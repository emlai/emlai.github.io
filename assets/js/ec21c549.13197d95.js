"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3255],{3905:(e,n,a)=>{a.d(n,{Zo:()=>m,kt:()=>u});var t=a(7294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},m=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=p(a),u=r,f=d["".concat(s,".").concat(u)]||d[u]||c[u]||i;return a?t.createElement(f,l(l({ref:n},m),{},{components:a})):t.createElement(f,l({ref:n},m))}));function u(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6113:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var t=a(7462),r=(a(7294),a(3905));const i={},l="Qualified names and member access",o={unversionedId:"docs/design/expressions/member_access",id:"docs/design/expressions/member_access",title:"Qualified names and member access",description:"\x3c!--",source:"@site/../docs/design/expressions/member_access.md",sourceDirName:"docs/design/expressions",slug:"/docs/design/expressions/member_access",permalink:"/docs/design/expressions/member_access",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/design/expressions/member_access.md",tags:[],version:"current",frontMatter:{},sidebar:"design",previous:{title:"Logical operators",permalink:"/docs/design/expressions/logical_operators"},next:{title:"Functions",permalink:"/docs/design/functions"}},s={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Member resolution",id:"member-resolution",level:2},{value:"Package and namespace members",id:"package-and-namespace-members",level:3},{value:"Lookup within values",id:"lookup-within-values",level:3},{value:"Templates and generics",id:"templates-and-generics",level:4},{value:"Lookup ambiguity",id:"lookup-ambiguity",level:4},{value:"<code>impl</code> lookup",id:"impl-lookup",level:2},{value:"Instance binding",id:"instance-binding",level:2},{value:"Non-instance members",id:"non-instance-members",level:2},{value:"Non-vacuous member access restriction",id:"non-vacuous-member-access-restriction",level:2},{value:"Precedence and associativity",id:"precedence-and-associativity",level:2},{value:"Alternatives considered",id:"alternatives-considered",level:2},{value:"References",id:"references",level:2}],m={toc:p};function c(e){let{components:n,...a}=e;return(0,r.kt)("wrapper",(0,t.Z)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"qualified-names-and-member-access"},"Qualified names and member access"),(0,r.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#member-resolution"},"Member resolution"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#package-and-namespace-members"},"Package and namespace members")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#lookup-within-values"},"Lookup within values"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#templates-and-generics"},"Templates and generics")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#lookup-ambiguity"},"Lookup ambiguity")))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#impl-lookup"},(0,r.kt)("inlineCode",{parentName:"a"},"impl")," lookup")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#instance-binding"},"Instance binding")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#non-instance-members"},"Non-instance members")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#non-vacuous-member-access-restriction"},"Non-vacuous member access restriction")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#precedence-and-associativity"},"Precedence and associativity")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"qualified name")," is a ",(0,r.kt)("a",{parentName:"p",href:"/docs/design/lexical_conventions/words"},"word")," that is preceded\nby a period. The name is found within a contextually determined entity:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In a member access expression, this is the entity preceding the period."),(0,r.kt)("li",{parentName:"ul"},"For a designator in a struct literal, the name is introduced as a member of\nthe struct type.")),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"member access expression")," allows a member of a value, type, interface,\nnamespace, and so on to be accessed by specifying a qualified name for the\nmember."),(0,r.kt)("p",null,"A member access expression is either a ",(0,r.kt)("em",{parentName:"p"},"simple")," member access expression of the\nform:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"member-access-expression")," ::= ",(0,r.kt)("em",{parentName:"li"},"expression")," ",(0,r.kt)("inlineCode",{parentName:"li"},".")," ",(0,r.kt)("em",{parentName:"li"},"word"))),(0,r.kt)("p",null,"or a ",(0,r.kt)("em",{parentName:"p"},"compound")," member access of the form:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"member-access-expression")," ::= ",(0,r.kt)("em",{parentName:"li"},"expression")," ",(0,r.kt)("inlineCode",{parentName:"li"},".")," ",(0,r.kt)("inlineCode",{parentName:"li"},"(")," ",(0,r.kt)("em",{parentName:"li"},"expression")," ",(0,r.kt)("inlineCode",{parentName:"li"},")"))),(0,r.kt)("p",null,"Compound member accesses allow specifying a qualified member name."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"package Widgets api;\ninterface Widget {\n  fn Grow[addr me: Self*](factor: f64);\n}\nclass Cog {\n  var size: i32;\n  fn Make(size: i32) -> Self;\n  impl as Widgets.Widget;\n}\n\nfn GrowSomeCogs() {\n  var cog1: Cog = Cog.Make(1);\n  var cog2: Cog = cog1.Make(2);\n  let cog1_size: i32 = cog1.size;\n  cog1.Grow(1.5);\n  cog2.(Cog.Grow)(cog1_size as f64);\n  cog1.(Widget.Grow)(1.1);\n  cog2.(Widgets.Cog.(Widgets.Widget.Grow))(1.9);\n}\n")),(0,r.kt)("p",null,"A member access expression is processed using the following steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"First, the word or parenthesized expression to the right of the ",(0,r.kt)("inlineCode",{parentName:"li"},".")," is\n",(0,r.kt)("a",{parentName:"li",href:"#member-resolution"},"resolved")," to a specific member entity, called ",(0,r.kt)("inlineCode",{parentName:"li"},"M")," in\nthis document."),(0,r.kt)("li",{parentName:"ul"},"Then, if necessary, ",(0,r.kt)("a",{parentName:"li",href:"#impl-lookup"},(0,r.kt)("inlineCode",{parentName:"a"},"impl")," lookup")," is performed to map from a\nmember of an interface to a member of the relevant ",(0,r.kt)("inlineCode",{parentName:"li"},"impl"),", potentially\nupdating ",(0,r.kt)("inlineCode",{parentName:"li"},"M"),"."),(0,r.kt)("li",{parentName:"ul"},"Then, if necessary, ",(0,r.kt)("a",{parentName:"li",href:"#instance-binding"},"instance binding")," is performed to\nlocate the member subobject corresponding to a field name or to build a\nbound method object, producing the result of the member access expression."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("a",{parentName:"li",href:"#non-instance-members"},"instance binding is not performed"),", the result is\n",(0,r.kt)("inlineCode",{parentName:"li"},"M"),".")),(0,r.kt)("h2",{id:"member-resolution"},"Member resolution"),(0,r.kt)("p",null,"The process of ",(0,r.kt)("em",{parentName:"p"},"member resolution")," determines which member ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," a member access\nexpression is referring to."),(0,r.kt)("h3",{id:"package-and-namespace-members"},"Package and namespace members"),(0,r.kt)("p",null,"If the first operand is a package or namespace name, the expression must be a\nsimple member access expression. The ",(0,r.kt)("em",{parentName:"p"},"word")," must name a member of that package\nor namespace, and the result is the package or namespace member with that name."),(0,r.kt)("p",null,"An expression that names a package or namespace can only be used as the first\noperand of a member access or as the target of an ",(0,r.kt)("inlineCode",{parentName:"p"},"alias")," declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"namespace MyNamespace;\nfn MyNamespace.MyFunction() {}\n\n// \u2705 OK, can alias a namespace.\nalias MyNS = MyNamespace;\nfn CallMyFunction() { MyNS.MyFunction(); }\n\n// \u274c Error: a namespace is not a value.\nlet MyNS2:! auto = MyNamespace;\n\nfn CallMyFunction2() {\n  // \u274c Error: cannot perform compound member access into a namespace.\n  MyNamespace.(MyNamespace.MyFunction)();\n}\n")),(0,r.kt)("h3",{id:"lookup-within-values"},"Lookup within values"),(0,r.kt)("p",null,"When the first operand is not a package or namespace name, there are three\nremaining cases we wish to support:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The first operand is a value, and lookup should consider members of the\nvalue's type."),(0,r.kt)("li",{parentName:"ul"},"The first operand is a type, and lookup should consider members of that\ntype. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"i32.Least")," should find the member constant ",(0,r.kt)("inlineCode",{parentName:"li"},"Least")," of\nthe type ",(0,r.kt)("inlineCode",{parentName:"li"},"i32"),"."),(0,r.kt)("li",{parentName:"ul"},"The first operand is a type-of-type, and lookup should consider members of\nthat type-of-type. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"Addable.Add")," should find the member\nfunction ",(0,r.kt)("inlineCode",{parentName:"li"},"Add")," of the interface ",(0,r.kt)("inlineCode",{parentName:"li"},"Addable"),". Because a type-of-type is a type,\nthis is a special case of the previous bullet.")),(0,r.kt)("p",null,"Note that because a type is a value, and a type-of-type is a type, these cases\nare overlapping and not entirely separable."),(0,r.kt)("p",null,"If any of the above lookups ever looks for members of a type parameter, it\nshould consider members of the type-of-type, treating the type parameter as an\narchetype."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," If lookup is performed into a type that involves a template parameter,\nthe lookup will be performed both in the context of the template definition and\nin the context of the template instantiation, as described in\n",(0,r.kt)("a",{parentName:"p",href:"#templates-and-generics"},"templates and generics"),"."),(0,r.kt)("p",null,"For a simple member access, the word is looked up in the following types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the first operand can be evaluated and evaluates to a type, that type."),(0,r.kt)("li",{parentName:"ul"},"If the type of the first operand can be evaluated, that type."),(0,r.kt)("li",{parentName:"ul"},"If the type of the first operand is a generic type parameter, and the type\nof that generic type parameter can be evaluated, that type-of-type.")),(0,r.kt)("p",null,"The results of these lookups are ",(0,r.kt)("a",{parentName:"p",href:"#lookup-ambiguity"},"combined"),"."),(0,r.kt)("p",null,"For a compound member access, the second operand is evaluated as a constant to\ndetermine the member being accessed. The evaluation is required to succeed and\nto result in a member of a type or interface."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"interface Printable {\n  fn Print[me: Self]();\n}\nexternal impl i32 as Printable;\nclass Point {\n  var x: i32;\n  var y: i32;\n  // Internal impl injects the name `Print` into class `Point`.\n  impl as Printable;\n}\n\nfn PrintPointTwice() {\n  var p: Point = {.x = 0, .y = 0};\n\n  // \u2705 OK, `x` found in type of `p`, namely `Point`.\n  p.x = 1;\n  // \u2705 OK, `y` found in the type `Point`.\n  p.(Point.y) = 1;\n\n  // \u2705 OK, `Print` found in type of `p`, namely `Point`.\n  p.Print();\n  // \u2705 OK, `Print` found in the type `Printable`.\n  p.(Printable.Print)();\n}\nfn GenericPrint[T:! Printable](a: T) {\n  // \u2705 OK, type of `a` is the type parameter `T`;\n  // `Print` found in the type of `T`, namely `Printable`.\n  a.Print();\n}\nfn CallGenericPrint(p: Point) {\n  GenericPrint(p);\n}\n")),(0,r.kt)("h4",{id:"templates-and-generics"},"Templates and generics"),(0,r.kt)("p",null,"If the value or type of the first operand depends on a template or generic\nparameter, the lookup is performed from a context where the value of that\nparameter is unknown. Evaluation of an expression involving the parameter may\nstill succeed, but will result in a symbolic value involving that parameter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class GenericWrapper(T:! Type) {\n  var field: T;\n}\nfn F[T:! Type](x: GenericWrapper(T)) -> T {\n  // \u2705 OK, finds `GenericWrapper(T).field`.\n  return x.field;\n}\n\nclass TemplateWrapper(template T:! Type) {\n  var field: T;\n}\nfn G[template T:! Type](x: TemplateWrapper(T)) -> T {\n  // \ud83e\udd37 Not yet decided.\n  return x.field;\n}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"TODO:")," The behavior of ",(0,r.kt)("inlineCode",{parentName:"p"},"G")," above is not yet fully decided. If class\ntemplates can be specialized, then we cannot know the members of\n",(0,r.kt)("inlineCode",{parentName:"p"},"TemplateWrapper(T)")," without knowing ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", so this first lookup will find\nnothing. In any case, as described below, the lookup will be performed again\nwhen ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is known.")),(0,r.kt)("p",null,"If the value or type depends on any template parameters, the lookup is redone\nfrom a context where the values of those parameters are known, but where the\nvalues of any generic parameters are still unknown. The lookup results from\nthese two contexts are ",(0,r.kt)("a",{parentName:"p",href:"#lookup-ambiguity"},"combined"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," All lookups are done from a context where the values of any generic\nparameters that are in scope are unknown. Unlike for a template parameter, the\nactual value of a generic parameter never affects the result of member\nresolution."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"class Cowboy { fn Draw[me: Self](); }\ninterface Renderable {\n  fn Draw[me: Self]();\n}\nexternal impl Cowboy as Renderable { fn Draw[me: Self](); }\nfn DrawDirect(c: Cowboy) { c.Draw(); }\nfn DrawGeneric[T:! Renderable](c: T) { c.Draw(); }\nfn DrawTemplate[template T:! Renderable](c: T) { c.Draw(); }\n\nfn Draw(c: Cowboy) {\n  // \u2705 Calls member of `Cowboy`.\n  DrawDirect(c);\n  // \u2705 Calls member of `impl Cowboy as Renderable`.\n  DrawGeneric(c);\n  // \u274c Error: ambiguous.\n  DrawTemplate(c);\n}\n\nclass RoundWidget {\n  external impl as Renderable {\n    fn Draw[me: Self]();\n  }\n  alias Draw = Renderable.Draw;\n}\n\nclass SquareWidget {\n  fn Draw[me: Self]() {}\n  external impl as Renderable {\n    alias Draw = Self.Draw;\n  }\n}\n\nfn DrawWidget(r: RoundWidget, s: SquareWidget) {\n  // \u2705 OK, lookup in type and lookup in type-of-type find the same entity.\n  DrawTemplate(r);\n\n  // \u2705 OK, lookup in type and lookup in type-of-type find the same entity.\n  DrawTemplate(s);\n\n  // \u2705 OK, found in type.\n  r.Draw();\n  s.Draw();\n}\n")),(0,r.kt)("h4",{id:"lookup-ambiguity"},"Lookup ambiguity"),(0,r.kt)("p",null,"Multiple lookups can be performed when resolving a member access expression. If\nmore than one member is found, after performing ",(0,r.kt)("a",{parentName:"p",href:"#impl-lookup"},(0,r.kt)("inlineCode",{parentName:"a"},"impl")," lookup")," if\nnecessary, the lookup is ambiguous, and the program is invalid. Similarly, if no\nmembers are found, the program is invalid. Otherwise, the result of combining\nthe lookup results is the unique member that was found."),(0,r.kt)("h2",{id:"impl-lookup"},(0,r.kt)("inlineCode",{parentName:"h2"},"impl")," lookup"),(0,r.kt)("p",null,"When the second operand of a member access expression resolves to a member of an\ninterface ",(0,r.kt)("inlineCode",{parentName:"p"},"I"),", and the first operand is a value other than a type-of-type,\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"impl")," lookup")," is performed to map the member of the interface to the\ncorresponding member of the relevant ",(0,r.kt)("inlineCode",{parentName:"p"},"impl"),". The member of the ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," replaces\nthe member of the interface in all further processing of the member access\nexpression."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"interface Addable {\n  // #1\n  fn Add[me: Self](other: Self) -> Self;\n  // #2\n  default fn Sum[Seq:! Iterable where .ValueType = Self](seq: Seq) -> Self {\n    // ...\n  }\n}\n\nclass Integer {\n  impl as Addable {\n    // #3\n    fn Add[me: Self](other: Self) -> Self;\n    // #4, generated from default implementation for #2.\n    // fn Sum[...](...);\n  }\n}\n\nfn SumIntegers(v: Vector(Integer)) -> Integer {\n  // Member resolution resolves the name `Sum` to #2.\n  // `impl` lookup then locates the `impl Integer as Addable`,\n  // and determines that the member access refers to #4,\n  // which is then called.\n  return Integer.Sum(v);\n}\n\nfn AddTwoIntegers(a: Integer, b: Integer) -> Integer {\n  // Member resolution resolves the name `Add` to #1.\n  // `impl` lookup then locates the `impl Integer as Addable`,\n  // and determines that the member access refers to #3.\n  // Finally, instance binding will be performed as described later.\n  // This can be written more verbosely and explicitly as any of:\n  // -   `return a.(Integer.Add)(b);`\n  // -   `return a.(Addable.Add)(b);`\n  // -   `return a.(Integer.(Addable.Add))(b);`\n  return a.Add(b);\n}\n")),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," that is expected to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," depends on the first operand of\nthe member access expression, ",(0,r.kt)("inlineCode",{parentName:"p"},"V"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"V")," can be evaluated and evaluates to a type, then ",(0,r.kt)("inlineCode",{parentName:"li"},"T")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"V"),".",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"// `V` is `Integer`. `T` is `V`, which is `Integer`.\n// Alias refers to #2.\nalias AddIntegers = Integer.Add;\n"))),(0,r.kt)("li",{parentName:"ul"},"Otherwise, ",(0,r.kt)("inlineCode",{parentName:"li"},"T")," is the type of ",(0,r.kt)("inlineCode",{parentName:"li"},"V"),".",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"let a: Integer = {};\n// `V` is `a`. `T` is the type of `V`, which is `Integer`.\n// `a.Add` refers to #2.\nlet twice_a: Integer = a.Add(a);\n")))),(0,r.kt)("p",null,"The appropriate ",(0,r.kt)("inlineCode",{parentName:"p"},"impl T as I")," implementation is located. The program is invalid\nif no such ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," exists. When ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," depends on a generic parameter, a\nsuitable constraint must be specified to ensure that such an ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," will exist.\nWhen ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," depends on a template parameter, this check is deferred until\nthe argument for the template parameter is known."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"M")," is replaced by the member of the ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," that corresponds to ",(0,r.kt)("inlineCode",{parentName:"p"},"M"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"interface I {\n  // #1\n  default fn F[me: Self]() {}\n  let N:! i32;\n}\nclass C {\n  impl as I where .N = 5 {\n    // #2\n    fn F[me: C]() {}\n  }\n}\n\n// `V` is `I` and `M` is `I.F`. Because `V` is a type-of-type,\n// `impl` lookup is not performed, and the alias binds to #1.\nalias A1 = I.F;\n\n// `V` is `C` and `M` is `I.F`. Because `V` is a type, `impl`\n// lookup is performed with `T` being `C`, and the alias binds to #2.\nalias A2 = C.F;\n\nlet c: C = {};\n\n// `V` is `c` and `M` is `I.N`. Because `V` is a non-type, `impl`\n// lookup is performed with `T` being the type of `c`, namely `C`, and\n// `M` becomes the associated constant from `impl C as I`.\n// The value of `Z` is 5.\nlet Z: i32 = c.N;\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#instance-binding"},"Instance binding")," may also apply if the member is an\ninstance member."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"var c: C;\n// `V` is `c` and `M` is `I.F`. Because `V` is not a type, `T` is the\n// type of `c`, which is `C`. `impl` lookup is performed, and `M` is\n// replaced with #2. Then instance binding is performed.\nc.F();\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," When an interface member is added to a class by an alias, ",(0,r.kt)("inlineCode",{parentName:"p"},"impl"),"\nlookup is not performed as part of handling the alias, but will happen when\nnaming the interface member as a member of the class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},'interface Renderable {\n  // #1\n  fn Draw[me: Self]();\n}\n\nclass RoundWidget {\n  external impl as Renderable {\n    // #2\n    fn Draw[me: Self]();\n  }\n  // `Draw` names the member of the `Renderable` interface.\n  alias Draw = Renderable.Draw;\n}\n\nclass SquareWidget {\n  // #3\n  fn Draw[me: Self]() {}\n  external impl as Renderable {\n    alias Draw = Self.Draw;\n  }\n}\n\nfn DrawWidget(r: RoundWidget, s: SquareWidget) {\n  // \u2705 OK: In the inner member access, the name `Draw` resolves to the\n  // member `Draw` of `Renderable`, #1, which `impl` lookup replaces with\n  // the member `Draw` of `impl RoundWidget as Renderable`, #2.\n  // The outer member access then forms a bound member function that\n  // calls #2 on `r`, as described in "Instance binding".\n  r.(RoundWidget.Draw)();\n\n  // \u2705 OK: In the inner member access, the name `Draw` resolves to the\n  // member `Draw` of `SquareWidget`, #3.\n  // The outer member access then forms a bound member function that\n  // calls #3 on `s`.\n  s.(SquareWidget.Draw)();\n\n  // \u274c Error: In the inner member access, the name `Draw` resolves to the\n  // member `Draw` of `SquareWidget`, #3.\n  // The outer member access fails because we can\'t call\n  // #3, `Draw[me: SquareWidget]()`, on a `RoundWidget` object `r`.\n  r.(SquareWidget.Draw)();\n\n  // \u274c Error: In the inner member access, the name `Draw` resolves to the\n  // member `Draw` of `Renderable`, #1, which `impl` lookup replaces with\n  // the member `Draw` of `impl RoundWidget as Renderable`, #2.\n  // The outer member access fails because we can\'t call\n  // #2, `Draw[me: RoundWidget]()`, on a `SquareWidget` object `s`.\n  s.(RoundWidget.Draw)();\n}\n\nbase class WidgetBase {\n  // \u2705 OK, even though `WidgetBase` does not implement `Renderable`.\n  alias Draw = Renderable.Draw;\n  fn DrawAll[T:! Renderable](v: Vector(T)) {\n    for (var w: T in v) {\n      // \u2705 OK. Unqualified lookup for `Draw` finds alias `WidgetBase.Draw`\n      // to `Renderable.Draw`, which does not perform `impl` lookup yet.\n      // Then the compound member access expression performs `impl` lookup\n      // into `impl T as Renderable`, since `T` is known to implement\n      // `Renderable`. Finally, the member function is bound to `w` as\n      // described in "Instance binding".\n      w.(Draw)();\n      // \u274c Error: `Self.Draw` performs `impl` lookup, which fails\n      // because `WidgetBase` does not implement `Renderable`.\n      w.(Self.Draw)();\n    }\n  }\n}\n\nclass TriangleWidget extends WidgetBase {\n  external impl as Renderable;\n}\nfn DrawTriangle(t: TriangleWidget) {\n  // \u2705 OK: name `Draw` resolves to `Draw` member of `WidgetBase`, which\n  // is `Renderable.Draw`. Then impl lookup replaces that with `Draw`\n  // member of `impl TriangleWidget as Renderable`.\n  t.Draw();\n}\n')),(0,r.kt)("h2",{id:"instance-binding"},"Instance binding"),(0,r.kt)("p",null,"If member resolution and ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," lookup produce a member ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," that is an instance\nmember -- that is, a field or a method -- and the first operand ",(0,r.kt)("inlineCode",{parentName:"p"},"V")," of ",(0,r.kt)("inlineCode",{parentName:"p"},".")," is a\nvalue other than a type, then ",(0,r.kt)("em",{parentName:"p"},"instance binding")," is performed, as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For a field member in class ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"V")," is required to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"C")," or of a\ntype derived from ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),". The result is the corresponding subobject within ",(0,r.kt)("inlineCode",{parentName:"p"},"V"),".\nThe result is an lvalue if ",(0,r.kt)("inlineCode",{parentName:"p"},"V")," is an lvalue."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"var dims: auto = {.width = 1, .height = 2};\n// `dims.width` denotes the field `width` of the object `dims`.\nPrint(dims.width);\n// `dims` is an lvalue, so `dims.height` is an lvalue.\ndims.height = 3;\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For a method, the result is a ",(0,r.kt)("em",{parentName:"p"},"bound method"),", which is a value ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," such that\na function call ",(0,r.kt)("inlineCode",{parentName:"p"},"F(args)")," behaves the same as a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"M(args)")," with the\n",(0,r.kt)("inlineCode",{parentName:"p"},"me")," parameter initialized by a corresponding recipient argument:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the method declares its ",(0,r.kt)("inlineCode",{parentName:"li"},"me")," parameter with ",(0,r.kt)("inlineCode",{parentName:"li"},"addr"),", the recipient\nargument is ",(0,r.kt)("inlineCode",{parentName:"li"},"&V"),"."),(0,r.kt)("li",{parentName:"ul"},"Otherwise, the recipient argument is ",(0,r.kt)("inlineCode",{parentName:"li"},"V"),".")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"class Blob {\n  fn Mutate[addr me: Self*](n: i32);\n}\nfn F(p: Blob*) {\n  // \u2705 OK, forms bound method `((*p).M)` and calls it.\n  // This calls `Blob.Mutate` with `me` initialized by `&(*p)`\n  // and `n` initialized by `5`.\n  (*p).Mutate(5);\n\n  // \u2705 OK, same as above.\n  let bound_m: auto = (*p).Mutate;\n  bound_m(5);\n}\n")))),(0,r.kt)("h2",{id:"non-instance-members"},"Non-instance members"),(0,r.kt)("p",null,"If instance binding is not performed, the result is the member ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," determined by\nmember resolution and ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," lookup. Evaluating the member access expression\nevaluates ",(0,r.kt)("inlineCode",{parentName:"p"},"V")," and discards the result."),(0,r.kt)("p",null,"An expression that names an instance member, but for which instance binding is\nnot performed, can only be used as the second operand of a compound member\naccess or as the target of an ",(0,r.kt)("inlineCode",{parentName:"p"},"alias")," declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-carbon"},"class C {\n  fn StaticMethod();\n  var field: i32;\n  class Nested {}\n}\nfn CallStaticMethod(c: C) {\n  // \u2705 OK, calls `C.StaticMethod`.\n  C.StaticMethod();\n\n  // \u2705 OK, evaluates expression `c` then calls `C.StaticMethod`.\n  c.StaticMethod();\n\n  // \u274c Error: name of instance member `C.field` can only be used in a\n  // member access or alias.\n  C.field = 1;\n  // \u2705 OK, instance binding is performed by outer member access,\n  // same as `c.field = 1;`\n  c.(C.field) = 1;\n\n  // \u2705 OK\n  let T:! Type = C.Nested;\n  // \u274c Error: value of `:!` binding is not constant because it\n  // refers to local variable `c`.\n  let U:! Type = c.Nested;\n}\n")),(0,r.kt)("h2",{id:"non-vacuous-member-access-restriction"},"Non-vacuous member access restriction"),(0,r.kt)("p",null,"The first operand of a member access expression must be used in some way: a\ncompound member access must result in ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," lookup, instance binding, or both.\nIn a simple member access, this always holds, because the first operand is\nalways used for lookup."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"interface Printable {\n  fn Print[me: Self]();\n}\nexternal impl i32 as Printable {\n  fn Print[me: Self]();\n}\nfn MemberAccess(n: i32) {\n  // \u2705 OK: `Printable.Print` is the interface member.\n  // `i32.(Printable.Print)` is the corresponding member of the `impl`.\n  // `n.(i32.(Printable.Print))` is a bound member function naming that member.\n  n.(i32.(Printable.Print))();\n\n  // \u2705 Same as above, `n.(Printable.Print)` is effectively interpreted as\n  // `n.(T.(Printable.Print))()`, where `T` is the type of `n`,\n  // because `n` does not evaluate to a type. Performs impl lookup\n  // and then instance binding.\n  n.(Printable.Print)();\n}\n\n// \u2705 OK, member `Print` of interface `Printable`.\nalias X1 = Printable.Print;\n// \u274c Error, compound access doesn't perform impl lookup or instance binding.\nalias X2 = Printable.(Printable.Print);\n// \u2705 OK, member `Print` of `impl i32 as Printable`.\nalias X3 = i32.(Printable.Print);\n// \u274c Error, compound access doesn't perform impl lookup or instance binding.\nalias X4 = i32.(i32.(Printable.Print));\n")),(0,r.kt)("h2",{id:"precedence-and-associativity"},"Precedence and associativity"),(0,r.kt)("p",null,"Member access expressions associate left-to-right:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class A {\n  class B {\n    fn F();\n  }\n}\ninterface B {\n  fn F();\n}\nexternal impl A as B;\n\nfn Use(a: A) {\n  // Calls member `F` of class `A.B`.\n  (a.B).F();\n  // Calls member `F` of interface `B`, as implemented by type `A`.\n  a.(B.F)();\n  // Same as `(a.B).F()`.\n  a.B.F();\n}\n")),(0,r.kt)("p",null,"Member access has lower precedence than primary expressions, and higher\nprecedence than all other expression forms."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// \u2705 OK, `*` has lower precedence than `.`. Same as `(A.B)*`.\nvar p: A.B*;\n// \u2705 OK, `1 + (X.Y)` not `(1 + X).Y`.\nvar n: i32 = 1 + X.Y;\n")),(0,r.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0989.md#separate-syntax-for-static-versus-dynamic-access"},"Separate syntax for static versus dynamic access, such as ",(0,r.kt)("inlineCode",{parentName:"a"},"::")," versus ",(0,r.kt)("inlineCode",{parentName:"a"},"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0989.md#use-a-different-lookup-rule-in-templates"},"Use a different lookup rule for names in templates")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0989.md#meaning-of-typeinterface"},"Meaning of ",(0,r.kt)("inlineCode",{parentName:"a"},"Type.Interface")))),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Proposal\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/989"},"#989: member access expressions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/949"},"Question for leads: constrained template name lookup"))))}c.isMDXComponent=!0}}]);