"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7888],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),h=i,u=d["".concat(l,".").concat(h)]||d[h]||m[h]||r;return n?a.createElement(u,s(s({ref:t},c),{},{components:n})):a.createElement(u,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1830:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},s="Generics: Terminology",o={unversionedId:"docs/design/generics/terminology",id:"docs/design/generics/terminology",title:"Generics: Terminology",description:"\x3c!--",source:"@site/../docs/design/generics/terminology.md",sourceDirName:"docs/design/generics",slug:"/docs/design/generics/terminology",permalink:"/docs/design/generics/terminology",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/design/generics/terminology.md",tags:[],version:"current",frontMatter:{},sidebar:"design",previous:{title:"Generics: Overview",permalink:"/docs/design/generics/overview"},next:{title:"Bidirectional interoperability with C/C++",permalink:"/docs/design/interoperability/"}},l={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Parameterized language constructs",id:"parameterized-language-constructs",level:2},{value:"Generic versus template parameters",id:"generic-versus-template-parameters",level:2},{value:"Polymorphism",id:"polymorphism",level:3},{value:"Parametric polymorphism",id:"parametric-polymorphism",level:4},{value:"Compile-time duck typing",id:"compile-time-duck-typing",level:4},{value:"Ad-hoc polymorphism",id:"ad-hoc-polymorphism",level:4},{value:"Constrained genericity",id:"constrained-genericity",level:3},{value:"Dependent names",id:"dependent-names",level:3},{value:"Definition checking",id:"definition-checking",level:3},{value:"Complete definition checking",id:"complete-definition-checking",level:4},{value:"Early versus late type checking",id:"early-versus-late-type-checking",level:4},{value:"Deduced parameter",id:"deduced-parameter",level:2},{value:"Interface",id:"interface",level:2},{value:"Structural interfaces",id:"structural-interfaces",level:3},{value:"Nominal interfaces",id:"nominal-interfaces",level:3},{value:"Named constraints",id:"named-constraints",level:3},{value:"Associated entity",id:"associated-entity",level:2},{value:"Impls: Implementations of interfaces",id:"impls-implementations-of-interfaces",level:2},{value:"Internal impl",id:"internal-impl",level:3},{value:"External impl",id:"external-impl",level:3},{value:"Member access",id:"member-access",level:2},{value:"Simple member access",id:"simple-member-access",level:3},{value:"Qualified member access expression",id:"qualified-member-access-expression",level:3},{value:"Compatible types",id:"compatible-types",level:2},{value:"Subtyping and casting",id:"subtyping-and-casting",level:2},{value:"Coherence",id:"coherence",level:2},{value:"Adapting a type",id:"adapting-a-type",level:2},{value:"Type erasure",id:"type-erasure",level:2},{value:"Archetype",id:"archetype",level:2},{value:"Extending an interface",id:"extending-an-interface",level:2},{value:"Witness tables",id:"witness-tables",level:2},{value:"Dynamic-dispatch witness table",id:"dynamic-dispatch-witness-table",level:3},{value:"Static-dispatch witness table",id:"static-dispatch-witness-table",level:3},{value:"Instantiation",id:"instantiation",level:2},{value:"Specialization",id:"specialization",level:2},{value:"Template specialization",id:"template-specialization",level:3},{value:"Generic specialization",id:"generic-specialization",level:3},{value:"Conditional conformance",id:"conditional-conformance",level:2},{value:"Interface type parameters and associated types",id:"interface-type-parameters-and-associated-types",level:2},{value:"Type constraints",id:"type-constraints",level:2},{value:"Type-of-type",id:"type-of-type",level:2},{value:"References",id:"references",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"generics-terminology"},"Generics: Terminology"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameterized-language-constructs"},"Parameterized language constructs")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generic-versus-template-parameters"},"Generic versus template parameters"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#polymorphism"},"Polymorphism"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parametric-polymorphism"},"Parametric polymorphism")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#compile-time-duck-typing"},"Compile-time duck typing")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#ad-hoc-polymorphism"},"Ad-hoc polymorphism")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#constrained-genericity"},"Constrained genericity")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dependent-names"},"Dependent names")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#definition-checking"},"Definition checking"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complete-definition-checking"},"Complete definition checking")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#early-versus-late-type-checking"},"Early versus late type checking")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#deduced-parameter"},"Deduced parameter")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface"},"Interface"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#structural-interfaces"},"Structural interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#nominal-interfaces"},"Nominal interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#named-constraints"},"Named constraints")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#associated-entity"},"Associated entity")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impls-implementations-of-interfaces"},"Impls: Implementations of interfaces"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#internal-impl"},"Internal impl")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#external-impl"},"External impl")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#member-access"},"Member access"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#simple-member-access"},"Simple member access")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#qualified-member-access-expression"},"Qualified member access expression")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#compatible-types"},"Compatible types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#subtyping-and-casting"},"Subtyping and casting")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#coherence"},"Coherence")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#adapting-a-type"},"Adapting a type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-erasure"},"Type erasure")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#archetype"},"Archetype")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#extending-an-interface"},"Extending an interface")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#witness-tables"},"Witness tables"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dynamic-dispatch-witness-table"},"Dynamic-dispatch witness table")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#static-dispatch-witness-table"},"Static-dispatch witness table")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#instantiation"},"Instantiation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#specialization"},"Specialization"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#template-specialization"},"Template specialization")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generic-specialization"},"Generic specialization")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#conditional-conformance"},"Conditional conformance")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-type-parameters-and-associated-types"},"Interface type parameters and associated types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-constraints"},"Type constraints")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-of-type"},"Type-of-type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,i.kt)("h2",{id:"parameterized-language-constructs"},"Parameterized language constructs"),(0,i.kt)("p",null,"Generally speaking, when we talk about either templates or a generics system, we\nare talking about generalizing some language construct by adding a parameter to\nit. Language constructs here primarily would include functions and types, but we\nmay want to support parameterizing other language constructs like\n",(0,i.kt)("a",{parentName:"p",href:"#interface-type-parameters-and-associated-types"},"interfaces"),"."),(0,i.kt)("p",null,"This parameter broadens the scope of the language construct on an axis defined\nby that parameter, for example it could define a family of functions instead of\na single one."),(0,i.kt)("h2",{id:"generic-versus-template-parameters"},"Generic versus template parameters"),(0,i.kt)("p",null,"When we are distinguishing between generics and templates in Carbon, it is on an\nparameter by parameter basis. A single function can take a mix of regular,\ngeneric, and template parameters."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Regular parameters"),', or "dynamic parameters", are designated using the\n"',"<","name>",(0,i.kt)("inlineCode",{parentName:"li"},":")," ","<",'type>" syntax (or "',"<",'value>").'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Generic parameters")," are designated using ",(0,i.kt)("inlineCode",{parentName:"li"},":!"),' between the name and the\ntype (so it is "',"<","name>",(0,i.kt)("inlineCode",{parentName:"li"},":!")," ","<",'type>").'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Template parameters"),' are designated using "',(0,i.kt)("inlineCode",{parentName:"li"},"template")," ","<","name>",(0,i.kt)("inlineCode",{parentName:"li"},":!"),"<",'type>".')),(0,i.kt)("p",null,"The syntax for generic and template parameters was decided in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/565"},"questions-for-leads issue #565"),"."),(0,i.kt)("p",null,"Expected difference between generics and templates:"),(0,i.kt)("table",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,(0,i.kt)("strong",null,"Generics")),(0,i.kt)("td",null,(0,i.kt)("strong",null,"Templates"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"bounded parametric polymorphism"),(0,i.kt)("td",null,"compile-time duck typing and ad-hoc polymorphism")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"constrained genericity"),(0,i.kt)("td",null,"optional constraints")),(0,i.kt)("tr",null,(0,i.kt)("td",null,'name lookup resolved for definitions in isolation ("early")'),(0,i.kt)("td",null,'some name lookup may require information from calls (name lookup may be "late")')),(0,i.kt)("tr",null,(0,i.kt)("td",null,'sound to typecheck definitions in isolation ("early")'),(0,i.kt)("td",null,'complete type checking may require information from calls (may be "late")')),(0,i.kt)("tr",null,(0,i.kt)("td",null,"supports separate type checking; may also support separate compilation, for example when implemented using dynamic witness tables"),(0,i.kt)("td",null,"separate compilation only to the extent that C++ supports it")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"allowed but not required to be implemented using dynamic dispatch"),(0,i.kt)("td",null,"does not support implementation by way of dynamic dispatch, just static by way of ",(0,i.kt)("a",{href:"#instantiation"},"instantiation"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"monomorphization is an optional optimization that cannot render the program invalid"),(0,i.kt)("td",null,"monomorphization is mandatory and can fail, resulting in the program being invalid"))),(0,i.kt)("h3",{id:"polymorphism"},"Polymorphism"),(0,i.kt)("p",null,"Generics and templates provide different forms of\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)"},"polymorphism"),"\nthan object-oriented programming with inheritance. That uses\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subtyping"},"subtype polymorphism"),' where different\ndescendants, or "subtypes", of a base class can provide different\nimplementations of a method, subject to some compatibility restrictions on the\nsignature.'),(0,i.kt)("h4",{id:"parametric-polymorphism"},"Parametric polymorphism"),(0,i.kt)("p",null,"Parametric polymorphism\n(",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Parametric_polymorphism"},"Wikipedia"),") is when a\nfunction or a data type can be written generically so that it can handle values\n",(0,i.kt)("em",{parentName:"p"},"identically")," without depending on their type.\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Parametric_polymorphism#Bounded_parametric_polymorphism"},"Bounded parametric polymorphism"),"\nis where the allowed types are restricted to satisfy some constraints. Within\nthe set of allowed types, different types are treated uniformly."),(0,i.kt)("h4",{id:"compile-time-duck-typing"},"Compile-time duck typing"),(0,i.kt)("p",null,"Duck typing (",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Duck_typing"},"Wikipedia"),") is when the\nlegal types for arguments are determined implicitly by the usage of the values\nof those types in the body of the function. Compile-time duck typing is when the\nusages in the body of the function are checked at compile-time, along all code\npaths. Contrast this with ordinary duck typing in a dynamic language such as\nPython where type errors are only diagnosed at runtime when a usage is reached\ndynamically."),(0,i.kt)("h4",{id:"ad-hoc-polymorphism"},"Ad-hoc polymorphism"),(0,i.kt)("p",null,"Ad-hoc polymorphism\n(",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ad_hoc_polymorphism"},"Wikipedia"),'), also known as\n"overloading", is when a single function name has multiple implementations for\nhandling different argument types. There is no enforcement of any consistency\nbetween the implementations. For example, the return type of each overload can\nbe arbitrary, rather than being the result of some consistent rule being applied\nto the argument types.'),(0,i.kt)("p",null,"Templates work with ad-hoc polymorphism in two ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A function with template parameters can be\n",(0,i.kt)("a",{parentName:"li",href:"#template-specialization"},"specialized")," in\n",(0,i.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/language/template_specialization"},"C++")," as\na form of ad-hoc polymorphism."),(0,i.kt)("li",{parentName:"ul"},"A function with template parameters can call overloaded functions since it\nwill only resolve that call after the types are known.")),(0,i.kt)("p",null,"In Carbon, we expect there to be a compile error if overloading of some name\nprevents a generic function from being typechecked from its definition alone.\nFor example, let's say we have some overloaded function called ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," that has two\noverloads:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[template T:! Type](x: T*) -> T;\nfn F(x: Int) -> Bool;\n")),(0,i.kt)("p",null,"A generic function ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," can call ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," with a type like ",(0,i.kt)("inlineCode",{parentName:"p"},"T*")," that can not possibly\ncall the ",(0,i.kt)("inlineCode",{parentName:"p"},"F(Int)")," overload for ",(0,i.kt)("inlineCode",{parentName:"p"},"F"),", and so it can consistently determine the\nreturn type of ",(0,i.kt)("inlineCode",{parentName:"p"},"F"),". But ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," can't call ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," with an argument that could match\neither overload."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," It is undecided what to do in the situation where ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," is overloaded,\nbut the signatures are consistent and so callers could still typecheck calls to\n",(0,i.kt)("inlineCode",{parentName:"p"},"F"),". This still poses problems for the dynamic strategy for compiling generics,\nin a similar way to impl specialization."),(0,i.kt)("h3",{id:"constrained-genericity"},"Constrained genericity"),(0,i.kt)("p",null,"We will allow some way of specifying constraints as part of a function (or type\nor other parameterized language construct). These constraints are a limit on\nwhat callers are allowed to pass in. The distinction between constrained and\nunconstrained genericity is whether the body of the function is limited to just\nthose operations that are guaranteed by the constraints."),(0,i.kt)("p",null,"With templates using unconstrained genericity, you may perform any operation in\nthe body of the function, and they will be checked against the specific types\nused in calls. You can still have constraints, but they are optional in that\nthey could be removed and the function would still have the same capabilities.\nConstraints only affect the caller, which will use them to resolve overloaded\ncalls to the template and provide clearer error messages."),(0,i.kt)("p",null,"With generics using constrained genericity, the function body can be checked\nagainst the signature at the time of definition. Note that it is still perfectly\npermissible to have no constraints on a type; that just means that you can only\nperform operations that work for all types (such as manipulate pointers to\nvalues of that type) in the body of the function."),(0,i.kt)("h3",{id:"dependent-names"},"Dependent names"),(0,i.kt)("p",null,"A name is said to be ",(0,i.kt)("em",{parentName:"p"},"dependent")," if it depends on some generic or template\nparameter. Note: this matches\n",(0,i.kt)("a",{parentName:"p",href:"https://www.google.com/search?q=c%2B%2B+dependent+name"},'the use of the term "dependent" in C++'),",\nnot as in ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dependent_type"},"dependent types"),"."),(0,i.kt)("h3",{id:"definition-checking"},"Definition checking"),(0,i.kt)("p",null,"Definition checking is the process of semantically checking the definition of\nparameterized code for correctness ",(0,i.kt)("em",{parentName:"p"},"independently")," of any particular arguments.\nIt includes type checking and other semantic checks. It is possible, even with\ntemplates, to check semantics of expressions that are not\n",(0,i.kt)("a",{parentName:"p",href:"#dependent-names"},"dependent")," on any template parameter in the definition.\nAdding constraints to template parameters and/or switching them to be generic\nallows the compiler to increase how much of the definition can be checked. Any\nremaining checks are delayed until ",(0,i.kt)("a",{parentName:"p",href:"#instantiation"},"instantiation"),", which can\nfail."),(0,i.kt)("h4",{id:"complete-definition-checking"},"Complete definition checking"),(0,i.kt)("p",null,"Complete definition checking is when the definition can be ",(0,i.kt)("em",{parentName:"p"},"fully")," semantically\nchecked, including type checking. It is an especially useful property because it\nenables ",(0,i.kt)("em",{parentName:"p"},"separate")," semantic checking of the definition, a prerequisite to\nseparate compilation. It also enables implementation strategies that don\u2019t\ninstantiate the implementation (for example, ",(0,i.kt)("a",{parentName:"p",href:"#type-erasure"},"type erasure")," or\n",(0,i.kt)("a",{parentName:"p",href:"#dynamic-dispatch-witness-table"},"dynamic-dispatch witness tables"),")."),(0,i.kt)("h4",{id:"early-versus-late-type-checking"},"Early versus late type checking"),(0,i.kt)("p",null,"Early type checking is where expressions and statements are type checked when\nthe definition of the function body is compiled, as part of definition checking.\nThis occurs for regular and generic values."),(0,i.kt)("p",null,"Late type checking is where expressions and statements may only be fully\ntypechecked once calling information is known. Late type checking delays\ncomplete definition checking. This occurs for\n",(0,i.kt)("a",{parentName:"p",href:"#dependent-names"},"template-dependent")," values."),(0,i.kt)("h2",{id:"deduced-parameter"},"Deduced parameter"),(0,i.kt)("p",null,"An deduced parameter is listed in the optional ",(0,i.kt)("inlineCode",{parentName:"p"},"[")," ",(0,i.kt)("inlineCode",{parentName:"p"},"]")," section right after the\nfunction name in a function signature:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fn")," ","<","name> ",(0,i.kt)("inlineCode",{parentName:"p"},"[")," ","<","deduced parameters> ",(0,i.kt)("inlineCode",{parentName:"p"},"](")," ","<","explicit parameters ",(0,i.kt)("inlineCode",{parentName:"p"},") ->"),"\n","<","return type>"),(0,i.kt)("p",null,"Deduced arguments are determined as a result of pattern matching the explicit\nargument values (usually the types of those values) to the explicit parameters.\nNote that function signatures can typically be rewritten to avoid using deduced\nparameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[template T:! Type](value: T);\n// is equivalent to:\nfn F(value: (template T:! Type));\n")),(0,i.kt)("p",null,"See more ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/overview#deduced-parameters"},"here"),"."),(0,i.kt)("h2",{id:"interface"},"Interface"),(0,i.kt)("p",null,"An interface is an API constraint used in a function signature to provide\nencapsulation. Encapsulation here means that callers of the function only need\nto know about the interface requirements to call the function, not anything\nabout the implementation of the function body, and the compiler can check the\nfunction body without knowing anything more about the caller. Callers of the\nfunction provide a value that has an implementation of the API and the body of\nthe function may then use that API (and nothing else)."),(0,i.kt)("h3",{id:"structural-interfaces"},"Structural interfaces"),(0,i.kt)("p",null,'A "structural" interface is one where we say a type satisfies the interface as\nlong as it has members with a specific list of names, and for each name it must\nhave some type or signature. A type can satisfy a structural interface without\never naming that interface, just by virtue of having members with the right\nform.'),(0,i.kt)("h3",{id:"nominal-interfaces"},"Nominal interfaces"),(0,i.kt)("p",null,'A "nominal" interface is one where we say a type can only satisfy an interface\nif there is some explicit statement saying so, for example by defining an\n',(0,i.kt)("a",{parentName:"p",href:"#impls-implementations-of-interfaces"},"impl"),'. This allows "satisfies the\ninterface" to have additional semantic meaning beyond what is directly checkable\nby the compiler. For example, knowing whether the ',(0,i.kt)("inlineCode",{parentName:"p"},"Draw"),' function means "render\nan image to the screen" or "take a card from the top of a deck of cards"; or\nthat a ',(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator is commutative (and not, say, string concatenation)."),(0,i.kt)("p",null,'We use the "structural" versus "nominal" terminology as a generalization of the\nsame terms being used in a\n',(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subtyping#Subtyping_schemes"},"subtyping context"),"."),(0,i.kt)("h3",{id:"named-constraints"},"Named constraints"),(0,i.kt)("p",null,"Named constraints are \"structural\" in the sense that they match a type based on\nmeeting some criteria rather than an explicit statement in the type's\ndefinition. The criteria for a named constraint, however, are less focused on\nthe type's API and instead might include a set of nominal interfaces that the\ntype must implement and constraints on the\n",(0,i.kt)("a",{parentName:"p",href:"#associated-entity"},"associated entities")," and\n",(0,i.kt)("a",{parentName:"p",href:"#interface-type-parameters-and-associated-types"},"interface type parameters"),"."),(0,i.kt)("h2",{id:"associated-entity"},"Associated entity"),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"associated entity")," is a requirement in an interface that a type's\nimplementation of the interface must satisfy by having a matching member. A\nrequirement that the type define a value for a member constant is called an\n",(0,i.kt)("em",{parentName:"p"},"associated constant"),", and similarly an ",(0,i.kt)("em",{parentName:"p"},"associated function")," or ",(0,i.kt)("em",{parentName:"p"},"associated\ntype"),"."),(0,i.kt)("p",null,"Different types can satisfy an interface with different definitions for a given\nmember. These definitions are ",(0,i.kt)("em",{parentName:"p"},"associated")," with what type is implementing the\ninterface. An ",(0,i.kt)("a",{parentName:"p",href:"#impls-implementations-of-interfaces"},"impl")," defines what is\nassociated with the type for that interface."),(0,i.kt)("p",null,"Rust uses the term\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/items/associated-items.html"},'"associated item"'),"\ninstead of associated entity."),(0,i.kt)("h2",{id:"impls-implementations-of-interfaces"},"Impls: Implementations of interfaces"),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"impl")," is an implementation of an interface for a specific type. It is the\nplace where the function bodies are defined, values for associated types, etc.\nare given. Impls are needed for ",(0,i.kt)("a",{parentName:"p",href:"#nominal-interfaces"},"nominal interfaces"),";\n",(0,i.kt)("a",{parentName:"p",href:"#structural-interfaces"},"structural interfaces")," and\n",(0,i.kt)("a",{parentName:"p",href:"#named-constraints"},"named constraints")," define conformance implicitly instead of\nby requiring an impl to be defined. In can still make sense to implement a named\nconstraint as a way to implement all of the interfaces it requires."),(0,i.kt)("h3",{id:"internal-impl"},"Internal impl"),(0,i.kt)("p",null,"A type that implements an interface ",(0,i.kt)("em",{parentName:"p"},"internally")," has all the named members of\nthe interface as named members of the type. This means that the members of the\ninterface are available by way of both\n",(0,i.kt)("a",{parentName:"p",href:"#member-access"},"simple member access and qualified member access expressions"),"."),(0,i.kt)("h3",{id:"external-impl"},"External impl"),(0,i.kt)("p",null,"In contrast, a type that implements an interface ",(0,i.kt)("em",{parentName:"p"},"externally")," does not include\nthe named members of the interface in the type. The members of the interface are\nstill implemented by the type, though, and so may be accessed using\n",(0,i.kt)("a",{parentName:"p",href:"#qualified-member-access-expression"},"qualified member access expressions")," for\nthose members."),(0,i.kt)("h2",{id:"member-access"},"Member access"),(0,i.kt)("p",null,"There are two different kinds of member access: ",(0,i.kt)("em",{parentName:"p"},"simple")," and ",(0,i.kt)("em",{parentName:"p"},"compound"),". See the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access"},"member access design document")," for\nthe details. The application to generics combines compound member access with\nqualified names, which we call a ",(0,i.kt)("em",{parentName:"p"},"qualified member access expression"),"."),(0,i.kt)("h3",{id:"simple-member-access"},"Simple member access"),(0,i.kt)("p",null,"Simple member access has the from ",(0,i.kt)("inlineCode",{parentName:"p"},"object.member"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"member")," is a word\nnaming a member of ",(0,i.kt)("inlineCode",{parentName:"p"},"object"),". This form may be used to access members of\ninterfaces ",(0,i.kt)("a",{parentName:"p",href:"#internal-impl"},"implemented internally")," by the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"object"),"."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Printable")," internally, then ",(0,i.kt)("inlineCode",{parentName:"p"},"s1.Print()")," calls the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Print")," method of ",(0,i.kt)("inlineCode",{parentName:"p"},"Printable")," using simple member access. In this case, the name\n",(0,i.kt)("inlineCode",{parentName:"p"},"Print")," is used without qualifying it with the name of the interface it is a\nmember of since it is recognized as a member of the type itself as well."),(0,i.kt)("h3",{id:"qualified-member-access-expression"},"Qualified member access expression"),(0,i.kt)("p",null,"Compound member access has the form ",(0,i.kt)("inlineCode",{parentName:"p"},"object.(expression)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"expression")," is\nresolved in the containing scope. A compound member access where the member\nexpression is a simple member access expression, as in ",(0,i.kt)("inlineCode",{parentName:"p"},"a.(context.b)"),", is\ncalled a ",(0,i.kt)("em",{parentName:"p"},"qualified member access expression"),". The member expression ",(0,i.kt)("inlineCode",{parentName:"p"},"context.b"),"\nmay be the ",(0,i.kt)("em",{parentName:"p"},"qualified member name")," of an interface member, that consists of the\nname of the interface, possibly qualified with a package or namespace name, a\ndot ",(0,i.kt)("inlineCode",{parentName:"p"},".")," and the name of the member."),(0,i.kt)("p",null,"For example, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," interface has a ",(0,i.kt)("inlineCode",{parentName:"p"},"Less")," member method, then the\nqualified name of that member is ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable.Less"),". So if ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," implements\n",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"s1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"s2")," are variables of type ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", then the ",(0,i.kt)("inlineCode",{parentName:"p"},"Less"),"\nmethod may be called using the qualified member name by writing the qualified\nmember access expression ",(0,i.kt)("inlineCode",{parentName:"p"},"s1.(Comparable.Less)(s2)"),"."),(0,i.kt)("p",null,"This form may be used to access any member of an interface implemented for a\ntype, whether it is implemented ",(0,i.kt)("a",{parentName:"p",href:"#internal-impl"},"internally")," or\n",(0,i.kt)("a",{parentName:"p",href:"#external-impl"},"externally"),"."),(0,i.kt)("h2",{id:"compatible-types"},"Compatible types"),(0,i.kt)("p",null,"Two types are compatible if they have the same notional set of values and\nrepresent those values in the same way, even if they expose different APIs. The\nrepresentation of a type describes how the values of that type are represented\nas a sequence of bits in memory. The set of values of a type includes properties\nthat the compiler can't directly see, such as invariants that the type\nmaintains."),(0,i.kt)("p",null,"We can't just say two types are compatible based on structural reasons. Instead,\nwe have specific constructs that create compatible types from existing types in\nways that encourage preserving the programmer's intended semantics and\ninvariants, such as implementing the API of the new type by calling (public)\nmethods of the original API, instead of accessing any private implementation\ndetails."),(0,i.kt)("h2",{id:"subtyping-and-casting"},"Subtyping and casting"),(0,i.kt)("p",null,"Both subtyping and casting are different names for changing the type of a value\nto a compatible type."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subtyping"},"Subtyping")," is a relationship between\ntwo types where you can safely operate on a value of one type using a variable\nof another. For example, using C++'s object-oriented features, you can operate\non a value of a derived class using a pointer to the base class. In most cases,\nyou can pass a more specific type to a function that can handle a more general\ntype. Return types work the opposite way, a function can return a more specific\ntype to a caller prepared to handle a more general type. This determines how\nfunction signatures can change from base class to derived class, see\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"},"covariance and contravariance in Wikipedia"),"."),(0,i.kt)("p",null,"In a generics context, we are specifically interested in the subtyping\nrelationships between ",(0,i.kt)("a",{parentName:"p",href:"#type-of-type"},"type-of-types"),". In particular, a\ntype-of-type encompasses a set of ",(0,i.kt)("a",{parentName:"p",href:"#type-constraints"},"type constraints"),", and you\ncan convert a type from a more-restrictive type-of-type to another type-of-type\nwhose constraints are implied by the first. C++ concepts terminology uses the\nterm\n",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/constraints#Partial_ordering_of_constraints"},'"subsumes"'),"\nto talk about this partial ordering of constraints, but we avoid that term since\nit is at odds with the use of the term in\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subtyping#Subsumption"},"object-oriented subtyping terminology"),"."),(0,i.kt)("p",null,"Note that subtyping is a bit like\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Type_conversion"},"coercion"),", except we want to\nmake it clear that the data representation of the value is not changing, just\nits type as reflected in the API available to manipulate the value."),(0,i.kt)("p",null,"Casting is indicated explicitly by way of some syntax in the source code. You\nmight use a cast to switch between ",(0,i.kt)("a",{parentName:"p",href:"#adapting-a-type"},"type adaptations"),', or to\nbe explicit where an implicit conversion would otherwise occur. For now, we are\nsaying "',(0,i.kt)("inlineCode",{parentName:"p"},"x as y"),'" is the provisional syntax in Carbon for casting the value ',(0,i.kt)("inlineCode",{parentName:"p"},"x"),"\nto the type ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),'. Note that outside of generics, the term "casting" includes any\nexplicit type change, including those that change the data representation.'),(0,i.kt)("p",null,"In contexts where an expression of one type is provided and a different type is\nrequired, an ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicit conversion")," is\nperformed if it is considered safe to do so. Such an implicit conversion, if\npermitted, always has the same meaning as an explicit cast."),(0,i.kt)("h2",{id:"coherence"},"Coherence"),(0,i.kt)("p",null,"A generics system has the ",(0,i.kt)("em",{parentName:"p"},"implementation coherence")," property, or simply\n",(0,i.kt)("em",{parentName:"p"},"coherence"),', if there is a single answer to the question "what is the\nimplementation of this interface for this type, if any?" independent of context,\nsuch as the libraries imported into a given file.'),(0,i.kt)("p",null,"This is typically enforced by making sure the definition of the implementation\nmust be imported if you import both the interface and the type. This may be done\nby requiring the implementation to be in the same library as the interface or\ntype. This is called an ",(0,i.kt)("em",{parentName:"p"},"orphan rule"),", meaning we don't allow an implementation\nthat is not with either of its parents (parent type or parent interface)."),(0,i.kt)("p",null,"Note that in addition to an orphan rule that implementations are visible when\nqueried, coherence also requires a rule for resolving what happens if there are\nmultiple non-orphan implementations. In Rust, this is called the\n",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/chalk/book/clauses/coherence.html#chalk-overlap-check"},"overlap rule or overlap check"),".\nThis could be just producing an error in that situation, or picking one using\nsome specialization rule."),(0,i.kt)("h2",{id:"adapting-a-type"},"Adapting a type"),(0,i.kt)("p",null,"A type can be adapted by creating a new type that is\n",(0,i.kt)("a",{parentName:"p",href:"#compatible-types"},"compatible")," with an existing type, but has a different API.\nIn particular, the new type might implement different interfaces or provide\ndifferent implementations of the same interfaces."),(0,i.kt)("p",null,"Unlike extending a type (as with C++ class inheritance), you are not allowed to\nadd new data fields onto the end of the representation -- you may only change\nthe API. This means that it is safe to ",(0,i.kt)("a",{parentName:"p",href:"#subtyping-and-casting"},"cast")," a value\nbetween those two types without any dynamic checks or danger of\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object_slicing"},"object slicing"),"."),(0,i.kt)("p",null,'This is called "newtype" in Rust, and is used for capturing additional\ninformation in types to improve type safety by moving some checking to compile\ntime (',(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/generics/new_types.html"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction"},"2"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html"},"3"),")\nand as a workaround for\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Ixrec/rust-orphan-rules#why-are-the-orphan-rules-controversial"},"Rust's orphan rules for coherence"),"."),(0,i.kt)("h2",{id:"type-erasure"},"Type erasure"),(0,i.kt)("p",null,'"Type erasure" is where a type\'s API is replaced by a subset. Everything outside\nof the preserved subset is said to have been "erased". This can happen in a\nvariety of contexts including both generics and runtime polymorphism. For\ngenerics, type erasure restricts a type to just the API required by the\nconstraints on a generic function.'),(0,i.kt)("p",null,"An example of type erasure in runtime polymorphism in C++ is casting from a\npointer of a derived type to a pointer to an abstract base type. Only the API of\nthe base type is available on the result, even though the implementation of\nthose methods still come from the derived type."),(0,i.kt)("p",null,'The term "type erasure" can also refer to\n',(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Generics_in_Java"},"the specific strategy used by Java to implement generics"),'.\nwhich includes erasing the identity of type parameters. This is not the meaning\nof "type erasure" used in Carbon.'),(0,i.kt)("h2",{id:"archetype"},"Archetype"),(0,i.kt)("p",null,"A placeholder type is used when type checking a function in place of a generic\ntype parameter. This allows type checking when the specific type to be used is\nnot known at type checking time. The type satisfies just its constraint and no\nmore, so it acts as the most general type satisfying the interface. In this way\nthe archetype is the supertype of all types satisfying the interface."),(0,i.kt)("p",null,"In addition to satisfying all the requirements of its constraint, the archetype\nalso has the member names of its constraint. Effectively it is considered to\n",(0,i.kt)("a",{parentName:"p",href:"#internal-impl"},"implement the constraint internally"),"."),(0,i.kt)("h2",{id:"extending-an-interface"},"Extending an interface"),(0,i.kt)("p",null,"An interface can be extended by defining an interface that includes the full API\nof another interface, plus some additional API. Types implementing the extended\ninterface should automatically be considered to have implemented the narrower\ninterface."),(0,i.kt)("h2",{id:"witness-tables"},"Witness tables"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/where-does-the-term-witness-table-come-from/54334/4"},"Witness tables"),"\nare an implementation strategy where values passed to a generic parameter are\ncompiled into a table of required functionality. That table is then filled in\nfor a given passed-in type with references to the implementation on the original\ntype. The generic is implemented using calls into entries in the witness table,\nwhich turn into calls to the original type. This doesn't necessarily imply a\nruntime indirection: it may be a purely compile-time separation of concerns.\nHowever, it insists on a full abstraction boundary between the generic user of a\ntype and the concrete implementation."),(0,i.kt)("p",null,"A simple way to imagine a witness table is as a struct of function pointers, one\nper method in the interface. However, in practice, it's more complex because it\nmust model things like associated types and interfaces."),(0,i.kt)("p",null,'Witness tables are called "dictionary passing" in Haskell. Outside of generics,\na ',(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_method_table"},"vtable")," is a witness\ntable that witnesses that a class is a descendant of an abstract base class, and\nis passed as part of the object instead of separately."),(0,i.kt)("h3",{id:"dynamic-dispatch-witness-table"},"Dynamic-dispatch witness table"),(0,i.kt)("p",null,"For dynamic-dispatch witness tables, actual function pointers are formed and\nused as a dynamic, runtime indirection. As a result, the generic code ",(0,i.kt)("strong",{parentName:"p"},"will\nnot")," be duplicated for different witness tables."),(0,i.kt)("h3",{id:"static-dispatch-witness-table"},"Static-dispatch witness table"),(0,i.kt)("p",null,"For static-dispatch witness tables, the implementation is required to collapse\nthe table indirections at compile time. As a result, the generic code ",(0,i.kt)("strong",{parentName:"p"},"will"),"\nbe duplicated for different witness tables."),(0,i.kt)("p",null,"Static-dispatch may be implemented as a performance optimization for\ndynamic-dispatch that increases generated code size. The final compiled output\nmay not retain the witness table."),(0,i.kt)("h2",{id:"instantiation"},"Instantiation"),(0,i.kt)("p",null,"Instantiation is the implementation strategy for templates in both C++ and\nCarbon. Instantiation explicitly creates a copy of the template code and\nreplaces the template components with the concrete type and its implementation\noperations. It allows duck typing and lazy binding. Instantiation implies\ntemplate code ",(0,i.kt)("strong",{parentName:"p"},"will")," be duplicated."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"#static-dispatch-witness-table"},"static-dispatch witness tables")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics"},"monomorphization (as in Rust)"),",\nthis is done ",(0,i.kt)("strong",{parentName:"p"},"before")," type checking completes. Only when the template is used\nwith a concrete type is the template fully type checked, and it type checks\nagainst the actual concrete type after substituting it into the template. This\nmeans that different instantiations may interpret the same construct in\ndifferent ways, and that templates can include constructs that are not valid for\nsome possible instantiations. However, it also means that some errors in the\ntemplate implementation may not produce errors until the instantiation occurs,\nand other errors may only happen for ",(0,i.kt)("strong",{parentName:"p"},"some")," instantiations."),(0,i.kt)("h2",{id:"specialization"},"Specialization"),(0,i.kt)("h3",{id:"template-specialization"},"Template specialization"),(0,i.kt)("p",null,"Specialization in C++ is essentially overloading in the context of a template.\nThe template is overloaded to have a different definition for some subset of the\npossible template argument values. For example, the C++ type ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T>"),"\nmight have a specialization ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T*>")," that is implemented in terms of\n",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<void*>")," to reduce code size. In C++, even the interface of a\ntemplated type can be changed in a specialization, as happens for\n",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<bool>"),"."),(0,i.kt)("h3",{id:"generic-specialization"},"Generic specialization"),(0,i.kt)("p",null,"Specialization of generics, or types used by generics, is restricted to changing\nthe implementation ",(0,i.kt)("em",{parentName:"p"},"without")," affecting the interface. This restriction is needed\nto preserve the ability to perform type checking of generic definitions that\nreference a type that can be specialized, without statically knowing which\nspecialization will be used."),(0,i.kt)("p",null,"While there is nothing fundamentally incompatible about specialization with\ngenerics, even when implemented using witness tables, the result may be\nsurprising because the selection of the specialized generic happens outside of\nthe witness-table-based indirection between the generic code and the concrete\nimplementation. Provided all selection relies exclusively on interfaces, this\nstill satisfies the fundamental constraints of generics."),(0,i.kt)("h2",{id:"conditional-conformance"},"Conditional conformance"),(0,i.kt)("p",null,"Conditional conformance is when you have a parameterized type that has one API\nthat it always supports, but satisfies additional interfaces under some\nconditions on the type argument. For example: ",(0,i.kt)("inlineCode",{parentName:"p"},"Array(T)")," might implement\n",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," itself implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable"),", using lexicographical order."),(0,i.kt)("h2",{id:"interface-type-parameters-and-associated-types"},"Interface type parameters and associated types"),(0,i.kt)("p",null,'Imagine an interface defining a container. Different containers will contain\ndifferent types of values, and the container API will have to refer to that\n"element type" when defining the signature of methods like "insert" or "find".\nIf that element type is a parameter (input) to the interface type, we say it is\nan ',(0,i.kt)("em",{parentName:"p"},"interface type parameter"),"; if it is an output, we say it is an ",(0,i.kt)("em",{parentName:"p"},"associated\ntype"),". An associated type is a kind of ",(0,i.kt)("a",{parentName:"p",href:"#associated-entity"},"associated entity"),"."),(0,i.kt)("p",null,"Interface type parameter example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface StackTP(ElementType:! Type)\n  fn Push[addr me: Self*](value: ElementType);\n  fn Pop[addr me: Self*]() -> ElementType;\n}\n")),(0,i.kt)("p",null,"Associated type example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface StackAT {\n  let ElementType:! Type;\n  fn Push[addr me: Self*](value: ElementType);\n  fn Pop[addr me: Self*]() -> ElementType;\n}\n")),(0,i.kt)("p",null,"Associated types are particularly called for when the implementation controls\nthe type, not the caller. For example, the iterator type for a container is\nspecific to the container and not something you would expect a user of the\ninterface to specify."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Iterator { ... }\ninterface Container {\n  // This does not make sense as an parameter to the container interface,\n  // since this type is determined from the container type.\n  let IteratorType:! Iterator;\n  ...\n  fn Insert[addr me: Self*](position: IteratorType, value: ElementType);\n}\nclass ListIterator(ElementType:! Type) {\n  ...\n  impl as Iterator;\n}\nclass List(ElementType:! Type) {\n  // Iterator type is determined by the container type.\n  impl as Container where .IteratorType = ListIterator(ElementType) {\n    fn Insert[addr me: Self*](position: IteratorType, value: ElementType) {\n      ...\n    }\n  }\n}\n")),(0,i.kt)("p",null,"If you have an interface with type parameters, a type can have multiple impls\nfor different combinations of type parameters. As a result, type parameters may\nnot be deduced in a function call. However, if the interface parameters are\nspecified, a type can only have a single implementation of the given interface.\nThis unique implementation choice determines the values of associated types."),(0,i.kt)("p",null,"For example, we might have an interface that says how to perform addition with\nanother type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Addable(T:! Type) {\n  let ResultType:! Type;\n  fn Add[me: Self](rhs: T) -> ResultType;\n}\n")),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," value might support addition with ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"u16"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"f64")," values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl i32 as Addable(i32) where .ResultType = i32 { ... }\nimpl i32 as Addable(u16) where .ResultType = i32 { ... }\nimpl i32 as Addable(f64) where .ResultType = f64 { ... }\n")),(0,i.kt)("p",null,"To write a generic function requiring a parameter to be ",(0,i.kt)("inlineCode",{parentName:"p"},"Addable"),", there needs\nto be some way to determine the type to add to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// \u2705 This is allowed, since the value of `T` is determined by the\n// `y` parameter.\nfn DoAdd[T:! Type, U:! Addable(T)](x: U, y: T) -> U.ResultType {\n  return x.Add(y);\n}\n\n// \u274c This is forbidden, can't uniquely determine `T`.\nfn CompileError[T:! Type, U:! Addable(T)](x: U) -> T;\n")),(0,i.kt)("p",null,"Once the interface parameter can be determined, that determines the values for\nassociated types, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"ResultType")," in the example. As always, calls with\ntypes for which no implementation exists will be rejected at the call site:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// \u274c This is forbidden, no implementation of `Addable(Orange)`\n// for `Apple`.\nDoAdd(apple, orange);\n")),(0,i.kt)("h2",{id:"type-constraints"},"Type constraints"),(0,i.kt)("p",null,"Type constraints restrict which types are legal for template or generic\nparameters or associated types. They help define semantics under which they\nshould be called, and prevent incorrect calls."),(0,i.kt)("p",null,"In general there are a number of different type relationships we would like to\nexpress, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This function accepts two containers. The container types may be different,\nbut the element types need to match."),(0,i.kt)("li",{parentName:"ul"},"For this container interface we have associated types for iterators and\nelements. The iterator type's element type needs to match the container's\nelement type."),(0,i.kt)("li",{parentName:"ul"},"An interface may define an associated type that needs to be constrained to\nimplement some interfaces."),(0,i.kt)("li",{parentName:"ul"},"This type must be ",(0,i.kt)("a",{parentName:"li",href:"#compatible-types"},"compatible")," with another type. You\nmight use this to define alternate implementations of a single interfaces,\nsuch as sorting order, for a single type.")),(0,i.kt)("p",null,"Note that type constraints can be a restriction on one type parameter or\nassociated type, or can define a relationship between multiple types."),(0,i.kt)("h2",{id:"type-of-type"},"Type-of-type"),(0,i.kt)("p",null,"A type-of-type is the type used when declaring some type parameter. It foremost\ndetermines which types are legal arguments for that type parameter, also known\nas ",(0,i.kt)("a",{parentName:"p",href:"#type-constraints"},"type constraints"),". For template parameters, that is all a\ntype-of-type does. For generic parameters, it also determines the API that is\navailable in the body of the function."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/447"},"#447: Generics terminology")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/731"},"#731: Generics details 2: adapters, associated types, parameterized interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/950"},"#950: Generic details 6: remove facets")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1013"},"#1013: Generics: Set associated constants using where constraints"))))}m.isMDXComponent=!0}}]);