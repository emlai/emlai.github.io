"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4583],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(a),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||o;return a?n.createElement(h,r(r({ref:t},u),{},{components:a})):n.createElement(h,r({ref:t},u))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},3478:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const o={},r="Interoperability philosophy and goals",l={unversionedId:"interoperability/philosophy_and_goals",id:"interoperability/philosophy_and_goals",title:"Interoperability philosophy and goals",description:"\x3c!--",source:"@site/../docs/design/interoperability/philosophy_and_goals.md",sourceDirName:"interoperability",slug:"/interoperability/philosophy_and_goals",permalink:"/design/interoperability/philosophy_and_goals",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/interoperability/philosophy_and_goals.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Bidirectional interoperability with C/C++",permalink:"/design/interoperability/"},next:{title:"Lexical conventions",permalink:"/design/lexical_conventions/"}},s={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Background",id:"background",level:2},{value:"Other interoperability layers",id:"other-interoperability-layers",level:3},{value:"Philosophy",id:"philosophy",level:2},{value:"Language goal influences",id:"language-goal-influences",level:2},{value:"Performance-critical software",id:"performance-critical-software",level:3},{value:"Software and language evolution",id:"software-and-language-evolution",level:3},{value:"Code that is easy to read, understand, and write",id:"code-that-is-easy-to-read-understand-and-write",level:3},{value:"Practical safety guarantees and testing mechanisms",id:"practical-safety-guarantees-and-testing-mechanisms",level:3},{value:"Fast and scalable development",id:"fast-and-scalable-development",level:3},{value:"Modern OS platforms, hardware architectures, and environments",id:"modern-os-platforms-hardware-architectures-and-environments",level:3},{value:"Interoperability with and migration from existing C++ code",id:"interoperability-with-and-migration-from-existing-c-code",level:3},{value:"Goals",id:"goals",level:2},{value:"Support mixing Carbon and C++ toolchains",id:"support-mixing-carbon-and-c-toolchains",level:3},{value:"Compatibility with the C++ memory model",id:"compatibility-with-the-c-memory-model",level:3},{value:"Minimize bridge code",id:"minimize-bridge-code",level:3},{value:"Unsurprising mappings between C++ and Carbon types",id:"unsurprising-mappings-between-c-and-carbon-types",level:3},{value:"Allow C++ bridge code in Carbon files",id:"allow-c-bridge-code-in-carbon-files",level:3},{value:"Carbon inheritance from C++ types",id:"carbon-inheritance-from-c-types",level:3},{value:"Support use of advanced C++ features",id:"support-use-of-advanced-c-features",level:3},{value:"Support basic C interoperability",id:"support-basic-c-interoperability",level:3},{value:"Non-goals",id:"non-goals",level:2},{value:"Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains",id:"full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains",level:3},{value:"Never require bridge code",id:"never-require-bridge-code",level:3},{value:"Convert all C++ types to Carbon types",id:"convert-all-c-types-to-carbon-types",level:3},{value:"Support for C++ exceptions without bridge code",id:"support-for-c-exceptions-without-bridge-code",level:3},{value:"Cross-language metaprogramming",id:"cross-language-metaprogramming",level:3},{value:"Offer equivalent support for languages other than C++",id:"offer-equivalent-support-for-languages-other-than-c",level:3},{value:"Open questions to be resolved later",id:"open-questions-to-be-resolved-later",level:2},{value:"Carbon type inheritance from non-pure interface C++ types",id:"carbon-type-inheritance-from-non-pure-interface-c-types",level:3},{value:"CRTP support",id:"crtp-support",level:3},{value:"Object lifetimes",id:"object-lifetimes",level:3},{value:"References",id:"references",level:2}],u={toc:p};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"interoperability-philosophy-and-goals"},"Interoperability philosophy and goals"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#background"},"Background"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#other-interoperability-layers"},"Other interoperability layers")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#philosophy"},"Philosophy")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#language-goal-influences"},"Language goal influences"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#performance-critical-software"},"Performance-critical software")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#software-and-language-evolution"},"Software and language evolution")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#code-that-is-easy-to-read-understand-and-write"},"Code that is easy to read, understand, and write")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#practical-safety-guarantees-and-testing-mechanisms"},"Practical safety guarantees and testing mechanisms")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#fast-and-scalable-development"},"Fast and scalable development")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#modern-os-platforms-hardware-architectures-and-environments"},"Modern OS platforms, hardware architectures, and environments")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interoperability-with-and-migration-from-existing-c-code"},"Interoperability with and migration from existing C++ code")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#goals"},"Goals"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#support-mixing-carbon-and-c-toolchains"},"Support mixing Carbon and C++ toolchains")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#compatibility-with-the-c-memory-model"},"Compatibility with the C++ memory model")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#minimize-bridge-code"},"Minimize bridge code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#unsurprising-mappings-between-c-and-carbon-types"},"Unsurprising mappings between C++ and Carbon types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#allow-c-bridge-code-in-carbon-files"},"Allow C++ bridge code in Carbon files")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#carbon-inheritance-from-c-types"},"Carbon inheritance from C++ types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#support-use-of-advanced-c-features"},"Support use of advanced C++ features")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#support-basic-c-interoperability"},"Support basic C interoperability")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#non-goals"},"Non-goals"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains"},"Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#never-require-bridge-code"},"Never require bridge code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#convert-all-c-types-to-carbon-types"},"Convert all C++ types to Carbon types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#support-for-c-exceptions-without-bridge-code"},"Support for C++ exceptions without bridge code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#cross-language-metaprogramming"},"Cross-language metaprogramming")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#offer-equivalent-support-for-languages-other-than-c"},"Offer equivalent support for languages other than C++")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#open-questions-to-be-resolved-later"},"Open questions to be resolved later"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#carbon-type-inheritance-from-non-pure-interface-c-types"},"Carbon type inheritance from non-pure interface C++ types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#crtp-support"},"CRTP support")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#object-lifetimes"},"Object lifetimes")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"Interoperability with and migration from C++ are a\n",(0,i.kt)("a",{parentName:"p",href:"/project/goals#interoperability-with-and-migration-from-existing-c-code"},"language goal"),".\nHowever, performance and evolution are\n",(0,i.kt)("a",{parentName:"p",href:"/project/goals#language-goals-and-priorities"},(0,i.kt)("em",{parentName:"a"},"higher")," priorities"),".\nThis interaction of priorities is important to understanding Carbon's\ninteroperability goals and trade-offs."),(0,i.kt)("h3",{id:"other-interoperability-layers"},"Other interoperability layers"),(0,i.kt)("p",null,"Other language interoperability layers that may offer useful examples are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html"},"Java/Kotlin"),"\nshould be a comparable interoperability story. The languages are different,\nbut share an underlying runtime. This may be closest to the model we desire\nfor Carbon.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html"},"JavaScript/TypeScript"),"\nis similar to C/C++, where one language is essentially a subset of the\nother, allowing high interoperability. This is an interesting reference\npoint, but we are looking at a different approach with a clearer boundary.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Java_Native_Interface"},"C++/Java")," is an\nexample of requiring specialized code for the bridge layer, making\ninteroperability more burden on developers. The burden of the approach may\nbe considered to correspond to the difference in language memory models and\nother language design choices. Regardless, the result can be considered\nhigher maintenance for developers than we want for Carbon.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://golang.org/cmd/cgo/"},"C++/Go")," is similar to C++/Java. However, Go\nnotably allows C++ bridge code to exist in the .go files, which can ease\nmaintenance of the bridge layer, and is desirable for Carbon."))),(0,i.kt)("h2",{id:"philosophy"},"Philosophy"),(0,i.kt)("p",null,"The C++ interoperability layer of Carbon allows a subset of C++ APIs to be\naccessed from Carbon code, and similarly a subset of Carbon APIs to be accessed\nfrom C++ code. This requires expressing one language as a subset of the other.\nBridge code may be needed to map some APIs into the relevant subset, but the\nconstraints on expressivity should be loose enough to keep the amount of such\nbridge code sustainable."),(0,i.kt)("p",null,"The design for interoperability between Carbon and C++ hinges on:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The ability to interoperate with a wide variety of code, such as\nclasses/structs and templates, not just free functions."),(0,i.kt)("li",{parentName:"ol"},"A willingness to expose the idioms of C++ into Carbon code, and the other\nway around, when necessary to maximize performance of the interoperability\nlayer."),(0,i.kt)("li",{parentName:"ol"},"The use of wrappers and generic programming, including templates, to\nminimize or eliminate runtime overhead.")),(0,i.kt)("p",null,"These things come together when looking at how custom data structures in C++ are\nexposed into Carbon, and the other way around. In both languages, it is\nreasonable and even common to have customized low-level data structures, such as\nassociative containers. For example, there are numerous data structures for\nmapping from a key to a value that might be best for a particular use case,\nincluding hash tables, linked hash tables, sorted vectors, and btrees. Even for\na given data structure, there may be slow but meaningful evolution in\nimplementations strategies."),(0,i.kt)("p",null,'The result is that it will often be reasonable to directly expose a C++ data\nstructure to Carbon without converting it to a "native" or "idiomatic" Carbon\ndata structure. Although interfaces may differ, a trivial adapter wrapper should\nbe sufficient. Many Carbon data structures should also be able to support\nmultiple implementations with C++ data structures being one such implementation,\nallowing for idiomatic use of C++ hidden behind Carbon.'),(0,i.kt)("p",null,"The reverse is also true. C++ code will often not care, or can be refactored to\nnot care, what specific data structure is used. Carbon data structures can be\nexposed as yet another implementation in C++, and wrapped to match C++ idioms\nand even templates."),(0,i.kt)("p",null,"For example, a C++ class template like ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T>")," should be usable without\nwrapper code or runtime overhead, and passing a Carbon type as ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". The\nresulting type should be equally usable from either C++ or Carbon code. It\nshould also be easy to wrap ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T>")," with a Carbon interface for\ntransparent use in idiomatic Carbon code."),(0,i.kt)("h2",{id:"language-goal-influences"},"Language goal influences"),(0,i.kt)("h3",{id:"performance-critical-software"},"Performance-critical software"),(0,i.kt)("p",null,"Interoperability with C++ will be frequently used in Carbon, whether it's C++\ndevelopers trying out Carbon, incrementally migrating a large C++ codebase, or\ncontinuing to use a C++ library long-term. In all cases, it must be possible to\nwrite interoperable code with zero overhead; copies must not be required."),(0,i.kt)("h3",{id:"software-and-language-evolution"},"Software and language evolution"),(0,i.kt)("p",null,"Interoperability will require the addition of features to Carbon which exist\nprimarily to support interoperability use cases. However, these features must\nnot unduly impinge the overall evolution of Carbon. In particular, only a subset\nof Carbon features will support interoperability with C++. To do otherwise would\nrestrict Carbon's feature set."),(0,i.kt)("h3",{id:"code-that-is-easy-to-read-understand-and-write"},"Code that is easy to read, understand, and write"),(0,i.kt)("p",null,"Interoperability-related Carbon code will likely be more difficult to read than\nother, more idiomatic Carbon code. This is okay: aiming to make Carbon code\nreadable doesn't mean that it needs to ",(0,i.kt)("em",{parentName:"p"},"all")," be trivial to read. At the same\ntime, the extra costs that interoperability exerts on Carbon developers should\nbe minimized."),(0,i.kt)("h3",{id:"practical-safety-guarantees-and-testing-mechanisms"},"Practical safety guarantees and testing mechanisms"),(0,i.kt)("p",null,"Safety is important to maintain around interoperability code, and mitigations\nshould be provided where possible. However, safety guarantees will be focused on\nnative Carbon code. C++ code will not benefit from the same set of safety\nmechanisms that Carbon offers, so Carbon code calling into C++ will accept\nhigher safety risks."),(0,i.kt)("h3",{id:"fast-and-scalable-development"},"Fast and scalable development"),(0,i.kt)("p",null,"The interoperability layer will likely have tooling limitations similar to C++.\nFor example, Carbon aims to compile quickly. However, C++ interoperability\nhinges on compiling C++ code, which is relatively slow. Carbon libraries that\nuse interoperability will see bottlenecks from C++ compile time. Improving C++\nis outside the scope of Carbon."),(0,i.kt)("h3",{id:"modern-os-platforms-hardware-architectures-and-environments"},"Modern OS platforms, hardware architectures, and environments"),(0,i.kt)("p",null,"Interoperability will apply to the intersection of environments supported by\nboth Carbon and C++. Pragmatically, Carbon will likely be the limiting factor\nhere."),(0,i.kt)("h3",{id:"interoperability-with-and-migration-from-existing-c-code"},"Interoperability with and migration from existing C++ code"),(0,i.kt)("p",null,"Carbon's language goal for interoperability will focus on C++17 compatibility.\nThe language design must be mindful of the prioritization; trade-offs harming\nother goals may still be made so long as they offer greater benefits for\ninteroperability and Carbon as a whole."),(0,i.kt)("p",null,"Although the below interoperability-specific goals will focus on\ninteroperability, it's also important to consider how migration would be\naffected. If interoperability requires complex work, particularly to avoid\nperformance impacts, it could impair the ability to incrementally migrate C++\ncodebases to Carbon."),(0,i.kt)("h2",{id:"goals"},"Goals"),(0,i.kt)("h3",{id:"support-mixing-carbon-and-c-toolchains"},"Support mixing Carbon and C++ toolchains"),(0,i.kt)("p",null,"The Carbon toolchain will support compiling C++ code. It will contain a\ncustomized C++ compiler that enables some more advanced interoperability\nfeatures, such as calling Carbon templates from C++."),(0,i.kt)("p",null,"Mixing toolchains will also be supported in both directions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"C++ libraries compiled by a non-Carbon toolchain will be usable from Carbon,\nso long as they are ABI-compatible with Carbon's C++ toolchain.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The Carbon toolchain will support, as an option, generating a C++ header and\nobject file from a Carbon library, with an ABI that's suitable for use with\nnon-Carbon toolchains."))),(0,i.kt)("p",null,"Mixing toolchains restricts functionality to what's feasible with the C++ ABI.\nFor example, developers should expect that Carbon templates will be callable\nfrom C++ when using the Carbon toolchain, and will not be available when mixing\ntoolchains because it would require a substantially different and more complex\ninteroperability implementation. This degraded interoperability should still be\nsufficient for most developers, albeit with the potential of more bridge code."),(0,i.kt)("p",null,"Any C++ interoperability code that works when mixing toolchains must work when\nusing the native Carbon toolchain. The mixed toolchain support must not have\nsemantic divergence. The converse is not true, and the native Carbon toolchain\nmay have additional language support and optimizations."),(0,i.kt)("h3",{id:"compatibility-with-the-c-memory-model"},"Compatibility with the C++ memory model"),(0,i.kt)("p",null,"It must be straightforward for any Carbon interoperability code to be compatible\nwith the C++ memory model. This does not mean that Carbon must exclusively use\nthe C++ memory model, only that it must be supported."),(0,i.kt)("h3",{id:"minimize-bridge-code"},"Minimize bridge code"),(0,i.kt)("p",null,"The majority of simple C++ functions and types should be usable from Carbon\nwithout any custom bridge code and without any runtime overhead. That is, Carbon\ncode should be able to call most C++ code without any code changes to add\nsupport for interoperability, even if that code was built with a non-Carbon\ntoolchain. This includes instantiating Carbon templates or generics using C++\ntypes."),(0,i.kt)("p",null,"In the other direction, Carbon may need some minimal markup to expose functions\nand types to C++. This should help avoid requiring Carbon to generate\nC++-compatible endpoints unconditionally, which could have compile and linking\noverheads that may in many cases be unnecessary. Also, it should help produce\nerrors that indicate when a function or type may require additional changes to\nmake compatible with C++."),(0,i.kt)("p",null,"Carbon's priority developers should be able to easily reuse the mature ecosystem\nof C++ libraries provided by third-parties. A third-party library's language\nchoice should not be a barrier to Carbon adoption."),(0,i.kt)("p",null,"Even for first-party libraries, migration of C++ codebases to Carbon will often\nbe incremental due to human costs of executing and verifying source migrations.\nMinimizing the amount of bridge code required should be expected to simplify\nsuch migrations."),(0,i.kt)("h3",{id:"unsurprising-mappings-between-c-and-carbon-types"},"Unsurprising mappings between C++ and Carbon types"),(0,i.kt)("p",null,"Carbon will provide unsurprising mappings for common types."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Primitive types")," will have mappings with zero overhead conversions. They are\nfrequently used, making it important that interoperability code be able to use\nthem seamlessly."),(0,i.kt)("p",null,"The storage and representation will need to be equivalent in both languages. For\nexample, if a C++ ",(0,i.kt)("inlineCode",{parentName:"p"},"__int64")," maps to Carbon's ",(0,i.kt)("inlineCode",{parentName:"p"},"Int64"),", the memory layout of both\ntypes must be identical."),(0,i.kt)("p",null,"Semantics need to be similar, but edge-case behaviors don't need to be\nidentical, allowing Carbon flexibility to evolve. For example, where C++ would\nhave modulo wrapping on integers, Carbon could instead have trapping behavior on\nthe default-mapped primitive types."),(0,i.kt)("p",null,"Carbon may have versions of these types with no C++ mapping, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Int256"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Non-owning vocabulary types"),", such as pointers and references, will have\ntransparent, automatic translation between C++ and Carbon non-owning vocabulary\ntypes with zero overhead."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Other vocabulary types")," will typically have reasonable, but potentially\nnon-zero overhead, conversions available to map into Carbon vocabulary types.\nCode using these may choose whether to pay the overhead to convert. They may\nalso use the C++ type directly from Carbon code, and the other way around."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Incomplete types")," must have a mapping with similar semantics, similar to\nprimitive types."),(0,i.kt)("h3",{id:"allow-c-bridge-code-in-carbon-files"},"Allow C++ bridge code in Carbon files"),(0,i.kt)("p",null,"Carbon files should support inline bridge code written in C++. Where bridge code\nis necessary, this will allow for maintenance of it directly alongside the code\nthat uses it."),(0,i.kt)("h3",{id:"carbon-inheritance-from-c-types"},"Carbon inheritance from C++ types"),(0,i.kt)("p",null,"Carbon will support inheritance from C++ types for interoperability, although\nthe syntax constructs may look different from C++ inheritance. This is\nconsidered necessary to address cases where a C++ library API expects users to\ninherit from a given C++ type."),(0,i.kt)("p",null,"This might be restricted to pure interface types; see\n",(0,i.kt)("a",{parentName:"p",href:"#carbon-type-inheritance-from-non-pure-interface-c-types"},"the open question"),"."),(0,i.kt)("h3",{id:"support-use-of-advanced-c-features"},"Support use of advanced C++ features"),(0,i.kt)("p",null,"There should be support for most idiomatic usage of advanced C++ features. A few\nexamples are templates, overload sets,\n",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/attributes"},"attributes")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Argument-dependent_name_lookup"},"ADL"),"."),(0,i.kt)("p",null,'Although these features can be considered "advanced", their use is widespread\nthroughout C++ code, including STL. Support for such features is key to\nsupporting migration from C++ features.'),(0,i.kt)("h3",{id:"support-basic-c-interoperability"},"Support basic C interoperability"),(0,i.kt)("p",null,"C interoperability support must be sufficient for Carbon code to call popular\nAPIs that are written in C. The ability of C to call Carbon will be more\nrestricted, limited to where it echoes C++ interoperability support. Basic C\ninteroperability will include functions, primitive types, and structs that only\ncontain member variables."),(0,i.kt)("p",null,"Features where interoperability will rely on more advanced C++-specific\nfeatures, such as templates, inheritance, and class functions, need not be\nsupported for C. These would require a C-specific interoperability model that\nwill not be included."),(0,i.kt)("h2",{id:"non-goals"},"Non-goals"),(0,i.kt)("h3",{id:"full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains"},"Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains"),(0,i.kt)("p",null,"Making mixed C++/Carbon toolchain support equivalent to Carbon-only toolchain\nsupport affects all interoperability features. Mixed toolchains will have\ndegraded support because full parity would be too expensive."),(0,i.kt)("p",null,"The feature of calling Carbon templates from C++ code is key when analyzing this\noption. Template instantiation during compilation is pervasive in C++."),(0,i.kt)("p",null,"With a Carbon toolchain compiling both Carbon and C++ code, the C++ compiler\n",(0,i.kt)("em",{parentName:"p"},"can")," be modified to handle Carbon templates differently. Carbon templates can\nbe handled by exposing the Carbon compiler's AST to the C++ compiler directly,\nas a compiler extension. While this approach is still complex and may not always\nwork, it should offer substantial value and ability to migrate C++ code to\nCarbon without requiring parallel maintenance of implementations in C++."),(0,i.kt)("p",null,"With a mixed toolchain, the C++ compiler ",(0,i.kt)("em",{parentName:"p"},"cannot")," be modified to handle Carbon\ntemplates differently. The only way to support template instantiation would be\nby having Carbon templates converted into equivalent C++ templates in C++\nheaders; in other words, template support would require source-to-source\ntranslation. Supporting Carbon to C++ code translations would be a complex and\nhigh cost feature to achieve full parity for mixed toolchains. Requiring bridge\ncode for mixed toolchains is the likely solution to avoid this cost."),(0,i.kt)("p",null,"Note that this issue differs when considering interoperability for Carbon code\ninstantiating C++ templates. The C++ templates must be in C++ headers for\nre-use, which in turn must compile with the Carbon toolchain to re-use the built\nC++ code, regardless of whether a separate C++ toolchain is in use. This may\nalso be considered a constraint on mixed toolchain interoperability, but it's\nsimpler to address and less likely to burden developers."),(0,i.kt)("p",null,"To summarize, developers should expect that while ",(0,i.kt)("em",{parentName:"p"},"most")," features will work\nequivalently for mixed toolchains, there will never be full parity."),(0,i.kt)("h3",{id:"never-require-bridge-code"},"Never require bridge code"),(0,i.kt)("p",null,"Corner cases of C++ will not receive equal support to common cases: the\ncomplexity of supporting any given construct must be balanced by the real world\nneed for that support. For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Interoperability will target C++17. Any interoperability support for future\nversions of C++, including features such as C++20 modules, will be based on\na cost-benefit analysis. Exhaustive support should not be assumed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Support will be focused on idiomatic code, interfaces, and patterns used in\nwidespread open source libraries or by other key constituencies. C++ code\nwill have edge cases where the benefits of limiting Carbon's maintenance\ncosts by avoiding complex interoperability outweighs the value of avoiding\nbridge code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Support for low-level C ABIs may be focused on modern 64-bit ABIs, including\nLinux, POSIX, and a small subset of Windows' calling conventions."))),(0,i.kt)("h3",{id:"convert-all-c-types-to-carbon-types"},"Convert all C++ types to Carbon types"),(0,i.kt)("p",null,"Non-zero overhead conversions should only be ",(0,i.kt)("em",{parentName:"p"},"supported"),", never ",(0,i.kt)("em",{parentName:"p"},"required"),", in\norder to offer reliable, unsurprising performance behaviors. This does not mean\nthat conversions will ",(0,i.kt)("em",{parentName:"p"},"always")," be supported, as support is a cost-benefit\ndecision for specific type mappings. For example, consider conversions between\n",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T>")," and an equivalent, idiomatic Carbon type:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Making conversions zero-overhead would require the Carbon type to mirror the\nmemory layout and implementation semantics of ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T>"),". However,\ndoing so would constrain the evolution of the Carbon type to match C++.\nAlthough some constraints are accepted for most primitive types, it would\npose a major burden on Carbon's evolution to constrain Carbon's types to\nmatch C++ vocabulary type implementations.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"These conversions may not always be present, but ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T>")," is a\nfrequently used type. As a result, it can be expected that there will be\nfunctions supporting a copy-based conversion to the idiomatic Carbon type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"An interface which can hide the difference between whether ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector<T>"),"\nor the equivalent, idiomatic Carbon type is in use may also be offered for\ncommon types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It will still be normal to handle C++ types in Carbon code without\nconversions. Developers should be given the choice of when to convert."))),(0,i.kt)("h3",{id:"support-for-c-exceptions-without-bridge-code"},"Support for C++ exceptions without bridge code"),(0,i.kt)("p",null,"Carbon may not provide seamless interoperability support for C++ exceptions. For\nexample, translating C++ exceptions to or from Carbon errors might require\nannotations or bridge code, and those translations may have some performance\noverhead or lose information. Furthermore, if Carbon code calls a C++ function\nwithout suitable annotations or bridging, and that function exits with an\nexception, the program might terminate."),(0,i.kt)("h3",{id:"cross-language-metaprogramming"},"Cross-language metaprogramming"),(0,i.kt)("p",null,"Carbon's metaprogramming design will be more restrictive than C++'s preprocessor\nmacros. Although interoperability should handle simple cases, such as\n",(0,i.kt)("inlineCode",{parentName:"p"},"#define STDIN_FILENO 0"),", complex metaprogramming libraries may require a deep\nability to understand code rewrites. It should be reasonable to have these\ninstead rewritten to use Carbon's metaprogramming model."),(0,i.kt)("h3",{id:"offer-equivalent-support-for-languages-other-than-c"},"Offer equivalent support for languages other than C++"),(0,i.kt)("p",null,"Long-term, it should be anticipated that Carbon will add interoperability with\nnon-C++ languages. However, interoperability discussions will be focused on C++\nin order to support the\n",(0,i.kt)("a",{parentName:"p",href:"/project/goals#interoperability-with-and-migration-from-existing-c-code"},"language goal"),".\nAlthough we should work to consider extensibility when building interoperability\nfacilities, C++ should be expected to have more robust support."),(0,i.kt)("p",null,"Many languages do offer interoperability layers with C. Carbon's\n",(0,i.kt)("a",{parentName:"p",href:"#support-basic-c-interoperability"},"C interoperability")," will likely offer a\ndegree of multi-language interoperability using C as an intermediary."),(0,i.kt)("h2",{id:"open-questions-to-be-resolved-later"},"Open questions to be resolved later"),(0,i.kt)("h3",{id:"carbon-type-inheritance-from-non-pure-interface-c-types"},"Carbon type inheritance from non-pure interface C++ types"),(0,i.kt)("p",null,"Some C++ APIs will expect that consumers use classes that inherit from a type\nprovided by the API. It's desirable to have Carbon support, in some way,\ninheritance from API types in order to use these APIs."),(0,i.kt)("p",null,"It may be sufficient to require the parent type be a pure interface, and that\nAPIs with either use bridge code or switch implementations. That will be\ndetermined later."),(0,i.kt)("h3",{id:"crtp-support"},"CRTP support"),(0,i.kt)("p",null,"Although\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"},"CRTP")," is a\ncommon technique in C++, interoperability support may require substantial work.\nLibraries based on use of CRTP may require bridge code or a rewrite for Carbon\ninteroperability."),(0,i.kt)("p",null,"More analysis should be done on the cost-benefit of supporting CRTP before\nmaking a support decision."),(0,i.kt)("h3",{id:"object-lifetimes"},"Object lifetimes"),(0,i.kt)("p",null,"Carbon may have a different object lifetime design than C++. For example, Carbon\nmay choose different rules for determining the lifetime of temporaries. This\ncould affect idiomatic use of C++ APIs, turning code that would be safe in C++\ninto unsafe Carbon code, requiring developers to learn new coding patterns."),(0,i.kt)("p",null,"More analysis should be done on object lifetimes and potential Carbon designs\nfor it before deciding how to treat object lifetimes in the scope of\ninteroperability."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/175"},"#175: C++ interoperability goals"))))}d.isMDXComponent=!0}}]);