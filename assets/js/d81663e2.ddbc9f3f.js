"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1601],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>p});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=d(a),p=i,h=m["".concat(s,".").concat(p)]||m[p]||u[p]||r;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function p(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7934:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var n=a(7462),i=(a(7294),a(3905));const r={},o="Safety strategy",l={unversionedId:"docs/project/principles/safety_strategy",id:"docs/project/principles/safety_strategy",title:"Safety strategy",description:"\x3c!--",source:"@site/../docs/project/principles/safety_strategy.md",sourceDirName:"docs/project/principles",slug:"/docs/project/principles/safety_strategy",permalink:"/docs/project/principles/safety_strategy",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/project/principles/safety_strategy.md",tags:[],version:"current",frontMatter:{},sidebar:"project",previous:{title:"Principle: Prefer providing only one way to do a given thing",permalink:"/docs/project/principles/one_way"},next:{title:"Principle: One static open extension mechanism",permalink:"/docs/project/principles/static_open_extension"}},s={},d=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Background",id:"background",level:2},{value:"What &quot;safety&quot; means in Carbon",id:"what-safety-means-in-carbon",level:3},{value:"Safety guarantees versus hardening",id:"safety-guarantees-versus-hardening",level:3},{value:"Philosophy",id:"philosophy",level:2},{value:"Principles",id:"principles",level:2},{value:"Details",id:"details",level:2},{value:"Incremental work when safety requires work",id:"incremental-work-when-safety-requires-work",level:3},{value:"Using build modes to manage safety checks",id:"using-build-modes-to-manage-safety-checks",level:3},{value:"Debug",id:"debug",level:4},{value:"Performance",id:"performance",level:4},{value:"Hardened",id:"hardened",level:4},{value:"Managing bugs without compile-time safety",id:"managing-bugs-without-compile-time-safety",level:3},{value:"Caveats",id:"caveats",level:2},{value:"Probabilistic techniques likely cannot stop attacks",id:"probabilistic-techniques-likely-cannot-stop-attacks",level:3},{value:"Alternatives considered",id:"alternatives-considered",level:2},{value:"Guaranteed memory safety programming models",id:"guaranteed-memory-safety-programming-models",level:3},{value:"Guaranteed compile-time memory safety using borrow checking",id:"guaranteed-compile-time-memory-safety-using-borrow-checking",level:4},{value:"Guaranteed run-time memory safety using reference counting",id:"guaranteed-run-time-memory-safety-using-reference-counting",level:4},{value:"Guaranteed run-time memory safety using garbage collection",id:"guaranteed-run-time-memory-safety-using-garbage-collection",level:4},{value:"Build mode names",id:"build-mode-names",level:3},{value:"Performance versus safety in the hardened build mode",id:"performance-versus-safety-in-the-hardened-build-mode",level:3},{value:"Add more build modes",id:"add-more-build-modes",level:3}],c={toc:d};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"safety-strategy"},"Safety strategy"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#background"},"Background"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#what-safety-means-in-carbon"},'What "safety" means in Carbon')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#safety-guarantees-versus-hardening"},"Safety guarantees versus hardening")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#philosophy"},"Philosophy")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#principles"},"Principles")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#details"},"Details"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#incremental-work-when-safety-requires-work"},"Incremental work when safety requires work")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#using-build-modes-to-manage-safety-checks"},"Using build modes to manage safety checks"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#debug"},"Debug")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#performance"},"Performance")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#hardened"},"Hardened")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#managing-bugs-without-compile-time-safety"},"Managing bugs without compile-time safety")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#caveats"},"Caveats"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#probabilistic-techniques-likely-cannot-stop-attacks"},"Probabilistic techniques likely cannot stop attacks")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#guaranteed-memory-safety-programming-models"},"Guaranteed memory safety programming models"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#guaranteed-compile-time-memory-safety-using-borrow-checking"},"Guaranteed compile-time memory safety using borrow checking")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#guaranteed-run-time-memory-safety-using-reference-counting"},"Guaranteed run-time memory safety using reference counting")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#guaranteed-run-time-memory-safety-using-garbage-collection"},"Guaranteed run-time memory safety using garbage collection")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#build-mode-names"},"Build mode names")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#performance-versus-safety-in-the-hardened-build-mode"},"Performance versus safety in the hardened build mode")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#add-more-build-modes"},"Add more build modes"))))),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"Carbon's goal is to provide\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals#practical-safety-and-testing-mechanisms"},"practical safety and testing mechanisms"),"."),(0,i.kt)("h3",{id:"what-safety-means-in-carbon"},'What "safety" means in Carbon'),(0,i.kt)("p",null,"Safety is protection from software bugs, whether the protection is required by\nthe language or merely an implementation option. Application-specific logic\nerrors can be prevented by testing, but can lead to security vulnerabilities in\nproduction. Safety categories will be referred to using names based on the type\nof\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Vulnerability_(computing)#Software_vulnerabilities"},"security vulnerability"),"\nthey protect against."),(0,i.kt)("p",null,"A key subset of safety categories Carbon should address are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Memory_safety"},(0,i.kt)("strong",{parentName:"a"},"Memory safety"))," protects\nagainst invalid memory accesses. Carbon uses\n",(0,i.kt)("a",{parentName:"p",href:"https://onlinelibrary.wiley.com/doi/full/10.1002/spe.2105"},"two main subcategories"),"\nfor memory safety:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Spatial")," memory safety protects against accessing an address that's out\nof bounds for the source. This includes array boundaries, as well as\ndereferencing invalid pointers such as uninitialized pointers, ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL")," in\nC++, or manufactured pointer addresses.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Temporal")," memory safety protects against accessing an address that has\nbeen deallocated. This includes use-after-free for heap and\nuse-after-return for stack addresses.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Type_safety"},(0,i.kt)("strong",{parentName:"a"},"Type safety")),' protects\nagainst accessing valid memory with an incorrect type, also known as "type\nconfusion".')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Race_condition#Data_race"},(0,i.kt)("strong",{parentName:"a"},"Data race safety")),"\nprotects against racing memory access: when a thread accesses (read or\nwrite) a memory location concurrently with a different writing thread and\nwithout synchronizing."))),(0,i.kt)("h3",{id:"safety-guarantees-versus-hardening"},"Safety guarantees versus hardening"),(0,i.kt)("p",null,"In providing safety, the underlying goal is to prevent attacks from turning a\n",(0,i.kt)("em",{parentName:"p"},"logic error")," into a ",(0,i.kt)("em",{parentName:"p"},"security vulnerability"),". The three ways of doing this can\nbe thought of in terms of how they prevent attacks:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Safety guarantees")," prevent bugs. They offer a strong requirement that a\nparticular security vulnerability cannot exist. Compile-time safety checks\nare always a safety guarantee, but safety guarantees may also be done at\nruntime. For example:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"At compile-time, range-based for loops offer a spatial safety guarantee\nthat out-of-bounds issues cannot exist in the absence of concurrent\nmodification of the sequence.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"At runtime, garbage collected languages offer a temporal safety\nguarantee because objects cannot be freed while they're still\naccessible.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Error detection")," checks for common logic errors at runtime. For example:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"An array lookup function might offer spatial memory error detection by\nverifying that the passed index is in-bounds.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A program can implement reference counting to detect a temporal memory\nerror by checking whether any references remain when memory is freed.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Safety hardening")," mitigates bugs, typically by minimizing the feasibility\nof an attack. For example:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Control-flow_integrity"},"Control Flow Integrity (CFI)"),"\nmonitors for behavior which can subvert the program's control flow. In\n",(0,i.kt)("a",{parentName:"p",href:"http://clang.llvm.org/docs/ControlFlowIntegrity.html"},"Clang"),", it is\noptimized for use in release builds. Typically CFI analysis will only\ndetect a subset of attacks because it can't track each possible code\npath separately. It should still reduce the feasibility of both spatial\nmemory, temporal memory, and type attacks.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://llvm.org/devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-LLVM-2018.pdf"},"Memory tagging"),"\nmakes each attempt at an invalid read or write operation have a high\nprobability of trapping, while still not detecting the underlying bug in\nevery case. Realistic attacks require many such operations, so memory\ntagging may stop attacks in some environments. Alternatively, the trap\nmight be asynchronous, leaving only a tiny window of time prior to the\nattack being detected and program terminated. These are probabilistic\nhardening and reduces the feasibility of both spatial and temporal\nmemory attacks."))))),(0,i.kt)("p",null,"Under both error detection and safety hardening, even if a safety is protected,\nthe underlying bugs will still exist and will need to be fixed. For example,\nprogram termination could be used for a denial-of-service attack."),(0,i.kt)("h2",{id:"philosophy"},"Philosophy"),(0,i.kt)("p",null,"Carbon's\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals#practical-safety-and-testing-mechanisms"},"practical safety and testing mechanisms"),"\nwill emphasize guaranteed safety where feasible without creating barriers to\nCarbon's ",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals"},"other goals"),", particularly performance and\ninteroperability. This limits Carbon's options for guaranteed safety, and as a\nresult there will be more reliance upon error detection and safety hardening.\nThe language's design should incentivize safe programming, although it will not\nbe required."),(0,i.kt)("p",null,"When writing code, Carbon developers should expect to receive safety without\nneeding to add safety annotations. Carbon will have optional safety annotations\nfor purposes such as optimizing safety checks or providing information that\nimproves coverage of safety checks."),(0,i.kt)("p",null,"Carbon will favor compile-time safety checks because catching issues early will\nmake applications more reliable. Runtime checks, either error detection or\nsafety hardening, will be enabled where safety cannot be proven at compile-time."),(0,i.kt)("p",null,"There will be three high-level use cases or directions that Carbon addresses\nthrough different build modes that prioritize safety checks differently:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("a",{parentName:"li",href:"#debug"},"debug")," oriented build mode that prioritizes detecting bugs and\nreporting errors helpfully."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("a",{parentName:"li",href:"#performance"},"performance")," oriented build mode that skips any dynamic\nsafety checks to reduce overhead."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("a",{parentName:"li",href:"#hardened"},"hardened")," oriented build mode that prioritizes ensuring\nsufficient safety to prevent security vulnerabilities, although it may not\nallow detecting all of the bugs.")),(0,i.kt)("p",null,"These high level build modes may be tuned, either to select specific nuanced\napproach for achieving the high level goal, or to configure orthogonal\nconstraints such as whether to prioritize binary size or execution speed.\nHowever, there is a strong desire to avoid requiring more fundamental build\nmodes to achieve the necessary coverage of detecting bugs and shipping software.\nThese build modes are also not expected to be interchangeable or compatible with\neach other within a single executable -- they must be a global selection."),(0,i.kt)("p",null,"Although expensive safety checks could be provided through additional build\nmodes, Carbon will favor safety checks that can be combined into these three\nbuild modes rather than adding more."),(0,i.kt)("p",null,"Over time, safety should ",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals#software-and-language-evolution"},"evolve"),"\nusing a hybrid compile-time and runtime safety approach to eventually provide a\nsimilar level of safety to a language that puts more emphasis on guaranteed\nsafety, such as\n",(0,i.kt)("a",{parentName:"p",href:"#guaranteed-compile-time-memory-safety-using-borrow-checking"},"Rust"),". However,\nwhile Carbon may ",(0,i.kt)("em",{parentName:"p"},"encourage")," developers to modify code in support of more\nefficient safety checks, it will remain important to improve the safety of code\nfor developers who cannot invest into safety-specific code modifications."),(0,i.kt)("h2",{id:"principles"},"Principles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Safety must be\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals#code-that-is-easy-to-read-understand-and-write"},"easy to ramp-up with"),",\neven if it means new developers don't receive the full safety that Carbon\ncan offer."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Developers should benefit from Carbon's safety without needing to learn\nand apply Carbon-specific design patterns. Some safety should be enabled\nby default, without safety-specific work, although some safety will\nrequire work to opt in. Developers concerned with performance should\nonly need to disable safety in rare edge-cases.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Where there is a choice between safety approaches, the safe option\nshould be incentivized by making it equally easy or easier to use. If\nthere is a default, it should be the safe option. It should be\nidentifiable when the unsafe option is used. Incentives will prioritize,\nin order:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Guaranteed safety."),(0,i.kt)("li",{parentName:"ol"},"Error detection."),(0,i.kt)("li",{parentName:"ol"},"Safety hardening."),(0,i.kt)("li",{parentName:"ol"},"Unsafe and unmitigated code."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Language design choices should favor more efficient implementations of\nsafety checks. They should also allow favor automation of testing and\nfuzzing.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Safety in Carbon must work with\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals#interoperability-with-and-migration-from-existing-c-code"},"interoperable or migrated C++ code"),",\nso that C++ developers can readily take advantage of Carbon's improvements."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Safety mechanisms will ideally be designed to apply to automatically\nmigrated C++ code. Providing immediate safety improvements to Carbon\nadopters will help motivate adoption.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the other direction, safety mechanisms must not force manual\nrewriting of C++ code in order to migrate, either by creating design\nincompatibilities or performance degradations. Automated migration of\nC++ code to Carbon must work for most developers, even if it forces\nCarbon's safety design to take a different approach.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Carbon's safety should degrade gracefully when Carbon code calls C++\ncode, although this may require use of the Carbon toolchain to compile\nthe C++ code. Applications should be expected to use interoperability.\nAlthough some safety features will be Carbon-specific, safety should not\nstop at the language boundary.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The rules for determining whether code will pass compile-time safety\nchecking should be articulable, documented, and easy to understand."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Compile-time safety checks should not change significantly across\ndifferent build modes. The purpose of the build modes is to determine\ncode generation."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Each build mode will prioritize performance and safety differently:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("a",{parentName:"p",href:"#debug"},"debug build mode")," will produce development-focused binaries\nthat prioritize fast iteration on code with safety checks that assist in\nidentification and debugging of errors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("a",{parentName:"p",href:"#performance"},"performance build mode")," will produce release-focused\nbinaries that prioritize performance over safety.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("a",{parentName:"p",href:"#hardened"},"hardened build mode")," will produce release-focused\nbinaries that prioritize safety that is resistant to attacks at the cost\nof performance.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Safety checks should try to be identical across build modes."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"There will be differences, typically due to performance overhead and\ndetection rate trade-offs of safety check algorithms."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The number of build modes will be limited, and should be expected to remain\nat the named three."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Most developers will use two build modes in their work: debug for\ndevelopment, and either performance or hardened for releases.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It's important to focus on checks that are cheap enough to run as part\nof normal development. Users are not expected to want to run additional\ndevelopment build modes for additional sanitizers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Limiting the number of build modes simplifies support for both Carbon\nmaintainers, who can focus on a more limited set of configurations, and\nCarbon developers, who can easily choose which is better for their\nuse-case.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Each distinct safety-related build mode (debug, performance, and hardened)\ncannot be combined with others in the same binary."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Cross-binary interfaces will exist in Carbon, and will need to be used\nby developers interested in combining libraries built under different\nbuild modes."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Although runtime safety checks should prevent logic errors from turning into\nsecurity vulnerabilities, the underlying logic errors will still be bugs.\nFor example, some safety checks would result in application termination;\nthis prevents execution of unexpected code and still needs to be fixed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Developers need a strong testing methodology to engineer correct software.\nCarbon will encourage testing and then leverage it with the checking build\nmodes to find and fix bugs and vulnerabilities."))),(0,i.kt)("h2",{id:"details"},"Details"),(0,i.kt)("h3",{id:"incremental-work-when-safety-requires-work"},"Incremental work when safety requires work"),(0,i.kt)("p",null,"Carbon is prioritizing usability of the language, particularly minimizing\nretraining of C++ developers and easing migration of C++ codebases, over the\nkind of provable safety that some other languages pursue, particularly Rust."),(0,i.kt)("p",null,"A key motivation of Carbon is to move C++ developers to a better, safer\nlanguage. However, if Carbon requires manually rewriting or redesigning C++ code\nin order to maintain performance, it creates additional pressure on C++\ndevelopers to learn and spend time on safety. Safety will often not be the top\npriority for developers; as a result, Carbon must be thoughtful about how and\nwhen it forces developers to think about safety."),(0,i.kt)("p",null,"Relying on multiple build modes to provide safety should fit into normal\ndevelopment workflows. Carbon can also have features to enable additional\nsafety, so long as developers can start using Carbon in their applications\n",(0,i.kt)("em",{parentName:"p"},"without")," learning new paradigms."),(0,i.kt)("p",null,"Where possible, safety checks shouldn't require work on the part of Carbon\ndevelopers. A safety check that requires no code edits or can be handled by\nautomated migration may be opt-out, as there is negligible cost to developers.\nOne which requires local code changes should be opt-in because costs will scale\nwith codebase size. Safety check approaches which would require substantial\nredesign by developers will be disfavored based on adoption cost, even if the\nalternative is a less-comprehensive approach."),(0,i.kt)("h3",{id:"using-build-modes-to-manage-safety-checks"},"Using build modes to manage safety checks"),(0,i.kt)("p",null,"Carbon will likely start in a state where most safety checks are done at\nruntime. However, runtime detection of safety violations remains expensive. In\norder to make as many safety checks as possible available to developers, Carbon\nwill adopt a strategy based on three build modes that target key use-cases."),(0,i.kt)("h4",{id:"debug"},"Debug"),(0,i.kt)("p",null,"The debug build mode targets developers who are iterating on code and running\ntests. It will emphasize detection and debuggability, especially for safety\nissues."),(0,i.kt)("p",null,"It needs to perform well enough to be run frequently by developers, but will\nmake performance sacrifices to catch more safety issues. This mode should have\nruntime checks for the most common safety issues, but it can make trade-offs\nthat improve performance in exchange for less frequent, but still reliable,\ndetection. Developers should do most of their testing in this build mode."),(0,i.kt)("p",null,"The debug build mode will place a premium on the debuggability of safety\nviolations. Where safety checks rely on hardening instead of guaranteed safety,\nviolations should be detected with a high probability per single occurrence of\nthe bug. Detected bugs will be accompanied by a detailed diagnostic report to\nease classification and root cause identification."),(0,i.kt)("h4",{id:"performance"},"Performance"),(0,i.kt)("p",null,"The performance build mode targets the typical application that wants high\nperformance from Carbon code, where performance considers processing time,\nmemory, and disk space. Trade-offs will be made that maximize the performance."),(0,i.kt)("p",null,"Only safety techniques that don't measurably impact application hot path\nperformance will be enabled by default. This is a very high bar, but is crucial\nfor meeting Carbon's performance goals, as well as allowing migration of\nexisting C++ systems which may not have been designed with Carbon's safety\nsemantics in mind."),(0,i.kt)("h4",{id:"hardened"},"Hardened"),(0,i.kt)("p",null,"The hardened build mode targets applications where developers want strong safety\nagainst attacks in exchange for worse performance. It will work to prevent\nattacks in ways that\n",(0,i.kt)("a",{parentName:"p",href:"#probabilistic-techniques-likely-cannot-stop-attacks"},"attackers cannot work around"),",\neven if it means using techniques that create significant performance costs."),(0,i.kt)("h3",{id:"managing-bugs-without-compile-time-safety"},"Managing bugs without compile-time safety"),(0,i.kt)("p",null,"Carbon's reliance on runtime checks will allow developers to manage their\nsecurity risk. Developers will still need to reliably find and fix the\ninevitable bugs, including both safety violations and regular business logic\nbugs. The cornerstone of managing bugs will be strong testing methodologies,\nwith built-in support from Carbon."),(0,i.kt)("p",null,"Strong testing is more than good test coverage. It means a combination of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Ensuring unsafe or risky operations and interfaces can easily be recognized\nby developers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Using static analysis tools to detect common bugs, and ensuring they're\nintegrated into build and code review workflows. These could be viewed as\nstatic testing of code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Writing good test coverage, including unit, integration, and system tests.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Implementing coverage-directed fuzz testing to discover bugs outside of\nmanually authored test coverage, especially for interfaces handling\nuntrusted data. Fuzz testing is a robust way to catch bugs when APIs may be\nused in ways developers don't consider.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Running continuous integration, including automatic and continuous running\nof these tests. The checked development build mode should be validated, as\nwell as any additional build modes necessary to cover different forms of\nbehavior checking.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Easing automated testing and fuzzing through language features. For example,\nif the language encourages value types and pure functions of some sort, they\ncan be automatically fuzzed."))),(0,i.kt)("p",null,"These practices are necessary for reliable, large-scale software engineering.\nMaintaining correctness of business logic over time requires continuous and\nthorough testing. Without it, such software systems cannot be changed and\nevolved over time reliably. Carbon will re-use these practices in conjunction\nwith checking build modes to mitigate the limitations of Carbon's safety\nguarantees without imposing overhead on production systems."),(0,i.kt)("p",null,"When a developer chooses to use Carbon, adhering to this kind of testing\nmethodology is essential for maintaining safety. As a consequence, Carbon's\necosystem, including the language, tools, and libraries, will need to directly\nwork to remove barriers and encourage the development of these methodologies."),(0,i.kt)("p",null,"The reliance on testing may make Carbon a poor choice in some environments; in\nenvironments where such testing rigor is infeasible, a language with a greater\ndegree of static checking may be better suited."),(0,i.kt)("h2",{id:"caveats"},"Caveats"),(0,i.kt)("h3",{id:"probabilistic-techniques-likely-cannot-stop-attacks"},"Probabilistic techniques likely cannot stop attacks"),(0,i.kt)("p",null,"It's expected that probabilistic techniques that can be applied at the language\nlevel are attackable through a variety of techniques:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The attacker might be able to attack repeatedly until it gets through."),(0,i.kt)("li",{parentName:"ul"},"The attacker may be able to determine when the attack would be detected and\nonly run the attack when it would not be."),(0,i.kt)("li",{parentName:"ul"},"The attacker might be able control the test condition to make detection much\nless likely or avoid detection completely. For example, if detection is\nbased on the last 4 bits of a memory address, an attacker may be able to\ngenerate memory allocations, viewing the address and only attacking when\nthere's a collision.")),(0,i.kt)("p",null,"Hardware vulnerabilities may make these attacks easier than they might otherwise\nappear. Future hardware vulnerabilities are difficult to predict."),(0,i.kt)("p",null,"Note this statement focuses on what can be applied to the language level. Using\na secure hash algorithm, such as SHA256, may be used to offer probabilistic\ndefense in other situations. However, the overhead of a secure hash algorithm's\ncalculation is significant in the context of most things that Carbon may do at\nthe language level."),(0,i.kt)("p",null,"Combining these issues, although it may seem like a probabilistic safety check\ncould be proven to reliably detect attackers, it's likely infeasible to do so.\nFor the various build modes, this means:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The debug build mode will not typically be accessible to attackers, so where\na probabilistic technique provides a better developer experience, it will be\npreferred."),(0,i.kt)("li",{parentName:"ul"},"The performance build mode will often avoid safety checks in order to reach\npeak performance. As a consequence, even the weak protection of a\nprobabilistic safety check may be used in order to provide ",(0,i.kt)("em",{parentName:"li"},"some"),"\nprotection."),(0,i.kt)("li",{parentName:"ul"},"The hardened build mode will prefer non-probabilistic techniques that\n",(0,i.kt)("em",{parentName:"li"},"cannot")," be attacked.")),(0,i.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,i.kt)("h3",{id:"guaranteed-memory-safety-programming-models"},"Guaranteed memory safety programming models"),(0,i.kt)("p",null,"Multiple approaches that would offer guaranteed memory safety have been\nconsidered, mainly based on other languages which offer related approaches.\nCarbon will likely rely more on error detection and hardening because of what\nthe models would mean for Carbon's performance and C++ migration language goals."),(0,i.kt)("h4",{id:"guaranteed-compile-time-memory-safety-using-borrow-checking"},"Guaranteed compile-time memory safety using borrow checking"),(0,i.kt)("p",null,"Rust offers a good example of an approach for compile-time safety based on\nborrow checking, which provides guaranteed safety. For code which can't\nimplement borrow checking, runtime safety using reference counting is available\nand provides reliable error detection. This approach still allows for\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/unsafe.html"},(0,i.kt)("inlineCode",{parentName:"a"},"unsafe")," blocks"),", as\nwell as types that offer runtime safety while wrapping ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," interfaces."),(0,i.kt)("p",null,"Carbon could use a similar approach for guaranteed safety by default."),(0,i.kt)("p",null,"Advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Guaranteed safety, including against data races, is provided for the\nbinaries.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The emphasis on compile-time safety limits the scope of the runtime\nmemory safety costs."),(0,i.kt)("li",{parentName:"ul"},"With Rust, there is early evidence that there's a significant impact in\nreducing bugs generally."))),(0,i.kt)("li",{parentName:"ul"},"Imitating Rust's techniques would allow building on the huge work of the\nRust community, reducing the risks of implementing similar in Carbon."),(0,i.kt)("li",{parentName:"ul"},"Careful use of narrow ",(0,i.kt)("inlineCode",{parentName:"li"},"unsafe")," escape hatches can be effectively\nencapsulated behind otherwise safe APIs.")),(0,i.kt)("p",null,"Disadvantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Rust's approach to compile-time safety requires use of\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rust-unofficial/patterns"},"design patterns and idioms"),"\nthat are substantially different from C++.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Conversion of C++ code to Rust results in either rewrites of code, or\nuse of runtime safety checks that impair performance."),(0,i.kt)("li",{parentName:"ul"},"Requires fully modeling lifetime and exclusivity in the type system."),(0,i.kt)("li",{parentName:"ul"},"Data structures must be redesigned to avoid sharing mutable state."),(0,i.kt)("li",{parentName:"ul"},"Increases complexity of node and pointer based data structures, such as\nlinked lists."))),(0,i.kt)("li",{parentName:"ul"},"Imitating Rust's techniques may prove insufficient for achieving Carbon's\n",(0,i.kt)("a",{parentName:"li",href:"/docs/project/goals#fast-and-scalable-development"},"compiler performance goals"),".\nRust compilation performance suggests its borrow checking performance is\nslow, although it's difficult to determine how significant this is or\nwhether it could be improved.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The Rust compiler\n",(0,i.kt)("a",{parentName:"li",href:"https://pingcap.com/blog/rust-compilation-model-calamity"},"is slow"),",\nalthough\n",(0,i.kt)("a",{parentName:"li",href:"https://blog.mozilla.org/nnethercote/2020/09/08/how-to-speed-up-the-rust-compiler-one-last-time/"},"much has been done to improve it"),"."),(0,i.kt)("li",{parentName:"ul"},"Details of type checking, particularly requiring parsing of function\nbodies to type check signatures, as well as wide use of\n",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch10-01-syntax.html"},"monomorphization"),"\nare likely significant contributors to Rust compilation performance."),(0,i.kt)("li",{parentName:"ul"},"LLVM codegen is also a significant cost for Rust compilation\nperformance."),(0,i.kt)("li",{parentName:"ul"},"With\n",(0,i.kt)("a",{parentName:"li",href:"https://fuchsia.dev/fuchsia-src/development/languages/rust"},"Fuchsia")," as\nan example, in December 2020, borrow checking and type checking combined\naccount for around 10% of Rust compile CPU time, or 25% of end-to-end\ncompile time. The current cost of borrow checking is obscured both\nbecause of the combination with type checking, and because Fuchsia\ndisables some compiler parallelization due to build system\nincompatibility."))),(0,i.kt)("li",{parentName:"ul"},"The complexity of using Rust's compile-time safety may incentivize\nunnecessary runtime checking of safety properties. For example, using\n",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/std/cell/struct.RefCell.html"},(0,i.kt)("inlineCode",{parentName:"a"},"RefCell"))," or\n",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/std/rc/struct.Rc.html"},(0,i.kt)("inlineCode",{parentName:"a"},"Rc"))," to avoid changing\ndesigns to fit compile-time safety models."),(0,i.kt)("li",{parentName:"ul"},"Some of the most essential safety tools that ease the ergonomic burden of\nthe Rust-style lifetime model (",(0,i.kt)("inlineCode",{parentName:"li"},"Rc"),") introduce ",(0,i.kt)("em",{parentName:"li"},"semantic")," differences that\ncannot then be eliminated in a context where performance is the dominant\npriority.")),(0,i.kt)("p",null,"It's possible to modify the Rust model several ways in order to reduce the\nburden on C++ developers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Don't offer safety guarantees for data races, eliminating ",(0,i.kt)("inlineCode",{parentName:"li"},"RefCell"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This would likely not avoid the need for ",(0,i.kt)("inlineCode",{parentName:"li"},"Rc")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"Arc"),", and wouldn't\nsubstantially reduce the complexity."))),(0,i.kt)("li",{parentName:"ul"},"Require manual destruction of ",(0,i.kt)("inlineCode",{parentName:"li"},"Rc"),", allowing safety checks to be disabled in\nthe performance build mode to eliminate overhead.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This still requires redesigning C++ code to take advantage of ",(0,i.kt)("inlineCode",{parentName:"li"},"Rc"),"."),(0,i.kt)("li",{parentName:"ul"},"The possibility of incorrect manual destruction means that the safety\nissue is being turned into a bug, which means it is hardening and no\nlonger a safety guarantee."),(0,i.kt)("li",{parentName:"ul"},"Carbon can provide equivalent hardening through techniques such as\n",(0,i.kt)("a",{parentName:"li",href:"https://www.cl.cam.ac.uk/~tmj32/papers/docs/ainsworth20-sp.pdf"},"MarkUs"),",\nwhich does not require redesigning C++ code.")))),(0,i.kt)("p",null,"Overall, Carbon is making a compromise around safety in order to give a path for\nC++ to evolve. C++ developers must be comfortable migrating their codebases, and\nable to do so in a largely automated manner. In order to achieve automated\nmigration, Carbon cannot require fundamental redesigns of migrated C++ code.\nWhile a migration tool could in theory mark all migrated code as ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe"),",\nCarbon should use a safety strategy that degrades gracefully and offers\nimprovements for C++ code, whether migrated or not."),(0,i.kt)("p",null,"That does not mean Carbon will never adopt guaranteed safety by default, only\nthat performance and migration of C++ code takes priority, and any design will\nneed to be considered in the context of other goals. It should still be possible\nto adopt guaranteed safety later, although it will require identifying a\nmigration path."),(0,i.kt)("h4",{id:"guaranteed-run-time-memory-safety-using-reference-counting"},"Guaranteed run-time memory safety using reference counting"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Reference_counting"},"Reference counting")," is a\ncommon memory safety model, with Swift as a popular example."),(0,i.kt)("p",null,"Advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Simple model for safety, particularly as compared with Rust."),(0,i.kt)("li",{parentName:"ul"},"Safe for all of the most common and important classes of memory safety bugs.")),(0,i.kt)("p",null,"Disadvantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Safety based on reference counting introduces significant performance costs,\nand tools for controlling these costs are difficult.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Safety based on garbage collection has less direct performance overhead,\nbut has a greater unpredictability of performance."))),(0,i.kt)("li",{parentName:"ul"},'Significant design differences versus C++ still result, as the distinction\nbetween value types and "class types" becomes extremely important.',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Class types are held by a reference counted pointer and are thus\nlifetime safe.")))),(0,i.kt)("p",null,"In order to mitigate the performance overhead, Swift does have a proposal to add\nan option for unique ownership, although the specifics are not designed yet. The\nunique ownership approach is expected to require unowned and unsafe access, so\nit would not considered to improve the safety trade-offs."),(0,i.kt)("p",null,"Swift was designated by Apple as the replacement for Objective-C. The safety\nversus performance trade-offs that it makes fit Apple's priorities. Carbon's\nperformance goals should lead to different trade-off decisions with a higher\npriority on peak performance, which effectively rules out broad use of reference\ncounting."),(0,i.kt)("h4",{id:"guaranteed-run-time-memory-safety-using-garbage-collection"},"Guaranteed run-time memory safety using garbage collection"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"},"Garbage collection"),"\nis a common memory safety model, with Java as a popular example."),(0,i.kt)("p",null,"Advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This approach is among the most robust and well studied models, with decades\nof practical usage and analysis for security properties."),(0,i.kt)("li",{parentName:"ul"},"Extremely suitable for efficient implementation on top of a virtual machine,\nsuch as the JVM.")),(0,i.kt)("p",null,"Disadvantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Extremely high complexity to fully understand the implications of complex\ncases like data races."),(0,i.kt)("li",{parentName:"ul"},"Performance overhead is significant in terms of what Carbon would like to\nconsider.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Garbage collection remains a difficult performance problem, even for the\nJVM and its extensive optimizations."),(0,i.kt)("li",{parentName:"ul"},"The complexity of the implementation makes it difficult to ",(0,i.kt)("em",{parentName:"li"},"predict"),"\nperformance; for example, Java applications experience latency spikes\nwhen garbage collection runs.")))),(0,i.kt)("p",null,"Java is a good choice for many applications, but Carbon is working to focus on a\nset of performance priorities that would be difficult to achieve with a garbage\ncollector."),(0,i.kt)("h3",{id:"build-mode-names"},"Build mode names"),(0,i.kt)("p",null,"The build mode concepts are difficult to name. Other names that were evaluated,\nand are ultimately similar, are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Debug" is a common term for the intended use of this build mode. Also,\ntooling including Visual Studio frequently uses the debug term for\ndescribing similar.'),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'"Development" was also considered, but this term is less specific and\nwould be better for describing all non-release builds together. For\nexample, a "fast build" mode might be added that disables safety checks\nto improve iteration time, like might be controlled by way of C++\'s\n',(0,i.kt)("inlineCode",{parentName:"li"},"NDEBUG")," option."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Performance" aligns with the phrasing of the language performance goal.'),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Optimized" implies that other modes would not be fully optimized, but\nhardened should be optimized.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Fast" would suggest that speed is the only aspect of performance being\noptimizing for, but "performance" also optimizes for memory usage and\nbinary size.')))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Hardened" is the choice for succinctly describing the additional safety\nmeasures that will be taken, and is a well-known term in the safety space.\nIt could be incorrectly inferred that "performance" has no hardening, but\nthe preference is to clearly indicate the priority of the "hardened" build\nmode.'),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Safe" implies something closer to guaranteed safety. However, safety\nbugs should be expected to result in program termination, which can\nstill be used in other attacks, such as Denial-of-Service.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Mitigated" is an overloaded term, and it may not be succinctly clear\nthat it\'s about security mitigations.')))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Some terms which were considered and don't fit well into the above groups\nare:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'"Release" is avoided because both "performance" and "hardened" could be\nconsidered to be "release" build modes.')))),(0,i.kt)("p",null,'The names "performance" and "hardened" may lead to misinterpretations, with some\ndevelopers who should use "hardened" using "performance" because they are\nworried about giving up too much performance, and the other way around. The\nterms try to balance the utility of well-known terminology with the succinctness\nof a short phrase for build modes, and that limits the expressivity. Some\nconfusion is expected, and documentation as well as real-world experience (for\nexample, a developer who cares about latency benchmarking both builds) should be\nexpected to help mitigate mix-ups.'),(0,i.kt)("h3",{id:"performance-versus-safety-in-the-hardened-build-mode"},"Performance versus safety in the hardened build mode"),(0,i.kt)("p",null,"The performance cost of safety techniques are expected to be non-linear with\nrespect to detection rates. For example, a particular vulnerability such as heap\nuse-after-free may be detectable with 99% accuracy at 20% performance cost, but\n100% accuracy at 50% performance cost. At present, build modes should be\nexpected to evaluate such a scenario as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The debug build mode would choose the 99% accurate approach.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Detecting safety issues is valuable for debugging."),(0,i.kt)("li",{parentName:"ul"},"The probabilistic detection rate won't meaningfully affect accuracy of\ntests."),(0,i.kt)("li",{parentName:"ul"},"The lower performance cost improves developer velocity."))),(0,i.kt)("li",{parentName:"ul"},"The performance build mode would decline detection.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Safety checks with a measurable performance cost should be declined."))),(0,i.kt)("li",{parentName:"ul"},"The hardened build mode would choose the 100% accurate approach.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Safety must be non-probabilistic in order to reliably prevent attacks."),(0,i.kt)("li",{parentName:"ul"},"Significant performance hits are acceptable."),(0,i.kt)("li",{parentName:"ul"},"This means the hardened build mode may be slower than the debug build\nmode.")))),(0,i.kt)("p",null,"In order to achieve better performance, the hardened build mode could make\ntrade-offs closer to the debug build mode. Rather than relying on\nnon-probabilistic techniques, it could instead offer a probability-based chance\nof detecting a given attack."),(0,i.kt)("p",null,"Advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Probabilistic safety should come at lower performance cost (including CPU,\nmemory, and disk space).",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This will sometimes be significant, and as a result of multiple checks,\ncould be the difference between the hardened build mode being 50% slower\nthan the performance build mode and being 200% slower.")))),(0,i.kt)("p",null,"Disadvantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#probabilistic-techniques-likely-cannot-stop-attacks"},"Probabilistic techniques likely cannot stop attacks"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Attackers may be able to repeat attacks until they succeed."),(0,i.kt)("li",{parentName:"ul"},"The variables upon which the probability is based, such as memory\naddresses, may be manipulable by the attacker. As a consequence, a\ndetermined attacker may be able to manipulate probabilities and not even\nbe detected.")))),(0,i.kt)("p",null,"Although performance is\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals#language-goals-and-priorities"},"Carbon's top goal"),", the hardened\nbuild mode exists to satisfy developers and environments that value safety more\nthan performance. The hardened build mode will rely on non-probabilistic safety\nat significant performance cost because other approaches will be insufficient to\nguard against determined attackers."),(0,i.kt)("h3",{id:"add-more-build-modes"},"Add more build modes"),(0,i.kt)("p",null,"More build modes could be added to this principle, or the principle could\nencourage the idea that specific designs may add more."),(0,i.kt)("p",null,"To explain why three build modes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The concept of debug and release (sometimes called opt) are common. For\nexample, in\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/visualstudio/debugger/how-to-set-debug-and-release-configurations?view=vs-2019"},"Visual Studio"),'.\nIn Carbon, this could be considered to translate to the "debug" and\n"performance" build modes by default.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The hardened build mode is added in order to emphasize security. Although\nhardened could be implemented as a set of options passed to the standard\nrelease build mode, the preference is to focus on it as an important\nfeature."))),(0,i.kt)("p",null,"An example of why another build mode may be needed is\n",(0,i.kt)("a",{parentName:"p",href:"https://clang.llvm.org/docs/ThreadSanitizer.html"},"ThreadSanitizer"),", which is\nnoted as having 5-15x slowdown and 5-10x memory overhead. This is infeasible for\nnormal use, but could be useful for some users in a separate build mode. A\ntrade-off that's possible for Carbon is instead using an approach similar to\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/google/ktsan/wiki/KCSAN"},"KCSAN")," which offers relatively\ninexpensive but lower-probability race detection."),(0,i.kt)("p",null,"Although options to these build modes may be supported to customize deployments,\nthe preference is to focus on a small set and make them behave well. For\nexample, if a separate build mode is added for ThreadSanitizer, it should be\nconsidered a temporary solution until it can be merged into the debug build\nmode."),(0,i.kt)("p",null,"Advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Grants more flexibility for using build modes as a solution to problems.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"With safety checks, this would allow providing safety checks that are\nhigh overhead but also high detection rate as separate build modes."),(0,i.kt)("li",{parentName:"ul"},"With other systems, there could be non-safety performance versus\nbehavior trade-offs.")))),(0,i.kt)("p",null,"Disadvantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Having standard modes simplifies validation of interactions between various\nsafety checks.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Safety is the only reason that's been considered for adding build modes."))),(0,i.kt)("li",{parentName:"ul"},"As more build modes are added, the chance of developers being confused and\nchoosing the wrong build mode for their application increases.")),(0,i.kt)("p",null,"Any long-term additions to the set of build modes will need to update this\nprinciple, raising the visibility and requiring more consideration of such an\naddition. If build modes are added for non-safety-related reasons, this may lead\nto moving build modes out of the safety strategy."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Experiment"),": This can be considered an experiment. Carbon may eventually add\nmore than the initial three build modes, although the reticence to add more is\nlikely to remain."))}u.isMDXComponent=!0}}]);