"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2904],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(a),u=i,h=m["".concat(o,".").concat(u)]||m[u]||c[u]||r;return a?n.createElement(h,s(s({ref:t},d),{},{components:a})):n.createElement(h,s({ref:t},d))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var p=2;p<r;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},3892:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={},s="Classes",l={unversionedId:"docs/design/classes",id:"docs/design/classes",title:"Classes",description:"\x3c!--",source:"@site/../docs/design/classes.md",sourceDirName:"docs/design",slug:"/docs/design/classes",permalink:"/docs/design/classes",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/design/classes.md",tags:[],version:"current",frontMatter:{},sidebar:"design",previous:{title:"Blocks and statements",permalink:"/docs/design/blocks_and_statements"},next:{title:"Code and name organization",permalink:"/docs/design/code_and_name_organization/"}},o={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Use cases",id:"use-cases",level:2},{value:"Data classes",id:"data-classes",level:3},{value:"Encapsulated types",id:"encapsulated-types",level:3},{value:"Without inheritance",id:"without-inheritance",level:4},{value:"With inheritance and subtyping",id:"with-inheritance-and-subtyping",level:4},{value:"Polymorphic types",id:"polymorphic-types",level:5},{value:"Interface as base class",id:"interface-as-base-class",level:6},{value:"Non-polymorphic inheritance",id:"non-polymorphic-inheritance",level:5},{value:"Interop with C++ multiple inheritance",id:"interop-with-c-multiple-inheritance",level:5},{value:"Mixins",id:"mixins",level:3},{value:"Background",id:"background",level:2},{value:"Members",id:"members",level:2},{value:"Data members have an order",id:"data-members-have-an-order",level:3},{value:"Struct types",id:"struct-types",level:2},{value:"Literals",id:"literals",level:3},{value:"Type expression",id:"type-expression",level:3},{value:"Assignment and initialization",id:"assignment-and-initialization",level:3},{value:"Operations performed field-wise",id:"operations-performed-field-wise",level:3},{value:"Nominal class types",id:"nominal-class-types",level:2},{value:"Forward declaration",id:"forward-declaration",level:3},{value:"Self",id:"self",level:3},{value:"Construction",id:"construction",level:3},{value:"Assignment",id:"assignment",level:4},{value:"Member functions",id:"member-functions",level:3},{value:"Class functions",id:"class-functions",level:4},{value:"Methods",id:"methods",level:4},{value:"Name lookup in member function definitions",id:"name-lookup-in-member-function-definitions",level:4},{value:"Nominal data classes",id:"nominal-data-classes",level:3},{value:"Member type",id:"member-type",level:3},{value:"Let",id:"let",level:3},{value:"Alias",id:"alias",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"Virtual methods",id:"virtual-methods",level:4},{value:"Virtual override keywords",id:"virtual-override-keywords",level:5},{value:"Subtyping",id:"subtyping",level:4},{value:"Constructors",id:"constructors",level:4},{value:"Partial facet",id:"partial-facet",level:5},{value:"Usage",id:"usage",level:5},{value:"Assignment with inheritance",id:"assignment-with-inheritance",level:4},{value:"Destructors",id:"destructors",level:3},{value:"Access control",id:"access-control",level:3},{value:"Private access",id:"private-access",level:4},{value:"Protected access",id:"protected-access",level:4},{value:"Friends",id:"friends",level:4},{value:"Test friendship",id:"test-friendship",level:4},{value:"Access control for construction",id:"access-control-for-construction",level:4},{value:"Operator overloading",id:"operator-overloading",level:3},{value:"Future work",id:"future-work",level:2},{value:"Struct literal shortcut",id:"struct-literal-shortcut",level:3},{value:"Optional named parameters",id:"optional-named-parameters",level:3},{value:"Field defaults for struct types",id:"field-defaults-for-struct-types",level:4},{value:"Destructuring in pattern matching",id:"destructuring-in-pattern-matching",level:4},{value:"Discussion",id:"discussion",level:4},{value:"Inheritance",id:"inheritance-1",level:3},{value:"C++ abstract base classes interoperating with object-safe interfaces",id:"c-abstract-base-classes-interoperating-with-object-safe-interfaces",level:4},{value:"Overloaded methods",id:"overloaded-methods",level:4},{value:"Interop with C++ inheritance",id:"interop-with-c-inheritance",level:4},{value:"Virtual base classes",id:"virtual-base-classes",level:5},{value:"Mixins",id:"mixins-1",level:3},{value:"Memory layout",id:"memory-layout",level:3},{value:"No <code>static</code> variables",id:"no-static-variables",level:3},{value:"Computed properties",id:"computed-properties",level:3},{value:"Interfaces implemented for data classes",id:"interfaces-implemented-for-data-classes",level:3},{value:"References",id:"references",level:2}],d={toc:p};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"classes"},"Classes"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#use-cases"},"Use cases"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#data-classes"},"Data classes")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#encapsulated-types"},"Encapsulated types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#without-inheritance"},"Without inheritance")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#with-inheritance-and-subtyping"},"With inheritance and subtyping"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#polymorphic-types"},"Polymorphic types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-as-base-class"},"Interface as base class")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#non-polymorphic-inheritance"},"Non-polymorphic inheritance")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interop-with-c-multiple-inheritance"},"Interop with C++ multiple inheritance")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#mixins"},"Mixins")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#background"},"Background")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#members"},"Members"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#data-members-have-an-order"},"Data members have an order")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#struct-types"},"Struct types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#literals"},"Literals")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-expression"},"Type expression")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#assignment-and-initialization"},"Assignment and initialization")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#operations-performed-field-wise"},"Operations performed field-wise")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#nominal-class-types"},"Nominal class types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#forward-declaration"},"Forward declaration")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#self"},"Self")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#construction"},"Construction"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#assignment"},"Assignment")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#member-functions"},"Member functions"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#class-functions"},"Class functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#methods"},"Methods")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#name-lookup-in-member-function-definitions"},"Name lookup in member function definitions")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#nominal-data-classes"},"Nominal data classes")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#member-type"},"Member type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#let"},"Let")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#alias"},"Alias")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#inheritance"},"Inheritance"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#virtual-methods"},"Virtual methods"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#virtual-override-keywords"},"Virtual override keywords")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#subtyping"},"Subtyping")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#constructors"},"Constructors"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#partial-facet"},"Partial facet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#usage"},"Usage")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#assignment-with-inheritance"},"Assignment with inheritance")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#destructors"},"Destructors")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#access-control"},"Access control"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#private-access"},"Private access")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#protected-access"},"Protected access")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#friends"},"Friends")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#test-friendship"},"Test friendship")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#access-control-for-construction"},"Access control for construction")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#operator-overloading"},"Operator overloading")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#future-work"},"Future work"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#struct-literal-shortcut"},"Struct literal shortcut")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#optional-named-parameters"},"Optional named parameters"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#field-defaults-for-struct-types"},"Field defaults for struct types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#destructuring-in-pattern-matching"},"Destructuring in pattern matching")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#discussion"},"Discussion")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#inheritance-1"},"Inheritance"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#c-abstract-base-classes-interoperating-with-object-safe-interfaces"},"C++ abstract base classes interoperating with object-safe interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#overloaded-methods"},"Overloaded methods")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interop-with-c-inheritance"},"Interop with C++ inheritance"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#virtual-base-classes"},"Virtual base classes")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#mixins-1"},"Mixins")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#memory-layout"},"Memory layout")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#no-static-variables"},"No ",(0,i.kt)("inlineCode",{parentName:"a"},"static")," variables")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#computed-properties"},"Computed properties")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interfaces-implemented-for-data-classes"},"Interfaces implemented for data classes")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"A Carbon ",(0,i.kt)("em",{parentName:"p"},"class")," is a user-defined\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Record_(computer_science)"},"record type"),". A\nclass has members that are referenced by their names, in contrast to a\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/tuples"},"Carbon tuple")," which defines a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Product_type"},"product type")," whose members are\nreferenced positionally."),(0,i.kt)("p",null,"Classes are the primary mechanism for users to extend the Carbon type system and\nare deeply rooted in C++ and its history (C and Simula). We call them classes\nrather than other terms as that is both familiar to existing programmers and\naccurately captures their essence: they define the types of objects with\n(optional) support for methods, encapsulation, and so on."),(0,i.kt)("p",null,'Carbon supports both named, or "nominal", and unnamed, anonymous, or\n"structural", class types. Nominal class types are all distinct, but structural\ntypes are equal if they have the same sequence of member types and names.\nStructural class literals may be used to initialize or assign values to nominal\nclass variables.'),(0,i.kt)("p",null,"A class type defines the interpretation of the bytes of a value of that type,\nincluding the size, data members, and layout. It defines the operations that may\nbe performed on those values, including what methods may be called. A class type\nmay directly have constant members. The type itself is a compile-time immutable\nconstant value."),(0,i.kt)("h2",{id:"use-cases"},"Use cases"),(0,i.kt)("p",null,"The use cases for classes include both cases motivated by C++ interop, and cases\nthat we expect to be included in idiomatic Carbon-only code."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'This design currently only attempts to address the "data classes" and\n"encapsulated types" use cases.'),' Addressing the "interface as base class",\n"interop with C++ multiple inheritance" and "mixin" use cases is future work.'),(0,i.kt)("h3",{id:"data-classes"},"Data classes"),(0,i.kt)("p",null,"Data classes are types that consist of data fields that are publicly accessible\nand directly read and manipulated by client code. They have few if any methods,\nand generally are not involved in inheritance at all."),(0,i.kt)("p",null,"Examples include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a key and value pair returned from a ",(0,i.kt)("inlineCode",{parentName:"li"},"SortedMap")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"HashMap")),(0,i.kt)("li",{parentName:"ul"},"a 2D point that might be used in a rendering API")),(0,i.kt)("p",null,"Properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Operations like copy, move, destroy, unformed, and so on are defined\nfield-wise."),(0,i.kt)("li",{parentName:"ul"},"Anonymous classes types and literals should match data class semantics.")),(0,i.kt)("p",null,"Expected in idiomatic Carbon-only code."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Background:")," Kotlin has a dedicated concise syntax for defining\n",(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/data-classes.html"},(0,i.kt)("em",{parentName:"a"},"data classes"))," that avoids\nboilerplate. Python has a\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/dataclasses.html"},"data class library"),",\nproposed in ",(0,i.kt)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0557/"},"PEP 557"),", that fills a\nsimilar role."),(0,i.kt)("h3",{id:"encapsulated-types"},"Encapsulated types"),(0,i.kt)("p",null,"There are several categories of types that support\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)"},"encapsulation"),".\nThis is done by making their data fields private so access and modification of\nvalues are all done through methods defined on the type."),(0,i.kt)("h4",{id:"without-inheritance"},"Without inheritance"),(0,i.kt)("p",null,"The common case for encapsulated types are those that do not participate in\ninheritance. These types neither support being inherited from (they are\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Non-subclassable_classes"},'"final"'),")\nnor do they extend other types."),(0,i.kt)("p",null,"Examples of this use case include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"strings, containers, iterators"),(0,i.kt)("li",{parentName:"ul"},"types with invariants such as ",(0,i.kt)("inlineCode",{parentName:"li"},"Date")),(0,i.kt)("li",{parentName:"ul"},"RAII types that are movable but not copyable like C++'s ",(0,i.kt)("inlineCode",{parentName:"li"},"std::unique_ptr")," or\na file handle"),(0,i.kt)("li",{parentName:"ul"},"non-movable types like ",(0,i.kt)("inlineCode",{parentName:"li"},"Mutex"))),(0,i.kt)("p",null,"We expect two kinds of methods on these types: public methods defining the API\nfor accessing and manipulating values of the type, and private helper methods\nused as an implementation detail of the public methods."),(0,i.kt)("p",null,"These types are expected in idiomatic Carbon-only code."),(0,i.kt)("h4",{id:"with-inheritance-and-subtyping"},"With inheritance and subtyping"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subtyping"},"subtyping")," you get with\ninheritance is that you may assign the address of an object of a derived type to\na pointer to its base type. For this to work, the compiler needs implementation\nstrategies that allow operations performed through the pointer to the base type\nwork independent of which derived type it actually points to. These strategies\ninclude:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Arranging for the data layout of derived types to start with the data layout\nof the base type as a prefix."),(0,i.kt)("li",{parentName:"ul"},"Putting a pointer to a table of function pointers, a\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Virtual_method_table"},(0,i.kt)("em",{parentName:"a"},"vtable")),", as the first\ndata member of the object. This allows methods to be\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Virtual_function"},(0,i.kt)("em",{parentName:"a"},"virtual"))," and have a\nderived-type-specific implementation, an ",(0,i.kt)("em",{parentName:"li"},"override"),", that is used even when\ninvoking the method on a pointer to a base type."),(0,i.kt)("li",{parentName:"ul"},"Non-virtual methods implemented on a base type should be applicable to all\nderived types. In general, derived types should not attempt to overload or\noverride non-virtual names defined in the base type.")),(0,i.kt)("p",null,"Note that these subtyping implementation strategies generally rely on\nencapsulation, but encapsulation is not a strict requirement in all cases."),(0,i.kt)("p",null,"This subtyping relationship also creates safety concerns, which Carbon should\nprotect against.\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object_slicing"},"Slicing problems")," can arise when\nthe source or target of an assignment is a dereferenced pointer to the base\ntype. It is also incorrect to delete an object with a non-virtual destructor\nthrough a pointer to a base type."),(0,i.kt)("h5",{id:"polymorphic-types"},"Polymorphic types"),(0,i.kt)("p",null,"Carbon will fully support single-inheritance type hierarchies with polymorphic\ntypes."),(0,i.kt)("p",null,"Polymorphic types support\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dynamic_dispatch"},"dynamic dispatch")," using a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_method_table"},"vtable"),", and data members,\nbut only single inheritance. Individual methods opt in to using dynamic\ndispatch, so types will have a mix of\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_function"},'"virtual"')," and non-virtual\nmethods. Polymorphic types support traditional\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)"},"object-oriented single inheritance"),",\na mix of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subtyping"},"subtyping")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Code_reuse"},"implementation and code reuse"),"."),(0,i.kt)("p",null,"We exclude complex multiple inheritance schemes, virtual inheritance, and so on\nfrom this use case. This is to avoid the complexity and overhead they bring,\nparticularly since the use of these features in C++ is generally discouraged.\nThe rule is that every type has at most one base type with data members for\nsubtyping purposes. Carbon will support additional base types as long as they\n",(0,i.kt)("a",{parentName:"p",href:"#interface-as-base-class"},"don't have data members")," or\n",(0,i.kt)("a",{parentName:"p",href:"#mixins"},"don't support subtyping"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Background:"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=OMPfEXIlTVE"},'The "Nothing is Something" talk by Sandi Metz'),"\nand\n",(0,i.kt)("a",{parentName:"p",href:"https://python-patterns.guide/gang-of-four/composition-over-inheritance/"},"the Composition Over Inheritance Principle"),"\ndescribe design patterns to use instead of multiple inheritance to support types\nthat vary over multiple axes."),(0,i.kt)("p",null,"In rare cases where the complex multiple inheritance schemes of C++ are truly\nneeded, they can be effectively approximated using a combination of these\nsimpler building blocks."),(0,i.kt)("p",null,"Polymorphic types support a number of different kinds of methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They will have virtual methods:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Polymorphic types will typically include virtual destructors."),(0,i.kt)("li",{parentName:"ul"},"The virtual methods types may have default implementations or be\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Method_(computer_programming)#Abstract_methods"},(0,i.kt)("em",{parentName:"a"},"abstract")),"\n(or\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions"},(0,i.kt)("em",{parentName:"a"},"pure virtual")),").\nIn the latter case, they must be implemented in any derived class that\ncan be instantiated."),(0,i.kt)("li",{parentName:"ul"},"Virtual methods may be\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Access_modifiers"},(0,i.kt)("em",{parentName:"a"},"protected"))," or\n",(0,i.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/2170688/private-virtual-method-in-c"},(0,i.kt)("em",{parentName:"a"},"private")),",\nintended to be called by methods in the base type but implemented in the\ndescendant."))),(0,i.kt)("li",{parentName:"ul"},"They may have non-virtual public or private helper methods, like\n",(0,i.kt)("a",{parentName:"li",href:"#without-inheritance"},"encapsulated types without inheritance"),". These avoid\nthe overhead of a virtual function call, and can be written when the base\nclass has sufficient data members."),(0,i.kt)("li",{parentName:"ul"},"They may have protected helper methods, typically non-virtual, provided by\nthe base type to be called by the descendant.")),(0,i.kt)("p",null,"Note that there are two uses for protected methods: those implemented in the\nbase and called in the descendant, and the other way around.\n",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=3MNVP9-hglc"},'"The End Of Object Inheritance & The Beginning Of A New Modularity" talk by Augie Fackler and Nathaniel Manista'),"\ndiscusses design patterns that split up types to reduce the number of kinds of\ncalls between base and derived types, and make sure calls only go in one\ndirection."),(0,i.kt)("p",null,"We expect polymorphic types in idiomatic Carbon-only code, at least for the\nmedium term. Extending this design to support polymorphic types is future work."),(0,i.kt)("h6",{id:"interface-as-base-class"},"Interface as base class"),(0,i.kt)("p",null,"We distinguish the specific case of polymorphic base classes that have no data\nmembers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"From an implementation perspective, the lack of data members removes most of\nthe problems with supporting multiple inheritance."),(0,i.kt)("li",{parentName:"ul"},"They are about decoupling two pieces of code instead of collaborating."),(0,i.kt)("li",{parentName:"ul"},"As a use case, they are used primarily for subtyping and much less\nimplementation reuse than other polymorphic types."),(0,i.kt)("li",{parentName:"ul"},"This case overlaps with the\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/terminology#interface"},"interface")," concept\nintroduced for ",(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/overview"},"Carbon generics"),".")),(0,i.kt)("p",null,"Removing support for data fields greatly simplifies supporting multiple\ninheritance. For example, it removes the need for a mechanism to figure out the\noffset of those data fields in the object. Similarly we don't need\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_inheritance"},"C++'s virtual inheritance"),"\nto avoid duplicating those fields. Some complexities still remain, such as\npointers changing values when casting to a secondary parent type, but these seem\nmanageable given the benefits of supporting this useful case of multiple\ninheritance."),(0,i.kt)("p",null,"While an interface base class is generally for providing an API that allows\ndecoupling two pieces of code, a polymorphic type is a collaboration between a\nbase and derived type to provide some functionality. This is a bit like the\ndifference between a library and a framework, where you might use many of the\nformer but only one of the latter."),(0,i.kt)("p",null,"Interface base classes are primarily used for subtyping. The extent of\nimplementation reuse is generally limited by the lack of data members, and the\ndecoupling role they play is usually about defining an API as a set of public\npure-virtual methods. Compared to other polymorphic types, they more rarely have\nmethods with implementations (virtual or not), or have methods with restricted\naccess. The main use case is when there is a method that is implemented in terms\nof pure-virtual methods. Those pure-virtual methods may be marked as protected\nto ensure they are only called through the non-abstract API, but can still be\nimplemented in descendants."),(0,i.kt)("p",null,"While it is typical for this case to be associated with single-level inheritance\nhierarchies, there are some cases where there is an interface at the root of a\ntype hierarchy and polymorphic types as interior branches of the tree. The case\nof generic interfaces extending or requiring other interface would also be\nmodeled by deeper inheritance hierarchies."),(0,i.kt)("p",null,"An interface as base class needs to either have a virtual destructor or forbid\ndeallocation."),(0,i.kt)("p",null,"There is significant overlap between interface base classes and\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/overview#interfaces"},"Carbon interfaces"),". Both represent APIs as a\ncollection of method names and signatures to implement. The subset of interfaces\nthat support dynamic dispatch are called ",(0,i.kt)("em",{parentName:"p"},"object-safe"),", following\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/items/traits.html#object-safety"},"Rust"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They don't have a ",(0,i.kt)("inlineCode",{parentName:"li"},"Self")," in the signature of a method in a contravariant\nposition like a parameter."),(0,i.kt)("li",{parentName:"ul"},"They don't have free associated types or other associated items used in a\nmethod signature.")),(0,i.kt)("p",null,"The restrictions on object-safe interfaces match the restrictions on base class\nmethods. The main difference is the representation in memory. A type extending a\nbase class with virtual methods includes a pointer to the table of methods in\nthe object value itself, while a type implementing an interface would store the\npointer alongside the pointer to the value in a ",(0,i.kt)("inlineCode",{parentName:"p"},"DynPtr(MyInterface)"),". Of\ncourse, the interface option also allows the method table to be passed at\ncompile time."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," This presumes that we include some concept of ",(0,i.kt)("inlineCode",{parentName:"p"},"final")," methods in\ninterfaces to match non-virtual functions in base classes."),(0,i.kt)("p",null,"We expect idiomatic Carbon-only code to generally use Carbon interfaces instead\nof interface base classes. We may still support interface base classes long term\nif we determine that the ability to put the pointer to the method\nimplementations in the object value is important for users, particularly with a\nsingle parent as in the ",(0,i.kt)("a",{parentName:"p",href:"#polymorphic-types"},"polymorphic type case"),". Extending\nthis design to support interface base classes is future work."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Background:"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Abstract_type"},"C++ abstract base classes")," that\ndon't have data members and\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Interface_(Java)"},"Java interfaces")," model this\ncase."),(0,i.kt)("h5",{id:"non-polymorphic-inheritance"},"Non-polymorphic inheritance"),(0,i.kt)("p",null,"While it is not common, there are cases where C++ code uses inheritance without\ndynamic dispatch or a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_method_table"},"vtable"),". Instead, methods\nare never overridden, and derived types only add data and methods. There are\nsome cases where this is done in C++ but would be done differently in Carbon:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For implementation reuse without subtyping, Carbon code should use mixins or\ncomposition. Carbon won't support private inheritance."),(0,i.kt)("li",{parentName:"ul"},"Carbon will allow data members to have size zero, so the\n",(0,i.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/language/ebo"},"empty-base optimization")," is\nunnecessary."),(0,i.kt)("li",{parentName:"ul"},"For cases where the derived type does not add any data members, in Carbon\nyou can potentially use adapter types instead of inheritance.")),(0,i.kt)("p",null,"However, there are still some cases where non-virtual inheritance makes sense.\nOne is a parameterized type where a prefix of the data is the same independent\nof the parameter. An example of this is containers with a\n",(0,i.kt)("a",{parentName:"p",href:"https://akrzemi1.wordpress.com/2014/04/14/common-optimizations/#sbo"},"small-buffer optimization"),",\nas described in the talk\n",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=vElZc6zSIXM"},'CppCon 2016: Chandler Carruth "High Performance Code 201: Hybrid Data Structures"'),".\nBy moving the data and methods that don't depend on the buffer size to a base\nclass, we reduce the instantiation overhead for monomorphization. The base type\nis also useful for reducing instantiation for consumers of the container, as\nlong as they only need to access methods defined in the base."),(0,i.kt)("p",null,"Another case for non-virtual inheritance is for different node types within a\ndata structure that have some data members in common. This is done in LLVM's\nmap,\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/llvm-mirror/libcxx/blob/master/include/__tree"},"red-black tree"),',\nand list data structure types. In a linked list, the base type might have the\nnext and previous pointers, which is enough for a sentinel node, and there would\nalso be a derived type with the actual data member. The base type can define\noperations like "splice" that only operate on the pointers not the data, and\nthis is in fact enforced by the type system. Only the derived node type needs to\nbe parameterized by the element type, saving on instantiation costs as before.'),(0,i.kt)("p",null,"Many of the concerns around non-polymorphic inheritance are the same as for the\nnon-virtual methods of ",(0,i.kt)("a",{parentName:"p",href:"#polymorphic-types"},"polymorphic types"),". Assignment and\ndestruction are examples of operations that need particular care to be sure they\nare only done on values of the correct type, rather than through a subtyping\nrelationship. This means having some extrinsic way of knowing when it is safe to\ndowncast before performing one of those operations, or performing them on\npointers that were never upcast to the base type."),(0,i.kt)("h5",{id:"interop-with-c-multiple-inheritance"},"Interop with C++ multiple inheritance"),(0,i.kt)("p",null,"While Carbon won't support all the C++ forms of multiple inheritance, Carbon\ncode will still need to interoperate with C++ code that does. Of particular\nconcern are the ",(0,i.kt)("inlineCode",{parentName:"p"},"std::iostream")," family of types. Most uses of those types are\nthe input and output variations or could be migrated to use those variations,\nnot the harder bidirectional cases."),(0,i.kt)("p",null,"Much of the complexity of this interoperation could be alleviated by adopting\nthe restriction that Carbon code can't directly access the fields of a virtual\nbase class. In the cases where such access is needed, the workaround is to\naccess them through C++ functions."),(0,i.kt)("p",null,"We do not expect idiomatic Carbon-only code to use multiple inheritance.\nExtending this design to support interoperating with C++ types using multiple\ninheritance is future work."),(0,i.kt)("h3",{id:"mixins"},"Mixins"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mixin"},"mixin"),' is a declaration of data,\nmethods, and interface implementations that can be added to another type, called\nthe "main type". The methods of a mixin may also use data, methods, and\ninterface implementations provided by the main type. Mixins are designed around\nimplementation reuse rather than subtyping, and so don\'t need to use a vtable.'),(0,i.kt)("p",null,"A mixin might be an implementation detail of a ",(0,i.kt)("a",{parentName:"p",href:"#data-classes"},"data class"),", or\n",(0,i.kt)("a",{parentName:"p",href:"#encapsulated-types"},"encapsulated type"),". A mixin might partially implement an\n",(0,i.kt)("a",{parentName:"p",href:"#interface-as-base-class"},"interface as base class"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Examples:"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://www.boost.org/doc/libs/1_63_0/doc/html/intrusive.html"},"intrusive linked list"),",\nintrusive reference count"),(0,i.kt)("p",null,'In both of these examples, the mixin needs the ability to convert between a\npointer to the mixin\'s data (like a "next" pointer or reference count) and a\npointer to the containing object with the main type.'),(0,i.kt)("p",null,"Mixins are expected in idiomatic Carbon-only code. Extending this design to\nsupport mixins is future work."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Background:")," Mixins are typically implemented using the\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"},"curiously recurring template pattern"),"\nin C++, but other languages support them directly."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In Dart, the mixin defines an interface that the destination type ends up\nimplementing, which restores a form of subtyping. See\n",(0,i.kt)("a",{parentName:"li",href:"https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3"},"Dart: What are mixins?"),"."),(0,i.kt)("li",{parentName:"ul"},"Swift is considering\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md"},"a proposal to add mixin support"),".")),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"See how other languages tackle this problem:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html"},"Swift"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"has two different concepts: classes support\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/Inheritance.html"},"inheritance"),"\nand use\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html"},"reference counting"),"\nwhile structs have value semantics"),(0,i.kt)("li",{parentName:"ul"},"may have\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/Initialization.html"},'constructor functions called "initializers"'),"\nand\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/Deinitialization.html"},'destructors called "deinitializers"')),(0,i.kt)("li",{parentName:"ul"},"supports\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/Properties.html"},"properties"),",\nincluding computed & lazy properties"),(0,i.kt)("li",{parentName:"ul"},"methods are const by default\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/Methods.html#ID239"},"unless marked mutating")),(0,i.kt)("li",{parentName:"ul"},"supports\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/Extensions.html"},"extensions")),(0,i.kt)("li",{parentName:"ul"},"has per-field\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html"},"access control")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch05-01-defining-structs.html"},"Rust"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"has no support for inheritance"),(0,i.kt)("li",{parentName:"ul"},"has no special constructor functions, instead has literal syntax"),(0,i.kt)("li",{parentName:"ul"},"has some convenience syntax for common cases:\n",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"},"variable and field names matching"),",\n",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"},"updating a subset of fields")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types"},"can have unnamed fields")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields"},"supports structs with size 0")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://ziglang.org/documentation/0.6.0/#struct"},"Zig"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://ziglang.org/documentation/0.6.0/#packed-struct"},"explicitly mark structs as packed to manually control layout")),(0,i.kt)("li",{parentName:"ul"},"has a struct literal syntax,\n",(0,i.kt)("a",{parentName:"li",href:"https://ziglang.org/documentation/0.6.0/#Anonymous-Struct-Literals"},"including for anonymous structs")),(0,i.kt)("li",{parentName:"ul"},"no special constructor functions"),(0,i.kt)("li",{parentName:"ul"},"supports fields with undefined values"),(0,i.kt)("li",{parentName:"ul"},"supports structs with size 0"),(0,i.kt)("li",{parentName:"ul"},"supports generics by way of memoized compile time functions accepting\nand returning types"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://ziglang.org/documentation/0.6.0/#toc-Default-Field-Values"},"supports default field values")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://ziglang.org/#Small-simple-language"},"has no properties or operator overloading -- Zig does not like hidden control flow"))))),(0,i.kt)("h2",{id:"members"},"Members"),(0,i.kt)("p",null,"The members of a class are named, and are accessed with the ",(0,i.kt)("inlineCode",{parentName:"p"},".")," notation. For\nexample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var p: Point2D = ...;\n// Data member access\np.x = 1;\np.y = 2;\n// Method call\nPrint(p.DistanceFromOrigin());\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/design/tuples"},"Tuples")," are used for cases where accessing the members positionally\nis more appropriate."),(0,i.kt)("h3",{id:"data-members-have-an-order"},"Data members have an order"),(0,i.kt)("p",null,"The data members of a class, or ",(0,i.kt)("em",{parentName:"p"},"fields"),", have an order that matches the order\nthey are declared in. This determines the order of those fields in memory, and\nthe order that the fields are destroyed when a value goes out of scope or is\ndeallocated."),(0,i.kt)("h2",{id:"struct-types"},"Struct types"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Structural data classes"),", or ",(0,i.kt)("em",{parentName:"p"},"struct types"),", are convenient for defining\n",(0,i.kt)("a",{parentName:"p",href:"#data-classes"},"data classes")," in an ad-hoc manner. They would commonly be used:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"as the return type of a function that returns multiple values and wants\nthose values to have names so a ",(0,i.kt)("a",{parentName:"li",href:"/docs/design/tuples"},"tuple")," is inappropriate"),(0,i.kt)("li",{parentName:"ul"},"as an initializer for other ",(0,i.kt)("inlineCode",{parentName:"li"},"class")," variables or values"),(0,i.kt)("li",{parentName:"ul"},"as a type parameter to a container")),(0,i.kt)("p",null,"Note that struct types are examples of ",(0,i.kt)("em",{parentName:"p"},"data class types")," and are still classes.\nThe ",(0,i.kt)("a",{parentName:"p",href:"#nominal-data-classes"},'"nominal data classes" section')," describes another\nway to define a data class type. Also note that there is no ",(0,i.kt)("inlineCode",{parentName:"p"},"struct"),' keyword,\n"struct" is just convenient shorthand terminology for a structural data class.'),(0,i.kt)("h3",{id:"literals"},"Literals"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Structural data class literals"),", or ",(0,i.kt)("em",{parentName:"p"},"struct literals"),", are written using this\nsyntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'var kvpair: auto = {.key = "the", .value = 27};\n')),(0,i.kt)("p",null,"This produces a struct value with two fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'The first field is named "',(0,i.kt)("inlineCode",{parentName:"li"},"key"),'" and has the value ',(0,i.kt)("inlineCode",{parentName:"li"},'"the"'),". The type of the\nfield is set to the type of the value, and so is ",(0,i.kt)("inlineCode",{parentName:"li"},"String"),"."),(0,i.kt)("li",{parentName:"ul"},'The second field is named "',(0,i.kt)("inlineCode",{parentName:"li"},"value"),'" and has the value ',(0,i.kt)("inlineCode",{parentName:"li"},"27"),". The type of the\nfield is set to the type of the value, and so is ",(0,i.kt)("inlineCode",{parentName:"li"},"i32"),".")),(0,i.kt)("p",null,"Note: A comma ",(0,i.kt)("inlineCode",{parentName:"p"},",")," may optionally be included after the last field:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'var kvpair: auto = {.key = "the", .value = 27,};\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," To keep the literal syntax from being ambiguous with compound\nstatements, Carbon will adopt some combination of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"looking ahead after a ",(0,i.kt)("inlineCode",{parentName:"li"},"{")," to see if it is followed by ",(0,i.kt)("inlineCode",{parentName:"li"},".name"),";"),(0,i.kt)("li",{parentName:"ul"},"not allowing a struct literal at the beginning of a statement;"),(0,i.kt)("li",{parentName:"ul"},"only allowing ",(0,i.kt)("inlineCode",{parentName:"li"},"{")," to introduce a compound statement in contexts introduced\nby a keyword where they are required, like requiring ",(0,i.kt)("inlineCode",{parentName:"li"},"{ ... }")," around the\ncases of an ",(0,i.kt)("inlineCode",{parentName:"li"},"if...else")," statement.")),(0,i.kt)("h3",{id:"type-expression"},"Type expression"),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"kvpair")," in the last example would be represented by this\nexpression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{.key: String, .value: i32}\n")),(0,i.kt)("p",null,"This syntax is intended to parallel the literal syntax, and so uses commas (",(0,i.kt)("inlineCode",{parentName:"p"},","),")\nto separate fields instead of a semicolon (",(0,i.kt)("inlineCode",{parentName:"p"},";"),") terminator. This choice also\nreflects the expected use inline in function signature declarations."),(0,i.kt)("p",null,"Struct types may only have data members, so the type declaration is just a list\nof field names and types. The result of a struct type expression is an immutable\ncompile-time type value."),(0,i.kt)("p",null,"Note: Like with struct literal expressions, a comma ",(0,i.kt)("inlineCode",{parentName:"p"},",")," may optionally be\nincluded after the last field:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{.key: String, .value: i32,}\n")),(0,i.kt)("p",null,"Also note that ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," represents both the empty struct literal and its type."),(0,i.kt)("h3",{id:"assignment-and-initialization"},"Assignment and initialization"),(0,i.kt)("p",null,"When initializing or assigning a variable with a data class such as a struct\ntype to a struct value on the right hand side, the order of the fields does not\nhave to match, just the names."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var different_order: {.x: i32, .y: i32} = {.y = 2, .x = 3};\nAssert(different_order.x == 3);\nAssert(different_order.y == 2);\n")),(0,i.kt)("p",null,"Initialization and assignment occur field-by-field. The order of fields is\ndetermined from the target on the left side of the ",(0,i.kt)("inlineCode",{parentName:"p"},"="),". This rule matches what\nwe expect for classes with encapsulation more generally."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," What operations and in what order happen for assignment and\ninitialization?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Is assignment just destruction followed by initialization? Is that\ndestruction completed for the whole object before initializing, or is it\ninterleaved field-by-field?"),(0,i.kt)("li",{parentName:"ul"},"When initializing to a literal value, is a temporary containing the literal\nvalue constructed first or are the fields initialized directly? The latter\napproach supports types that can't be moved or copied, such as mutex."),(0,i.kt)("li",{parentName:"ul"},"Perhaps some operations are ",(0,i.kt)("em",{parentName:"li"},"not")," ordered with respect to each other?")),(0,i.kt)("h3",{id:"operations-performed-field-wise"},"Operations performed field-wise"),(0,i.kt)("p",null,"Generally speaking, the operations that are available on a data class value,\nsuch as a value with a struct type, are dependent on those operations being\navailable for all the types of the fields."),(0,i.kt)("p",null,"For example, two values of the same data class type may be compared for equality\nor inequality if equality is supported for every member of the type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var p: auto = {.x = 2, .y = 3};\nAssert(p == {.x = 2, .y = 3});\nAssert(p != {.x = 2, .y = 4});\nAssert({.x = 2, .y = 4} != {.x = 5, .y = 3});\n")),(0,i.kt)("p",null,"Equality and inequality comparisons are also allowed between different data\nclass types when:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"At least one is a struct type."),(0,i.kt)("li",{parentName:"ul"},"They have the same set of field names, though the order may be different."),(0,i.kt)("li",{parentName:"ul"},"Equality comparison is defined between the pairs of member types with the\nsame field names.")),(0,i.kt)("p",null,"For example, since\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0702.md#built-in-comparisons-and-implicit-conversions"},"comparison between ",(0,i.kt)("inlineCode",{parentName:"a"},"i32")," and ",(0,i.kt)("inlineCode",{parentName:"a"},"u32")," is defined"),",\nequality comparison between values of types ",(0,i.kt)("inlineCode",{parentName:"p"},"{.x: i32, .y: i32}")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"{.y: u32, .x: u32}")," is as well. Equality and inequality comparisons compare\nfields using the field order of the left-hand operand and stop once the outcome\nof the comparison is determined. However, the comparison order and\nshort-circuiting are generally expected to affect only the performance\ncharacteristics of the comparison and not its meaning."),(0,i.kt)("p",null,"Ordering comparisons, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"<")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<="),", use the order of the fields to do a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lexicographic_order"},"lexicographical comparison"),".\nThe argument types must have a matching order of the field names. Otherwise, the\nrestrictions on ordering comparisons between different data class types are\nanalogous to equality comparisons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"At least one is a struct type."),(0,i.kt)("li",{parentName:"ul"},"Ordering comparison is defined between the pairs of member types with the\nsame field names.")),(0,i.kt)("p",null,"Implicit conversion from a struct type to a data class type is allowed when the\nset of field names is the same and implicit conversion is defined between the\npairs of member types with the same field names. So calling a function\neffectively performs an assignment from each of the caller's arguments to the\nfunction's parameters, and will be valid when those assignments are all valid."),(0,i.kt)("p",null,"A data class has an unformed state if all its members do. Treatment of unformed\nstate follows proposal\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/pull/257"},"#257"),"."),(0,i.kt)("p",null,"Destruction is performed field-wise in reverse order."),(0,i.kt)("p",null,"Extending user-defined operations on the fields to an operation on an entire\ndata class is ",(0,i.kt)("a",{parentName:"p",href:"#interfaces-implemented-for-data-classes"},"future work"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," The rules for assignment, comparison, and implicit conversion\nfor argument passing were decided in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/710"},"question-for-leads issue #710"),"."),(0,i.kt)("h2",{id:"nominal-class-types"},"Nominal class types"),(0,i.kt)("p",null,"The declarations for nominal class types will have:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"an optional ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"base")," prefix"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"class")," introducer"),(0,i.kt)("li",{parentName:"ul"},"the name of the class"),(0,i.kt)("li",{parentName:"ul"},"an optional ",(0,i.kt)("inlineCode",{parentName:"li"},"extends")," followed by the name of the immediate base class"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{"),", an open curly brace"),(0,i.kt)("li",{parentName:"ul"},"a sequence of declarations"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"}"),", a close curly brace")),(0,i.kt)("p",null,"Declarations should generally match declarations that can be declared in other\ncontexts, for example variable declarations with ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," will define\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Instance_variable"},"instance variables"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'class TextLabel {\n  var x: i32;\n  var y: i32;\n\n  var text: String = "default";\n}\n')),(0,i.kt)("p",null,"The main difference here is that ",(0,i.kt)("inlineCode",{parentName:"p"},'"default"')," is a default instead of an\ninitializer, and will be ignored if another value is supplied for that field\nwhen constructing a value. Defaults must be constants whose value can be\ndetermined at compile time."),(0,i.kt)("h3",{id:"forward-declaration"},"Forward declaration"),(0,i.kt)("p",null,"To support circular references between class types, we allow\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Forward_declaration"},"forward declaration")," of\ntypes. Forward declarations end with semicolon ",(0,i.kt)("inlineCode",{parentName:"p"},";")," after the name of the class,\ninstead of any ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," clause and the block of declarations in curly braces\n",(0,i.kt)("inlineCode",{parentName:"p"},"{"),"...",(0,i.kt)("inlineCode",{parentName:"p"},"}"),". A type that is forward declared is considered incomplete until the\nend of a definition with the same name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Forward declaration of `GraphNode`.\nclass GraphNode;\n\nclass GraphEdge {\n  var head: GraphNode*;\n  var tail: GraphNode*;\n}\n\nclass GraphNode {\n  var edges: Vector(GraphEdge*);\n}\n// `GraphNode` is first complete here.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," What is specifically allowed and forbidden with an incomplete\ntype has not yet been decided."),(0,i.kt)("h3",{id:"self"},"Self"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," definition may provisionally include references to its own name in\nlimited ways. These limitations arise from the type not being complete until the\nend of its definition is reached."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class IntListNode {\n  var data: i32;\n  var next: IntListNode*;\n}\n")),(0,i.kt)("p",null,"An equivalent definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"IntListNode"),", since ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," is an alias for the\ncurrent type, is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class IntListNode {\n  var data: i32;\n  var next: Self*;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Self")," refers to the innermost type declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class IntList {\n  class IntListNode {\n    var data: i32;\n    var next: Self*;\n  }\n  var first: IntListNode*;\n}\n")),(0,i.kt)("h3",{id:"construction"},"Construction"),(0,i.kt)("p",null,"Any function with access to all the data fields of a class can construct one by\nconverting a ",(0,i.kt)("a",{parentName:"p",href:"#struct-types"},"struct value")," to the class type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var tl1: TextLabel = {.x = 1, .y = 2};\nvar tl2: auto = {.x = 1, .y = 2} as TextLabel;\n\nAssert(tl1.x == tl2.x);\n\nfn ReturnsATextLabel() -> TextLabel {\n  return {.x = 1, .y = 2};\n}\nvar tl3: TextLabel = ReturnsATextLabel();\n\nfn AcceptsATextLabel(tl: TextLabel) -> i32 {\n  return tl.x + tl.y;\n}\nAssert(AcceptsATextLabel({.x = 2, .y = 4}) == 6);\n")),(0,i.kt)("p",null,"Note that a nominal class, unlike a ",(0,i.kt)("a",{parentName:"p",href:"#type-expression"},"struct type"),", can define\ndefault values for fields, and so may be initialized with a\n",(0,i.kt)("a",{parentName:"p",href:"#literals"},"struct value")," that omits some or all of those fields."),(0,i.kt)("h4",{id:"assignment"},"Assignment"),(0,i.kt)("p",null,"Assignment to a struct value is also allowed in a function with access to all\nthe data fields of a class. Assignment always overwrites all of the field\nmembers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'var tl: TextLabel = {.x = 1, .y = 2};\nAssert(tl.text == "default");\n\n// \u2705 Allowed: assigns all fields\ntl = {.x = 3, .y = 4, .text = "new"};\n\n// \u2705 Allowed: This statement is evaluated in two steps:\n// 1. {.x = 5, .y = 6} is converted into a new TextLabel value,\n//    using default for field `text`.\n// 2. tl is assigned to a TextLabel, which has values for all\n//    fields.\ntl = {.x = 5, .y = 6};\nAssert(tl.text == "default");\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," This behavior might be surprising because there is an\nambiguity about whether to use the default value or the previous value for a\nfield. We could require all fields to be specified when assigning, and only use\nfield defaults when initializing a new value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// \u274c Forbidden: should tl.text == "default" or "new"?\ntl = {.x = 5, .y = 6};\n')),(0,i.kt)("h3",{id:"member-functions"},"Member functions"),(0,i.kt)("p",null,"Member functions can either be class functions or methods. Class functions are\nmembers of the type, while methods can only be called on instances."),(0,i.kt)("h4",{id:"class-functions"},"Class functions"),(0,i.kt)("p",null,"A class function is like a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Static_(keyword)#Static_method"},"C++ static member function or method"),",\nand is declared like a function at file scope. The declaration can include a\ndefinition of the function body, or that definition can be provided out of line\nafter the class definition is finished. A common use is for constructor\nfunctions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Point {\n  fn Origin() -> Self {\n    return {.x = 0, .y = 0};\n  }\n  fn CreateCentered() -> Self;\n\n  var x: i32;\n  var y: i32;\n}\n\nfn Point.CreateCentered() -> Self {\n  return {.x = ScreenWidth() / 2, .y = ScreenHeight() / 2};\n}\n")),(0,i.kt)("p",null,"Class functions are members of the type, and may be accessed as using dot ",(0,i.kt)("inlineCode",{parentName:"p"},"."),"\nmember access either the type or any instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var p1: Point = Point.Origin();\nvar p2: Point = p1.CreateCentered();\n")),(0,i.kt)("h4",{id:"methods"},"Methods"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Method_(computer_programming)"},"Method"),"\ndeclarations are distinguished from ",(0,i.kt)("a",{parentName:"p",href:"#class-functions"},"class function"),"\ndeclarations by having a ",(0,i.kt)("inlineCode",{parentName:"p"},"me")," parameter in square brackets ",(0,i.kt)("inlineCode",{parentName:"p"},"["),"...",(0,i.kt)("inlineCode",{parentName:"p"},"]")," before the\nexplicit parameter list in parens ",(0,i.kt)("inlineCode",{parentName:"p"},"("),"...",(0,i.kt)("inlineCode",{parentName:"p"},")"),". There is no implicit member access\nin methods, so inside the method body members are accessed through the ",(0,i.kt)("inlineCode",{parentName:"p"},"me"),"\nparameter. Methods may be written lexically inline or after the class\ndeclaration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Circle {\n  fn Diameter[me: Self]() -> f32 {\n    return me.radius * 2;\n  }\n  fn Expand[addr me: Self*](distance: f32);\n\n  var center: Point;\n  var radius: f32;\n}\n\nfn Circle.Expand[addr me: Self*](distance: f32) {\n  me->radius += distance;\n}\n\nvar c: Circle = {.center = Point.Origin(), .radius = 1.5 };\nAssert(Math.Abs(c.Diameter() - 3.0) < 0.001);\nc.Expand(0.5);\nAssert(Math.Abs(c.Diameter() - 4.0) < 0.001);\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Methods are called using the dot ",(0,i.kt)("inlineCode",{parentName:"li"},".")," member syntax, ",(0,i.kt)("inlineCode",{parentName:"li"},"c.Diameter()")," and\n",(0,i.kt)("inlineCode",{parentName:"li"},"c.Expand("),"...",(0,i.kt)("inlineCode",{parentName:"li"},")"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Diameter")," computes and returns the diameter of the circle without modifying\nthe ",(0,i.kt)("inlineCode",{parentName:"li"},"Circle")," instance. This is signified using ",(0,i.kt)("inlineCode",{parentName:"li"},"[me: Self]")," in the method\ndeclaration."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"c.Expand("),"...",(0,i.kt)("inlineCode",{parentName:"li"},")")," does modify the value of ",(0,i.kt)("inlineCode",{parentName:"li"},"c"),". This is signified using\n",(0,i.kt)("inlineCode",{parentName:"li"},"[addr me: Self*]")," in the method declaration.")),(0,i.kt)("p",null,"The pattern '",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," ",(0,i.kt)("em",{parentName:"p"},"patt"),"' means \"first take the address of the argument, which\nmust be an\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue"},"l-value"),", and\nthen match pattern ",(0,i.kt)("em",{parentName:"p"},"patt"),' against it".'),(0,i.kt)("p",null,"If the method declaration also includes\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/overview#deduced-parameters"},"deduced generic parameters"),",\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"me")," parameter must be in the same list in square brackets ",(0,i.kt)("inlineCode",{parentName:"p"},"["),"...",(0,i.kt)("inlineCode",{parentName:"p"},"]"),". The\n",(0,i.kt)("inlineCode",{parentName:"p"},"me")," parameter may appear in any position in that list, as long as it appears\nafter any names needed to describe its type."),(0,i.kt)("h4",{id:"name-lookup-in-member-function-definitions"},"Name lookup in member function definitions"),(0,i.kt)("p",null,"When defining a member function lexically inline, we delay type checking of the\nfunction body until the definition of the current type is complete. This means\nthat name lookup ",(0,i.kt)("em",{parentName:"p"},"for members of objects")," is also delayed. That means that you\ncan reference ",(0,i.kt)("inlineCode",{parentName:"p"},"me.F()")," in a lexically inline method definition even before the\ndeclaration of ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," in that class definition. However, other names still need to\nbe declared before they are used. This includes unqualified names, names within\nnamespaces, and names ",(0,i.kt)("em",{parentName:"p"},"for members of types"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Point {\n  fn Distance[me: Self]() -> f32 {\n    // \u2705 Allowed: `x` and `y` are names for members of an object,\n    // and so lookup is delayed until `type_of(me) == Self` is complete.\n    return Math.Sqrt(me.x * me.x + me.y * me.y);\n  }\n\n  fn CreatePolarInvalid(r: f32, theta: f32) -> Point {\n    // \u274c Forbidden: unqualified name used before declaration.\n    return Create(r * Math.Cos(theta), r * Math.Sin(theta));\n  }\n  fn CreatePolarValid1(r: f32, theta: f32) -> Point {\n    // \u274c Forbidden: `Create` is not yet declared.\n    return Point.Create(r * Math.Cos(theta), r * Math.Sin(theta));\n  }\n  fn CreatePolarValid2(r: f32, theta: f32) -> Point {\n    // \u274c Forbidden: `Create` is not yet declared.\n    return Self.Create(r * Math.Cos(theta), r * Math.Sin(theta));\n  }\n\n  fn Create(x: f32, y: f32) -> Point {\n    // \u2705 Allowed: checking that conversion of `{.x: f32, .y: f32}`\n    // to `Point` is delayed until `Point` is complete.\n    return {.x = x, .y = y};\n  }\n\n  fn CreateXEqualsY(xy: f32) -> Point {\n    // \u2705 Allowed: `Create` is declared earlier.\n    return Create(xy, xy);\n  }\n\n  fn CreateXAxis(x: f32) -> Point;\n\n  fn Angle[me: Self]() -> f32;\n\n  var x: f32;\n  var y: f32;\n}\n\nfn Point.CreateXAxis(x: f32) -> Point;\n  // \u2705 Allowed: `Point` type is complete.\n  // Members of `Point` like `Create` are in scope.\n  return Create(x, 0);\n}\n\nfn Point.Angle[me: Self]() -> f32 {\n  // \u2705 Allowed: `Point` type is complete.\n  // Function is checked immediately.\n  return Math.ATan2(me.y, me.x);\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," The details of name lookup are still being decided in issue\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/472"},"#472: Open question: Calling functions defined later in the same file"),"."),(0,i.kt)("h3",{id:"nominal-data-classes"},"Nominal data classes"),(0,i.kt)("p",null,"We will mark ",(0,i.kt)("a",{parentName:"p",href:"#data-classes"},"data classes")," with an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl as Data {}")," line."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class TextLabel {\n  var x: i32;\n  var y: i32;\n\n  var text: String;\n\n  // This line makes `TextLabel` a data class, which defines\n  // a number of operations field-wise.\n  impl as Data {}\n}\n")),(0,i.kt)("p",null,"The fields of data classes must all be public. That line will add\n",(0,i.kt)("a",{parentName:"p",href:"#operations-performed-field-wise"},"field-wise implementations and operations of all interfaces that a struct with the same fields would get by default"),"."),(0,i.kt)("p",null,"The word ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," here refers to an empty interface in the Carbon prologue. That\ninterface would then be part of our\n",(0,i.kt)("a",{parentName:"p",href:"#interfaces-implemented-for-data-classes"},"strategy for defining how other interfaces are implemented for data classes"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," Rationale for this approach is given in proposal\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0722.md#nominal-data-class"},"#722"),"."),(0,i.kt)("h3",{id:"member-type"},"Member type"),(0,i.kt)("p",null,"Additional types may be defined in the scope of a class definition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class StringCounts {\n  class Node {\n    var key: String;\n    var count: i32;\n  }\n  var counts: Vector(Node);\n}\n")),(0,i.kt)("p",null,"The inner type is a member of the type, and is given the name\n",(0,i.kt)("inlineCode",{parentName:"p"},"StringCounts.Node"),". This case is called a ",(0,i.kt)("em",{parentName:"p"},"member class")," since the type is a\nclass, but other kinds of type declarations, like choice types, are allowed."),(0,i.kt)("h3",{id:"let"},"Let"),(0,i.kt)("p",null,"Other type constants can be defined using a ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class MyClass {\n  let Pi:! f32 = 3.141592653589793;\n  let IndexType:! Type = i32;\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},":!")," indicates that this is defining a compile-time constant, and so does\nnot affect the storage of instances of that class."),(0,i.kt)("h3",{id:"alias"},"Alias"),(0,i.kt)("p",null,"You may declare aliases of the names of class members. This is to allow them to\nbe renamed in multiple steps or support alternate names."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'class StringPair {\n  var key: String;\n  var value: String;\n  alias first = key;\n  alias second = value;\n}\n\nvar sp1: StringPair = {.key = "K", .value = "1"};\nvar sp2: StringPair = {.first = "K", .second = "2"};\nAssert(sp1.first == sp2.key);\nAssert(&sp1.first == &sp1.key);\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," This needs to be connected to the broader design of aliases,\nonce that lands."),(0,i.kt)("h3",{id:"inheritance"},"Inheritance"),(0,i.kt)("p",null,"Carbon supports\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)"},"inheritance"),"\nusing a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Class_(computer_programming)#Hierarchical"},"class hierarchy"),",\non an opt-in basis. Classes by default are\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Non-subclassable_classes"},(0,i.kt)("em",{parentName:"a"},"final")),",\nwhich means they may not be extended. To declare a class as allowing extension,\nuse either the ",(0,i.kt)("inlineCode",{parentName:"p"},"base class")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract class")," introducer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"base class MyBaseClass { ... }\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"base class")," may be ",(0,i.kt)("em",{parentName:"p"},"extended")," to get a ",(0,i.kt)("em",{parentName:"p"},"derived class"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"base class MiddleDerived extends MyBaseClass { ... }\nclass FinalDerived extends MiddleDerived { ... }\n// \u274c Forbidden: class Illegal extends FinalDerived { ... }\n")),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"https://en.wikipedia.org/wiki/Abstract_type"},"abstract class"))," or ",(0,i.kt)("em",{parentName:"p"},"abstract\nbase class")," is a base class that may not be instantiated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"abstract class MyAbstractClass { ... }\n// \u274c Forbidden: var a: MyAbstractClass = ...;\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," For now, the Carbon design only supports single inheritance. In\nthe future, Carbon will support multiple inheritance with limitations on all\nbase classes except the one listed first."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Terminology:")," We say ",(0,i.kt)("inlineCode",{parentName:"p"},"MiddleDerived")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"FinalDerived")," are ",(0,i.kt)("em",{parentName:"p"},"derived\nclasses"),", transitively extending or ",(0,i.kt)("em",{parentName:"p"},"derived from")," ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseClass"),". Similarly\n",(0,i.kt)("inlineCode",{parentName:"p"},"FinalDerived")," is derived from or extends ",(0,i.kt)("inlineCode",{parentName:"p"},"MiddleDerived"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"MiddleDerived")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"FinalDerived"),"'s ",(0,i.kt)("em",{parentName:"p"},"immediate base class"),", and both ",(0,i.kt)("inlineCode",{parentName:"p"},"MiddleDerived")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseClass")," are base classes of ",(0,i.kt)("inlineCode",{parentName:"p"},"FinalDerived"),". Base classes that are not\nabstract are called ",(0,i.kt)("em",{parentName:"p"},"extensible classes"),"."),(0,i.kt)("p",null,"A derived class has all the members of the class it extends, including data\nmembers and methods, though it may not be able to access them if they were\ndeclared ",(0,i.kt)("inlineCode",{parentName:"p"},"private"),"."),(0,i.kt)("h4",{id:"virtual-methods"},"Virtual methods"),(0,i.kt)("p",null,"A base class may define\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_function"},"virtual methods"),". These are\nmethods whose implementation may be overridden in a derived class."),(0,i.kt)("p",null,"Only methods defined in the scope of the class definition may be virtual, not\nany defined in\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#external-impl"},"external interface impls"),".\nInterface methods may be implemented using virtual methods when the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#implementing-interfaces"},"impl is internal"),",\nand calls to those methods by way of the interface will do virtual dispatch just\nlike a direct call to the method does."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#class-functions"},"Class functions")," may not be declared virtual."),(0,i.kt)("h5",{id:"virtual-override-keywords"},"Virtual override keywords"),(0,i.kt)("p",null,"A method is declared as virtual by using a ",(0,i.kt)("em",{parentName:"p"},"virtual override keyword")," in its\ndeclaration before ",(0,i.kt)("inlineCode",{parentName:"p"},"fn"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"base class MyBaseClass {\n  virtual fn Overridable[me: Self]() -> i32 { return 7; }\n}\n")),(0,i.kt)("p",null,"This matches C++, and makes it relatively easy for authors of derived classes to\nfind the functions that can be overridden."),(0,i.kt)("p",null,"If no keyword is specified, the default for methods is that they are\n",(0,i.kt)("em",{parentName:"p"},"non-virtual"),". This means:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"they can't override methods in bases of this class;"),(0,i.kt)("li",{parentName:"ul"},"they can't be overridden in derived classes; and"),(0,i.kt)("li",{parentName:"ul"},"they have an implementation in the current class, and that implementation\nmust work for all derived classes.")),(0,i.kt)("p",null,"There are three virtual override keywords:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"virtual")," - This marks a method as not present in bases of this class and\nhaving an implementation in this class. That implementation may be\noverridden in derived classes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),' - This marks a method that must be overridden in a derived class\nsince it has no implementation in this class. This is short for "abstract\nvirtual" but is called\n',(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions"},'"pure virtual" in C++'),".\nOnly abstract classes may have unimplemented abstract methods."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl")," - This marks a method that overrides a method marked ",(0,i.kt)("inlineCode",{parentName:"li"},"virtual")," or\n",(0,i.kt)("inlineCode",{parentName:"li"},"abstract")," in the base class with an implementation specific to -- and\ndefined within -- this class. The method is still virtual and may be\noverridden again in subsequent derived classes if this is a base class. See\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Method_overriding"},"method overriding in Wikipedia"),".\nRequiring a keyword when overriding allows the compiler to diagnose when the\nderived class accidentally uses the wrong signature or spelling and so\ndoesn't match the base class. We intentionally use the same keyword here as\nfor implementing interfaces, to emphasize that they are similar operations.")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Keyword on",(0,i.kt)("br",null),"method in ",(0,i.kt)("inlineCode",{parentName:"th"},"C")),(0,i.kt)("th",{parentName:"tr",align:null},"Allowed in",(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"th"},"abstract class C")),(0,i.kt)("th",{parentName:"tr",align:null},"Allowed in",(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"th"},"base class C")),(0,i.kt)("th",{parentName:"tr",align:null},"Allowed in",(0,i.kt)("br",null),"final ",(0,i.kt)("inlineCode",{parentName:"th"},"class C")),(0,i.kt)("th",{parentName:"tr",align:null},"in ",(0,i.kt)("inlineCode",{parentName:"th"},"B")," where",(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"th"},"C extends B")),(0,i.kt)("th",{parentName:"tr",align:null},"in ",(0,i.kt)("inlineCode",{parentName:"th"},"D")," where",(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"th"},"D extends C")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"virtual")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"\u274c"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"not present")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"abstract"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"impl"),(0,i.kt)("br",null),(0,i.kt)("em",{parentName:"td"},"not mentioned"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"abstract")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"\u274c"),(0,i.kt)("td",{parentName:"tr",align:null},"\u274c"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"not present"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"virtual"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"abstract"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"impl")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"abstract"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"impl"),(0,i.kt)("br",null),(0,i.kt)("em",{parentName:"td"},"may not be",(0,i.kt)("br",null),"mentioned if",(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"em"},"D")," is not final"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"impl")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"virtual"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"abstract"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"impl")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"abstract"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"impl"))))),(0,i.kt)("h4",{id:"subtyping"},"Subtyping"),(0,i.kt)("p",null,"A pointer to a base class, like ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseClass*")," is actually considered to be a\npointer to that type or any derived class, like ",(0,i.kt)("inlineCode",{parentName:"p"},"MiddleDerived")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"FinalDerived"),". This means that a ",(0,i.kt)("inlineCode",{parentName:"p"},"FinalDerived*")," value may be implicitly cast\nto type ",(0,i.kt)("inlineCode",{parentName:"p"},"MiddleDerived*")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseClass*"),"."),(0,i.kt)("p",null,"This is accomplished by making the data layout of a type extending ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseClass"),"\nhave ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseClass")," as a prefix. In addition, the first class in the inheritance\nchain with a virtual method will include a virtual pointer, or ",(0,i.kt)("em",{parentName:"p"},"vptr"),", pointing\nto a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_method_table"},"virtual method table"),",\nor ",(0,i.kt)("em",{parentName:"p"},"vtable"),". Any calls to virtual methods will perform\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dynamic_dispatch"},"dynamic dispatch")," by calling\nthe method using the function pointer in the vtable, to get the overridden\nimplementation from the most derived class that implements the method."),(0,i.kt)("p",null,"Since a final class may not be extended, the compiler can bypass the vtable and\nuse ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Static_dispatch"},"static dispatch"),". In\ngeneral, you can use a combination of an abstract base class and a final class\ninstead of an extensible class if you need to distinguish between exactly a type\nand possibly a subtype."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"base class Extensible { ... }\n\n// Can be replaced by:\n\nabstract class ExtensibleBase { ... }\nclass ExactlyExtensible extends ExtensibleBase { ... }\n")),(0,i.kt)("h4",{id:"constructors"},"Constructors"),(0,i.kt)("p",null,"Like for classes without inheritance, constructors for a derived class are\nordinary functions that return an instance of the derived class. Generally\nconstructor functions should return the constructed value without copying, as in\nproposal\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/pull/257"},"#257: Initialization of memory and variables"),".\nThis means either\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0257.md#function-returns-and-initialization"},"creating the object in the return statement itself"),",\nor in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0257.md#declared-returned-variable"},"a ",(0,i.kt)("inlineCode",{parentName:"a"},"returned var")," declaration"),".\nAs before, instances can be created using by casting a struct value into the\nclass type, this time with a ",(0,i.kt)("inlineCode",{parentName:"p"},".base")," member to initialize the members of the\nimmediate base type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class MyDerivedType extends MyBaseType {\n  fn Create() -> MyDerivedType {\n    return {.base = MyBaseType.Create(), .derived_field = ...};\n  }\n}\n")),(0,i.kt)("p",null,"There are two cases that aren't well supported with this pattern:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Users cannot create a value of an abstract class, which is necessary when it\nhas private fields or otherwise requires initialization."),(0,i.kt)("li",{parentName:"ul"},"Users may want to reduce the chance of mistakes from calling a method on a\npartially constructed object. Of particular concern is calling a virtual\nmethod prior to forming the derived class and so it uses the base class\nimplementation.")),(0,i.kt)("p",null,"While expected to be relatively rarely needed, we will address both of these\nconcerns with a specialized type just used during construction of base classes,\ncalled the partial facet type for the class."),(0,i.kt)("h5",{id:"partial-facet"},"Partial facet"),(0,i.kt)("p",null,"The partial facet for a base class type like ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseType")," is written\n",(0,i.kt)("inlineCode",{parentName:"p"},"partial MyBaseType"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Only methods that take the partial facet type may be called on the partial\nfacet type, so methods have to opt in to being called on an object that\nisn't fully constructed."),(0,i.kt)("li",{parentName:"ul"},"No virtual methods may take the partial facet type, so there is no way to\ntransitively call a virtual method on an object that isn't fully\nconstructed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass")," have the same fields in the same\norder with the same data layout. The only difference is that\n",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass")," doesn't use (look into) its hidden vptr slot. To\nreliably catch any bugs where virtual function calls occur in this state,\nboth fast and hardened release builds will initialize the hidden vptr slot\nto a null pointer. Debug builds will initialize it to an alternate vtable\nwhose functions will abort the program with a clear diagnostic."),(0,i.kt)("li",{parentName:"ul"},"Since ",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass")," has the same data layout but only uses a subset,\nthere is a subtyping relationship between these types. A ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass")," value\nis a ",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass")," value, but not the other way around. So you can\ncast ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass*")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass*"),", but the other direction is\nnot safe."),(0,i.kt)("li",{parentName:"ul"},"When ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass")," may be instantiated, there is a conversion from\n",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass"),". It changes the value by filling in\nthe hidden vptr slot. If ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass")," is abstract, then attempting that\nconversion is an error."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass")," is considered final, even if ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass")," is not.\nThis is despite the fact that from a data layout perspective,\n",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyDerivedClass")," will have ",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass")," as a prefix if\n",(0,i.kt)("inlineCode",{parentName:"li"},"MyDerivedClass")," extends ",(0,i.kt)("inlineCode",{parentName:"li"},"MyBaseClass"),". The type ",(0,i.kt)("inlineCode",{parentName:"li"},"partial MyBaseClass"),"\nspecifically means \"exactly this and no more.\" This means we don't need to\nlook at the hidden vptr slot, and we can instantiate it even if it doesn't\nhave a virtual ",(0,i.kt)("a",{parentName:"li",href:"#destructors"},"destructor"),"."),(0,i.kt)("li",{parentName:"ul"},"The keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"partial")," may only be applied to a base class. For final\nclasses, there is no need for a second type.")),(0,i.kt)("h5",{id:"usage"},"Usage"),(0,i.kt)("p",null,"The general pattern is that base classes can define constructors returning the\npartial facet type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"base class MyBaseClass {\n  fn Create() -> partial Self {\n    return {.base_field_1 = ..., .base_field_2 = ...};\n  }\n  // ...\n}\n")),(0,i.kt)("p",null,"Extensible classes can be instantiated even from a partial facet value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var mbc: MyBaseClass = MyBaseClass.Create();\n")),(0,i.kt)("p",null,"The conversion from ",(0,i.kt)("inlineCode",{parentName:"p"},"partial MyBaseClass")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBaseClass")," only fills in the\nvptr value and can be done in place. After the conversion, all public methods\nmay be called, including virtual methods."),(0,i.kt)("p",null,"The partial facet is required for abstract classes, since otherwise they may not\nbe instantiated. Constructor functions for abstract classes should be marked\n",(0,i.kt)("a",{parentName:"p",href:"#protected-access"},"protected")," so they may only be accessed in derived classes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"abstract class MyAbstractClass {\n  protected fn Create() -> partial Self {\n    return {.base_field_1 = ..., .base_field_2 = ...};\n  }\n  // ...\n}\n// \u274c Error: can't instantiate abstract class\nvar abc: MyAbstractClass = ...;\n")),(0,i.kt)("p",null,"If a base class wants to store a pointer to itself somewhere in the constructor\nfunction, there are two choices:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"An extensible class could use the plain type instead of the partial facet."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"base class MyBaseClass {\n  fn Create() -> Self {\n    returned var result: Self = {...};\n    StoreMyPointerSomewhere(&result);\n    return var;\n  }\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The other choice is to explicitly cast the type of its address. This pointer\nshould not be used to call any virtual method until the object is finished\nbeing constructed, since the vptr will be null."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"abstract class MyAbstractClass {\n  protected fn Create() -> partial Self {\n    returned var result: partial Self = {...};\n    // Careful! Pointer to object that isn't fully constructed!\n    StoreMyPointerSomewhere(&result as Self*);\n    return var;\n  }\n}\n")))),(0,i.kt)("p",null,"The constructor for a derived class may construct values from a partial facet of\nthe class' immediate base type or the full type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"abstract class MyAbstractClass {\n  protected fn Create() -> partial Self { ... }\n}\n\n// Base class returns a partial type\nbase class Derived extends MyAbstractClass {\n  protected fn Create() -> partial Self {\n    return {.base = MyAbstractClass.Create(), .derived_field = ...};\n  }\n  ...\n}\n\nbase class MyBaseClass {\n  fn Create() -> Self { ... }\n}\n\n// Base class returns a full type\nbase class ExtensibleDerived extends MyBaseClass {\n  fn Create() -> Self {\n    return {.base = MyBaseClass.Create(), .derived_field = ...};\n  }\n  ...\n}\n")),(0,i.kt)("p",null,"And final classes will return a type that does not use the partial facet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class FinalDerived extends MiddleDerived {\n  fn Create() -> Self {\n    return {.base = MiddleDerived.Create(), .derived_field = ...};\n  }\n  ...\n}\n")),(0,i.kt)("p",null,"Observe that the vptr is only assigned twice in release builds if you use\npartial facets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The first class value created, by the factory function creating the base of\nthe class hierarchy, initialized the vptr field to nullptr. Every derived\ntype transitively created from that value will leave it alone."),(0,i.kt)("li",{parentName:"ul"},"Only when the value has its most-derived class and is converted from the\npartial facet type to its final type is the vptr field set to its final\nvalue.")),(0,i.kt)("p",null,"In the case that the base class can be instantiated, tooling could optionally\nrecommend that functions returning ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," that are used to initialize a derived\nclass be changed to return ",(0,i.kt)("inlineCode",{parentName:"p"},"partial Self")," instead. However, the consequences of\nreturning ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"partial Self")," when the value will be used to\ninitialize a derived class are fairly minor:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The vptr field will be assigned more than necessary."),(0,i.kt)("li",{parentName:"ul"},"The types won't protect against calling methods on a value while it is being\nconstructed, much like the situation in C++ currently.")),(0,i.kt)("h4",{id:"assignment-with-inheritance"},"Assignment with inheritance"),(0,i.kt)("p",null,"Since the assignment operator method should not be virtual, it is only safe to\nimplement it for final types. However, following the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals#code-that-is-easy-to-read-understand-and-write"},'maxim that Carbon should "focus on encouraging appropriate usage of features rather than restricting misuse"'),",\nwe allow users to also implement assignment on extensible classes, even though\nit can lead to ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object_slicing"},"slicing"),"."),(0,i.kt)("h3",{id:"destructors"},"Destructors"),(0,i.kt)("p",null,"Every non-abstract type is ",(0,i.kt)("em",{parentName:"p"},"destructible"),", meaning has a defined destructor\nfunction called when the lifetime of a value of that type ends, such as when a\nvariable goes out of scope. The destructor for a class may be customized using\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"destructor")," keyword:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class MyClass {\n  destructor [me: Self] { ... }\n}\n")),(0,i.kt)("p",null,"or:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class MyClass {\n  // Can modify `me` in the body.\n  destructor [addr me: Self*] { ... }\n}\n")),(0,i.kt)("p",null,"If a class has no ",(0,i.kt)("inlineCode",{parentName:"p"},"destructor")," declaration, it gets the default destructor,\nwhich is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"destructor [me: Self] { }"),"."),(0,i.kt)("p",null,"The destructor for a class is run before the destructors of its data members.\nThe data members are destroyed in reverse order of declaration. Derived classes\nare destroyed before their base classes, so the order of operations is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"derived class' destructor runs,"),(0,i.kt)("li",{parentName:"ul"},"the data members of the derived class are destroyed, in reverse order of\ndeclaration,"),(0,i.kt)("li",{parentName:"ul"},"the immediate base class' destructor runs,"),(0,i.kt)("li",{parentName:"ul"},"the data members of the immediate base class are destroyed, in reverse order\nof declaration,"),(0,i.kt)("li",{parentName:"ul"},"and so on.")),(0,i.kt)("p",null,"Destructors may be declared in class scope and then defined out-of-line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class MyClass {\n  destructor [addr me: Self*];\n}\ndestructor MyClass [addr me: Self*] { ... }\n")),(0,i.kt)("p",null,"It is illegal to delete an instance of a derived class through a pointer to one\nof its base classes unless it has a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_function#Virtual_destructors"},"virtual destructor"),".\nAn abstract or base class' destructor may be declared virtual using the\n",(0,i.kt)("inlineCode",{parentName:"p"},"virtual")," introducer, in which case any derived class destructor declaration\nmust be ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"base class MyBaseClass {\n  virtual destructor [addr me: Self*] { ... }\n}\n\nclass MyDerivedClass extends MyBaseClass {\n  impl destructor [addr me: Self*] { ... }\n}\n")),(0,i.kt)("p",null,"The properties of a type, whether type is abstract, base, or final, and whether\nthe destructor is virtual or non-virtual, determines which\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology#type-of-type"},"type-of-types")," it satisfies."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Non-abstract classes are ",(0,i.kt)("inlineCode",{parentName:"li"},"Concrete"),". This means you can create local and\nmember variables of this type. ",(0,i.kt)("inlineCode",{parentName:"li"},"Concrete")," types have destructors that are\ncalled when the local variable goes out of scope or the containing object of\nthe member variable is destroyed."),(0,i.kt)("li",{parentName:"ul"},"Final classes and classes with a virtual destructor are ",(0,i.kt)("inlineCode",{parentName:"li"},"Deletable"),". These\nmay be safely deleted through a pointer."),(0,i.kt)("li",{parentName:"ul"},"Classes that are ",(0,i.kt)("inlineCode",{parentName:"li"},"Concrete"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Deletable"),", or both are ",(0,i.kt)("inlineCode",{parentName:"li"},"Destructible"),". These\nare types that may be deleted through a pointer, but it might not be safe.\nThe concerning situation is when you have a pointer to a base class without\na virtual destructor. It is unsafe to delete that pointer when it is\nactually pointing to a derived class.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," The names ",(0,i.kt)("inlineCode",{parentName:"p"},"Deletable")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Destructible")," are\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#type-of-type-naming"},(0,i.kt)("strong",{parentName:"a"},"placeholders"))," since they do not\nconform to the decision on\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/1058"},'question-for-leads issue #1058: "How should interfaces for core functionality be named?"'),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Class"),(0,i.kt)("th",{parentName:"tr",align:null},"Destructor"),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"Concrete")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"Deletable")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"Destructible")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"abstract"),(0,i.kt)("td",{parentName:"tr",align:null},"non-virtual"),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},"no")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"abstract"),(0,i.kt)("td",{parentName:"tr",align:null},"virtual"),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},"yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"base"),(0,i.kt)("td",{parentName:"tr",align:null},"non-virtual"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},"yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"base"),(0,i.kt)("td",{parentName:"tr",align:null},"virtual"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},"yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"final"),(0,i.kt)("td",{parentName:"tr",align:null},"any"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},"yes")))),(0,i.kt)("p",null,"The compiler automatically determines which of these\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology#type-of-type"},"type-of-types")," a given type\nsatisfies. It is illegal to directly implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Concrete"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Deletable"),", or\n",(0,i.kt)("inlineCode",{parentName:"p"},"Destructible")," directly. For more about these constraints, see\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#destructor-constraints"},'"destructor constraints" in the detailed generics design'),"."),(0,i.kt)("p",null,"A pointer to ",(0,i.kt)("inlineCode",{parentName:"p"},"Deletable")," types may be passed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Delete")," method of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Allocator")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology#interface"},"interface"),". To\ndeallocate a pointer to a base class without a virtual destructor, which may\nonly be done when it is not actually pointing to a value with a derived type,\ncall the ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsafeDelete")," method instead. Note that you may not call\n",(0,i.kt)("inlineCode",{parentName:"p"},"UnsafeDelete")," on abstract types without virtual destructors, it requires\n",(0,i.kt)("inlineCode",{parentName:"p"},"Destructible"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Allocator {\n  // ...\n  fn Delete[T:! Deletable, addr me: Self*](p: T*);\n  fn UnsafeDelete[T:! Destructible, addr me: Self*](p: T*);\n}\n")),(0,i.kt)("p",null,"To pass a pointer to a base class without a virtual destructor to a generic\nfunction expecting a ",(0,i.kt)("inlineCode",{parentName:"p"},"Deletable")," type, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsafeAllowDelete"),"\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#adapting-types"},"type adapter"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter UnsafeAllowDelete(T:! Concrete) extends T {\n  impl as Deletable {}\n}\n\n// Example usage:\nfn RequiresDeletable[T:! Deletable](p: T*);\nvar x: MyExtensible;\nRequiresDeletable(&x as UnsafeAllowDelete(MyExtensible)*);\n")),(0,i.kt)("p",null,"If a virtual method is transitively called from inside a destructor, the\nimplementation from the current class is used, not any overrides from derived\nclasses. It will abort the execution of the program if that method is abstract\nand not implemented in the current class."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," Allow or require destructors to be declared as taking\n",(0,i.kt)("inlineCode",{parentName:"p"},"partial Self")," in order to prove no use of virtual methods."),(0,i.kt)("p",null,"Types satisfy the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#destructor-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"TrivialDestructor")),"\ntype-of-type if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the class declaration does not define a destructor or the class defines the\ndestructor with an empty body ",(0,i.kt)("inlineCode",{parentName:"li"},"{ }"),","),(0,i.kt)("li",{parentName:"ul"},"all data members implement ",(0,i.kt)("inlineCode",{parentName:"li"},"TrivialDestructor"),", and"),(0,i.kt)("li",{parentName:"ul"},"all base classes implement ",(0,i.kt)("inlineCode",{parentName:"li"},"TrivialDestructor"),".")),(0,i.kt)("p",null,"For example, a ",(0,i.kt)("a",{parentName:"p",href:"#struct-types"},"struct type")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"TrivialDestructor")," if\nall its members do."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"TrivialDestructor")," implies that their destructor does nothing, which may be\nused to generate optimized specializations."),(0,i.kt)("p",null,"There is no provision for handling failure in a destructor. All operations that\ncould potentially fail must be performed before the destructor is called.\nUnhandled failure during a destructor call will abort the program."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," Allow or require destructors to be declared as taking\n",(0,i.kt)("inlineCode",{parentName:"p"},"[var me: Self]"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Alternatives considered:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#types-implement-destructor-interface"},"Types implement destructor interface")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#prevent-virtual-function-calls-in-destructors"},"Prevent virtual function calls in destructors")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#allow-functions-to-act-as-destructors"},"Allow functions to act as destructors")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#allow-private-destructors"},"Allow private destructors")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#allow-multiple-conditional-destructors"},"Allow multiple conditional destructors")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#dont-distinguish-safe-and-unsafe-delete-operations"},"Don't distinguish safe and unsafe delete operations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#dont-allow-unsafe-delete"},"Don't allow unsafe delete")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1154.md#allow-final-destructors"},"Allow final destructors"))),(0,i.kt)("h3",{id:"access-control"},"Access control"),(0,i.kt)("p",null,"By default, all members of a class are fully publicly accessible. Access can be\nrestricted by adding a keyword, called an\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Access_modifiers"},"access modifier"),", prior to the\ndeclaration. Access modifiers are how Carbon supports\n",(0,i.kt)("a",{parentName:"p",href:"#encapsulated-types"},"encapsulation"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Access_modifiers"},"access modifier")," is written\nbefore any ",(0,i.kt)("a",{parentName:"p",href:"#virtual-override-keywords"},"virtual override keyword"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Rationale:")," Carbon makes members public by default for a few reasons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The readability of public members is the most important, since we expect\nmost readers to be concerned with the public API of a type."),(0,i.kt)("li",{parentName:"ul"},"The members that are most commonly private are the data fields, which have\nrelatively less complicated definitions that suffer less from the extra\nannotation.")),(0,i.kt)("p",null,"Additionally, there is precedent for this approach in modern object-oriented\nlanguages such as\n",(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/visibility-modifiers.html"},"Kotlin")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.python.org/3/tutorial/classes.html"},"Python"),", both of which are\nwell regarded for their usability."),(0,i.kt)("p",null,"Keywords controlling visibility are attached to individual declarations instead\nof C++'s approach of labels controlling the visibility for all following\ndeclarations to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/principles/low_context_sensitivity"},"reduce context sensitivity"),".\nThis matches\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/visibility-and-privacy.html"},"Rust"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html"},"Swift"),",\n",(0,i.kt)("a",{parentName:"p",href:"http://rosettacode.org/wiki/Classes#Java"},"Java"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers"},"C#"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/visibility-modifiers.html#classes-and-interfaces"},"Kotlin"),",\nand ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.dlang.org/Access_specifiers_and_visibility"},"D"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," Proposal\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/pull/561"},"#561: Basic classes"),"\nincluded the decision that\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0561.md#access-control"},"members default to publicly accessible"),"\noriginally asked in issue\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/665"},"#665"),"."),(0,i.kt)("h4",{id:"private-access"},"Private access"),(0,i.kt)("p",null,"As in C++, ",(0,i.kt)("inlineCode",{parentName:"p"},"private")," means only accessible to members of the class and any\n",(0,i.kt)("a",{parentName:"p",href:"#friends"},"friends"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Point {\n  fn Distance[me: Self]() -> f32;\n  // These are only accessible to members of `Point`.\n  private var x: f32;\n  private var y: f32;\n}\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"private virtual")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"private abstract")," method may be implemented in derived\nclasses, even though it may not be called. This allows derived classes to\ncustomize the behavior of a function called by a method of the base class, while\nstill preventing the derived class from calling it. This matches the behavior of\nC++ and is more orthogonal."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"private")," will give the member internal linkage unless it needs\nto be external because it is used in an inline method or template. We may in the\nfuture\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0722.md#specifying-linkage-as-part-of-the-access-modifier"},"add a way to specify internal linkage explicitly"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open questions:")," Using ",(0,i.kt)("inlineCode",{parentName:"p"},"private"),' to mean "restricted to this class" matches\nC++. Other languages support restricting to different scopes:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Swift supports "restrict to this module" and "restrict to this file".'),(0,i.kt)("li",{parentName:"ul"},'Rust supports "restrict to this module and any children of this module", as\nwell as "restrict to this crate", "restrict to parent module", and "restrict\nto a specific ancestor module".')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison to other languages:")," C++, Rust, and Swift all make class members\nprivate by default. C++ offers the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," keyword that makes members public by\ndefault."),(0,i.kt)("h4",{id:"protected-access"},"Protected access"),(0,i.kt)("p",null,"Protected members may only be accessed by members of this class, members of\nderived classes, and any ",(0,i.kt)("a",{parentName:"p",href:"#friends"},"friends"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"base class MyBaseClass {\n  protected fn HelperClassFunction(x: i32) -> i32;\n  protected fn HelperMethod[me: Self](x: i32) -> i32;\n  protected var data: i32;\n}\n\nclass MyDerivedClass extends MyBaseClass {\n  fn UsesProtected[addr me: Self*]() {\n    // Can access protected members in derived class\n    var x: i32 = HelperClassFunction(3);\n    me->data = me->HelperMethod(x);\n  }\n}\n")),(0,i.kt)("h4",{id:"friends"},"Friends"),(0,i.kt)("p",null,"Classes may have a ",(0,i.kt)("em",{parentName:"p"},"friend")," declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Buddy { ... }\n\nclass Pal {\n  private var x: i32;\n  friend Buddy;\n}\n")),(0,i.kt)("p",null,"This declares ",(0,i.kt)("inlineCode",{parentName:"p"},"Buddy")," to be a friend of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pal"),", which means that ",(0,i.kt)("inlineCode",{parentName:"p"},"Buddy")," can\naccess all members of this class, even the ones that are declared ",(0,i.kt)("inlineCode",{parentName:"p"},"private")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"protected"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"friend")," keyword is followed by the name of an existing function, type, or\nparameterized family of types. Unlike C++, it won't act as a forward declaration\nof that name. The name must be resolvable by the compiler, and so may not be a\nmember of a template."),(0,i.kt)("h4",{id:"test-friendship"},"Test friendship"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," There should be a convenient way of allowing tests in the same\nlibrary as the class definition to access private members of the class. Ideally\nthis could be done without changing the class definition itself, since it\ndoesn't affect the class' public API."),(0,i.kt)("h4",{id:"access-control-for-construction"},"Access control for construction"),(0,i.kt)("p",null,"A function may construct a class, by casting a struct value to the class type,\nif it has access to (write) all of its fields."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," There should be a way to limit which code can construct a class\neven when it only has public fields. This will be resolved in question-for-leads\nissue ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/803"},"#803"),"."),(0,i.kt)("h3",{id:"operator-overloading"},"Operator overloading"),(0,i.kt)("p",null,"Developers may define how standard Carbon operators, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"/"),", apply\nto custom types by implementing the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology#interface"},"interface")," that corresponds to that operator\nfor the types of the operands. See the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#operator-overloading"},'"operator overloading" section')," of\nthe ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/overview"},"generics design"),". The specific interface used for a\ngiven operator may be found in the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/"},"expressions design"),"."),(0,i.kt)("h2",{id:"future-work"},"Future work"),(0,i.kt)("p",null,"This includes features that need to be designed, questions to answer, and a\ndescription of the provisional syntax in use until these decisions have been\nmade."),(0,i.kt)("h3",{id:"struct-literal-shortcut"},"Struct literal shortcut"),(0,i.kt)("p",null,"We could allow you to write ",(0,i.kt)("inlineCode",{parentName:"p"},"{x, y}")," as a short hand for ",(0,i.kt)("inlineCode",{parentName:"p"},"{.x = x, .y = y}"),"."),(0,i.kt)("h3",{id:"optional-named-parameters"},"Optional named parameters"),(0,i.kt)("p",null,"Structs are being considered as a possible mechanism for implementing optional\nnamed parameters. We have three main candidate approaches: allowing struct types\nto have field defaults, having dedicated support for destructuring struct values\nin pattern contexts, or having a dedicated optional named parameter syntax."),(0,i.kt)("h4",{id:"field-defaults-for-struct-types"},"Field defaults for struct types"),(0,i.kt)("p",null,"If struct types could have field defaults, you could write a function\ndeclaration with all of the optional parameters in an option struct:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn SortIntVector(\n    v: Vector(i32)*,\n    options: {.stable: Bool = false,\n              .descending: Bool = false} = {}) {\n  // Code using `options.stable` and `options.descending`.\n}\n\n// Uses defaults of `.stable` and `.descending` equal to `false`.\nSortIntVector(&v);\nSortIntVector(&v, {});\n// Sets `.stable` option to `true`.\nSortIntVector(&v, {.stable = true});\n// Sets `.descending` option to `true`.\nSortIntVector(&v, {.descending = true});\n// Sets both `.stable` and `.descending` options to `true`.\nSortIntVector(&v, {.stable = true, .descending = true});\n// Order can be different for arguments as well.\nSortIntVector(&v, {.descending = true, .stable = true});\n")),(0,i.kt)("h4",{id:"destructuring-in-pattern-matching"},"Destructuring in pattern matching"),(0,i.kt)("p",null,"We might instead support destructuring struct patterns with defaults:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn SortIntVector(\n    v: Vector(i32)*,\n    {stable: Bool = false, descending: Bool = false}) {\n  // Code using `stable` and `descending`.\n}\n")),(0,i.kt)("p",null,"This would allow the same syntax at the call site, but avoids\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/pull/561#discussion_r683856715"},"some concerns with field defaults"),"\nand allows some other use cases such as destructuring return values."),(0,i.kt)("h4",{id:"discussion"},"Discussion"),(0,i.kt)("p",null,"We might support destructuring directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var {key: String, value: i32} = ReturnKeyValue();\n")),(0,i.kt)("p",null,"or by way of a mechanism that converts a struct into a tuple:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var (key: String, value: i32) =\n    ReturnKeyValue().extract(.key, .value);\n// or maybe:\nvar (key: String, value: i32) =\n    ReturnKeyValue()[(.key, .value)];\n")),(0,i.kt)("p",null,"Similarly we might support optional named parameters directly instead of by way\nof struct types."),(0,i.kt)("p",null,"Some discussion on this topic has occurred in:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/505"},"question-for-leads issue #505 on named parameters")),(0,i.kt)("li",{parentName:"ul"},"labeled params brainstorming docs\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.google.com/document/d/1a1wI8SHGh3HYV8SUWPIKhg48ZW2glUlAMIIS3aec5dY/edit"},"1"),",\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.google.com/document/d/1u6GORSkcgThMAiYKOqsgALcEviEtcghGb5TTVT-U-N0/edit"},"2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.google.com/document/d/1iuytei37LPg_tEd6xe-O6P_bpN7TIbEjNtFMLYW2Nno/edit#heading=h.y566d16ivoy2"},'"match" in syntax choices doc'))),(0,i.kt)("h3",{id:"inheritance-1"},"Inheritance"),(0,i.kt)("h4",{id:"c-abstract-base-classes-interoperating-with-object-safe-interfaces"},"C++ abstract base classes interoperating with object-safe interfaces"),(0,i.kt)("p",null,"We want four things so that Carbon's object-safe interfaces may interoperate\nwith C++ abstract base classes without data members, matching the\n",(0,i.kt)("a",{parentName:"p",href:"#interface-as-base-class"},"interface as base class use case"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Ability to convert an object-safe interface (a type-of-type) into an\nC++-compatible base class (a base type), maybe using\n",(0,i.kt)("inlineCode",{parentName:"li"},"AsBaseClass(MyInterface)"),"."),(0,i.kt)("li",{parentName:"ul"},"Ability to convert a C++ base class without data members (a base type) into\nan object-safe interface (a type-of-type), maybe using ",(0,i.kt)("inlineCode",{parentName:"li"},"AsInterface(MyIBC)"),"."),(0,i.kt)("li",{parentName:"ul"},"Ability to convert a (thin) pointer to an abstract base class to a ",(0,i.kt)("inlineCode",{parentName:"li"},"DynPtr"),"\nof the corresponding interface."),(0,i.kt)("li",{parentName:"ul"},"Ability to convert ",(0,i.kt)("inlineCode",{parentName:"li"},"DynPtr(MyInterface)")," values to a proxy type that extends\nthe corresponding base class ",(0,i.kt)("inlineCode",{parentName:"li"},"AsBaseType(MyInterface)"),".")),(0,i.kt)("p",null,"Note that the proxy type extending ",(0,i.kt)("inlineCode",{parentName:"p"},"AsBaseType(MyInterface)")," would be a\ndifferent type than ",(0,i.kt)("inlineCode",{parentName:"p"},"DynPtr(MyInterface)")," since the receiver input to the\nfunction members of the vtable for the former does not match those in the\nwitness table for the latter."),(0,i.kt)("h4",{id:"overloaded-methods"},"Overloaded methods"),(0,i.kt)("p",null,"We allow a derived class to define a ",(0,i.kt)("a",{parentName:"p",href:"#class-functions"},"class function")," with the\nsame name as a class function in the base class. For example, we expect it to be\npretty common to have a constructor function named ",(0,i.kt)("inlineCode",{parentName:"p"},"Create")," at all levels of the\ntype hierarchy."),(0,i.kt)("p",null,"Beyond that, we may want some rules or restrictions about defining methods in a\nderived class with the same name as a base class method without overriding it.\nThere are some opportunities to improve on and simplify the C++ story:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We don't want to silently hide methods in the base class because of a method\nwith the same name in a derived class. There are uses for this in C++, but\nit also causes problems and without multiple inheritance there isn't the\nsame need in Carbon."),(0,i.kt)("li",{parentName:"ul"},"Overload resolution should happen before virtual dispatch."),(0,i.kt)("li",{parentName:"ul"},"For evolution purposes, you should be able to add private members to a base\nclass that have the same name as member of a derived class without affecting\noverload resolution on instances of the derived class, in functions that\naren't friends of the base class.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," This was discussed in\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/document/d/1QCdKQ33rki-kCDrxi8UHy3a36dtW0WdMqpUzluGSrz4/edit?resourcekey=0-bZmNUiueOiH_sysJNqnT9A#heading=h.40jlsrcgp8mr"},"the open discussion on 2021-07-12"),"."),(0,i.kt)("h4",{id:"interop-with-c-inheritance"},"Interop with C++ inheritance"),(0,i.kt)("p",null,"This design directly supports Carbon classes inheriting from a single C++ class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class CarbonClass extends C++.CPlusPlusClass {\n  fn Create() -> Self {\n    return {.base = C++.CPlusPlusClass(...), .other_fields = ...};\n  }\n  ...\n}\n")),(0,i.kt)("p",null,"To allow C++ classes to extend Carbon classes, there needs to be some way for\nC++ constructors to initialize their base class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There could be some way to export a Carbon class that identifies which\nfactory functions may be used as constructors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We could explicitly call the Carbon factory function, as in:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"// `Base` is a Carbon class which gets converted to a\n// C++ class for interop purposes:\nclass Base {\npublic:\n    virtual ~Base() {}\n    static auto Create() -> Base;\n};\n\n// In C++\nclass Derived : public Base {\npublic:\n    virtual ~Derived() override {}\n    // This isn't currently a case where C++ guarantees no copy,\n    // and so it currently still requires a notional copy and\n    // there appear to be implementation challenges with\n    // removing them. This may require an extension to make work\n    // reliably without an extraneous copy of the base subobject.\n    Derived() : Base(Base::Create()) {}\n};\n")),(0,i.kt)("p",{parentName:"li"},"However, this doesn't work in the case where ",(0,i.kt)("inlineCode",{parentName:"p"},"Base")," can't be instantiated,\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"Base")," does not have a copy constructor, even though it shouldn't be\ncalled due to RVO."))),(0,i.kt)("h5",{id:"virtual-base-classes"},"Virtual base classes"),(0,i.kt)("p",null,"TODO: Ask zygoloid to fill this in."),(0,i.kt)("p",null,"Carbon won't support declaring virtual base classes, and the C++ interop use\ncases Carbon needs to support are limited. This will allow us to simplify the\nC++ interop by allowing Carbon to delegate initialization of virtual base\nclasses to the C++ side."),(0,i.kt)("p",null,"This requires that we enforce two rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"No multiple inheritance of C++ classes with virtual bases"),(0,i.kt)("li",{parentName:"ul"},"No C++ class extending a Carbon class that extends a C++ class with a\nvirtual base")),(0,i.kt)("h3",{id:"mixins-1"},"Mixins"),(0,i.kt)("p",null,"We will need some way to declare mixins. This syntax will need a way to\ndistinguish defining versus requiring member variables. Methods may additionally\nbe given a default definition but may be overridden. Interface implementations\nmay only be partially provided by a mixin. Mixin methods will need to be able to\nconvert between pointers to the mixin type and the main type."),(0,i.kt)("p",null,"Open questions include whether a mixin is its own type that is a member of the\ncontaining type, and whether mixins are templated on the containing type. Mixins\nalso complicate how constructors work."),(0,i.kt)("h3",{id:"memory-layout"},"Memory layout"),(0,i.kt)("p",null,"Carbon will need some way for users to specify the memory layout of class types\nbeyond simple ordering of fields, such as controlling the packing and alignment\nfor the whole type or individual members."),(0,i.kt)("p",null,"We may allow members of a derived class like to put data members in the final\npadding of its base class prefix. Tail-padding reuse has both advantages and\ndisadvantages, so we may have some way for a class to explicitly mark that its\ntail padding is available for use by a derived class,"),(0,i.kt)("p",null,"Advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Tail-padding reuse is sometimes a nice layout optimization (eg, in Clang we\nsave 8 bytes per ",(0,i.kt)("inlineCode",{parentName:"li"},"Expr")," by reusing tail padding)."),(0,i.kt)("li",{parentName:"ul"},"No class size regressions when migrating from C++."),(0,i.kt)("li",{parentName:"ul"},"Special case of reusing the tail padding of a class that is empty other than\nits tail padding is very important, to the extent that we will likely need\nto support either zero-sized types or tail-padding reuse in order to have\nacceptable class layouts.")),(0,i.kt)("p",null,"Disadvantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Cannot use ",(0,i.kt)("inlineCode",{parentName:"li"},"memcpy(p, q, sizeof(Base))")," to copy around base class subobjects\nif the destination is an in-lifetime, because they might overlap other\nobjects' representations."),(0,i.kt)("li",{parentName:"ul"},"Somewhat more complex model."),(0,i.kt)("li",{parentName:"ul"},'We need some mechanism for disabling tail-padding reuse in "standard layout"\ntypes.'),(0,i.kt)("li",{parentName:"ul"},"We may also have to use narrowed loads for the last member of a base class\nto avoid accidentally creating a race condition.")),(0,i.kt)("p",null,"However, we can still use ",(0,i.kt)("inlineCode",{parentName:"p"},"memcpy")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"memset")," to initialize a base class\nsubobject, even if its tail padding might be reused, so long as we guarantee\nthat no other object lives in the tail padding and is initialized before the\nbase class. In C++, that happens only due to virtual base classes getting\ninitialized early and laid out at the end of the object; if we disallow virtual\nbase classes then we can guarantee that initialization order is address order,\nremoving most of the downside of tail-padding reuse."),(0,i.kt)("h3",{id:"no-static-variables"},"No ",(0,i.kt)("inlineCode",{parentName:"h3"},"static")," variables"),(0,i.kt)("p",null,"At the moment, there is no proposal to support\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Class_variable#Static_member_variables_and_static_member_functions"},(0,i.kt)("inlineCode",{parentName:"a"},"static")," member variables"),",\nin line with avoiding global variables more generally. Carbon may need some\nsupport in this area, though, for parity with and migration from C++."),(0,i.kt)("h3",{id:"computed-properties"},"Computed properties"),(0,i.kt)("p",null,"Carbon might want to support members of a type that are accessed like a data\nmember but return a computed value like a function. This has a number of\nimplications:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It would be a way of publicly exposing data members for\n",(0,i.kt)("a",{parentName:"li",href:"#encapsulated-types"},"encapsulated types"),", allowing for rules that otherwise\nforbid mixing public and private data members."),(0,i.kt)("li",{parentName:"ul"},"It would provide a more graceful evolution path from a\n",(0,i.kt)("a",{parentName:"li",href:"#data-classes"},"data class")," to an ",(0,i.kt)("a",{parentName:"li",href:"#encapsulated-types"},"encapsulated type"),"."),(0,i.kt)("li",{parentName:"ul"},"It would give an option to start with a ",(0,i.kt)("a",{parentName:"li",href:"#data-classes"},"data class")," instead\nof writing all the boilerplate to create an\n",(0,i.kt)("a",{parentName:"li",href:"#encapsulated-types"},"encapsulated type")," preemptively to allow future\nevolution."),(0,i.kt)("li",{parentName:"ul"},"It would let you take a variable away and put a property in its place with\nno other code changes. The number one use for this is so you can put a\nbreakpoint in the property code, then later go back to public variable once\nyou understand who was misbehaving."),(0,i.kt)("li",{parentName:"ul"},"We should have some guidance for when to use a computed property instead of\na function with no arguments. One possible criteria is when it is a pure\nfunction of the state of the object and executes in an amount of time\nsimilar to ordinary member access.")),(0,i.kt)("p",null,'However, there are likely to be differences between computed properties and\nother data members, such as the ability to take the address of them. We might\nwant to support "read only" data members, that can be read through the public\napi but only modified with private access, for data members which may need to\nevolve into a computed property. There are also questions regarding how to\nsupport assigning or modifying computed properties, such as using ',(0,i.kt)("inlineCode",{parentName:"p"},"+="),"."),(0,i.kt)("h3",{id:"interfaces-implemented-for-data-classes"},"Interfaces implemented for data classes"),(0,i.kt)("p",null,"We should define a way for defining implementations of interfaces for struct\ntypes. To satisfy coherence, these implementations would have to be defined in\nthe library with the interface definition. The syntax might look like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface ConstructWidgetFrom {\n  fn Construct(Self) -> Widget;\n}\n\nexternal impl {.kind: WidgetKind, .size: i32}\n    as ConstructWidgetFrom { ... }\n")),(0,i.kt)("p",null,"In addition, we should define a way for interfaces to define templated blanket\nimplementations for ",(0,i.kt)("a",{parentName:"p",href:"#data-classes"},"data classes")," more generally. These\nimplementations will typically subject to the criteria that all the data fields\nof the type must implement the interface. An example use case would be to say\nthat a data class is serializable if all of its fields were. For this we will\nneed a type-of-type for capturing that criteria, maybe something like\n",(0,i.kt)("inlineCode",{parentName:"p"},"DataFieldsImplement(MyInterface)"),". The templated implementation will need some\nway of iterating through the fields so it can perform operations fieldwise. This\nfeature should also implement the interfaces for any tuples whose fields satisfy\nthe criteria."),(0,i.kt)("p",null,"It is an open question how to define implementations for binary operators. For\nexample, if ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," is comparable to ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"{.x = 3, .y = 2.72}")," should be\ncomparable to ",(0,i.kt)("inlineCode",{parentName:"p"},"{.x = 3.14, .y = 2}"),'. The trick is how to declare the criteria\nthat "',(0,i.kt)("inlineCode",{parentName:"p"},"T")," is comparable to ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," if they have the same field names in the same\norder, and for every field ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"T.x")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"ComparableTo")," for\nthe type of ",(0,i.kt)("inlineCode",{parentName:"p"},"U.x"),'."'),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/257"},"#257: Initialization of memory and variables")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/561"},"#561: Basic classes: use cases, struct literals, struct types, and future wor")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/722"},"#722: Nominal classes and methods")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/777"},"#777: Inheritance")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/981"},"#981: Implicit conversions for aggregates")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1154"},"#1154: Destructors"))))}c.isMDXComponent=!0}}]);