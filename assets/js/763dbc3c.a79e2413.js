"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6061],{3905:(e,a,n)=>{n.d(a,{Zo:()=>m,kt:()=>u});var t=n(7294);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},m=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,k=d["".concat(s,".").concat(u)]||d[u]||c[u]||r;return n?t.createElement(k,l(l({ref:a},m),{},{components:n})):t.createElement(k,l({ref:a},m))}));function u(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7935:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var t=n(7462),i=(n(7294),n(3905));const r={},l="Language design",o={unversionedId:"docs/design/README",id:"docs/design/README",title:"Language design",description:"\x3c!--",source:"@site/../docs/design/README.md",sourceDirName:"docs/design",slug:"/docs/design/",permalink:"/docs/design/",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/design/README.md",tags:[],version:"current",frontMatter:{},sidebar:"design",next:{title:"Aliases",permalink:"/docs/design/aliases"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"This document is provisional",id:"this-document-is-provisional",level:3},{value:"Hello, Carbon",id:"hello-carbon",level:2},{value:"Code and comments",id:"code-and-comments",level:2},{value:"Build modes",id:"build-modes",level:2},{value:"Types are values",id:"types-are-values",level:2},{value:"Primitive types",id:"primitive-types",level:2},{value:"<code>bool</code>",id:"bool",level:3},{value:"Integer types",id:"integer-types",level:3},{value:"Integer literals",id:"integer-literals",level:4},{value:"Floating-point types",id:"floating-point-types",level:3},{value:"Floating-point literals",id:"floating-point-literals",level:4},{value:"String types",id:"string-types",level:3},{value:"String literals",id:"string-literals",level:4},{value:"Value categories and value phases",id:"value-categories-and-value-phases",level:2},{value:"Composite types",id:"composite-types",level:2},{value:"Tuples",id:"tuples",level:3},{value:"Struct types",id:"struct-types",level:3},{value:"Pointer types",id:"pointer-types",level:3},{value:"Arrays and slices",id:"arrays-and-slices",level:3},{value:"Expressions",id:"expressions",level:2},{value:"Declarations, Definitions, and Scopes",id:"declarations-definitions-and-scopes",level:2},{value:"Patterns",id:"patterns",level:2},{value:"Binding patterns",id:"binding-patterns",level:3},{value:"Destructuring patterns",id:"destructuring-patterns",level:3},{value:"Refutable patterns",id:"refutable-patterns",level:3},{value:"Name-binding declarations",id:"name-binding-declarations",level:2},{value:"Constant <code>let</code> declarations",id:"constant-let-declarations",level:3},{value:"Variable <code>var</code> declarations",id:"variable-var-declarations",level:3},{value:"<code>auto</code>",id:"auto",level:3},{value:"Functions",id:"functions",level:2},{value:"Parameters",id:"parameters",level:3},{value:"<code>auto</code> return type",id:"auto-return-type",level:3},{value:"Blocks and statements",id:"blocks-and-statements",level:3},{value:"Assignment statements",id:"assignment-statements",level:3},{value:"Control flow",id:"control-flow",level:3},{value:"<code>if</code> and <code>else</code>",id:"if-and-else",level:4},{value:"Loops",id:"loops",level:4},{value:"<code>while</code>",id:"while",level:5},{value:"<code>for</code>",id:"for",level:5},{value:"<code>break</code>",id:"break",level:5},{value:"<code>continue</code>",id:"continue",level:5},{value:"<code>return</code>",id:"return",level:4},{value:"<code>returned var</code>",id:"returned-var",level:5},{value:"<code>match</code>",id:"match",level:4},{value:"User-defined types",id:"user-defined-types",level:2},{value:"Classes",id:"classes",level:3},{value:"Assignment",id:"assignment",level:4},{value:"Class functions and factory functions",id:"class-functions-and-factory-functions",level:4},{value:"Methods",id:"methods",level:4},{value:"Inheritance",id:"inheritance",level:4},{value:"Access control",id:"access-control",level:4},{value:"Destructors",id:"destructors",level:4},{value:"<code>const</code>",id:"const",level:4},{value:"Unformed state",id:"unformed-state",level:4},{value:"Move",id:"move",level:4},{value:"Mixins",id:"mixins",level:4},{value:"Choice types",id:"choice-types",level:3},{value:"Names",id:"names",level:2},{value:"Files, libraries, packages",id:"files-libraries-packages",level:3},{value:"Package declaration",id:"package-declaration",level:3},{value:"Imports",id:"imports",level:3},{value:"Name visibility",id:"name-visibility",level:3},{value:"Package scope",id:"package-scope",level:3},{value:"Namespaces",id:"namespaces",level:3},{value:"Naming conventions",id:"naming-conventions",level:3},{value:"Aliases",id:"aliases",level:3},{value:"Name lookup",id:"name-lookup",level:3},{value:"Name lookup for common types",id:"name-lookup-for-common-types",level:4},{value:"Generics",id:"generics",level:2},{value:"Checked and template parameters",id:"checked-and-template-parameters",level:3},{value:"Interfaces and implementations",id:"interfaces-and-implementations",level:3},{value:"Combining constraints",id:"combining-constraints",level:3},{value:"Associated types",id:"associated-types",level:3},{value:"Generic entities",id:"generic-entities",level:3},{value:"Generic Classes",id:"generic-classes",level:4},{value:"Generic choice types",id:"generic-choice-types",level:4},{value:"Generic interfaces",id:"generic-interfaces",level:4},{value:"Generic implementations",id:"generic-implementations",level:4},{value:"Other features",id:"other-features",level:3},{value:"Generic type equality and <code>observe</code> declarations",id:"generic-type-equality-and-observe-declarations",level:3},{value:"Operator overloading",id:"operator-overloading",level:3},{value:"Common type",id:"common-type",level:4},{value:"Bidirectional interoperability with C and C++",id:"bidirectional-interoperability-with-c-and-c",level:2},{value:"Goals",id:"goals",level:3},{value:"Non-goals",id:"non-goals",level:3},{value:"Importing and <code>#include</code>",id:"importing-and-include",level:3},{value:"ABI and dynamic linking",id:"abi-and-dynamic-linking",level:3},{value:"Operator overloading",id:"operator-overloading-1",level:3},{value:"Templates",id:"templates",level:3},{value:"Standard types",id:"standard-types",level:3},{value:"Inheritance",id:"inheritance-1",level:3},{value:"Enums",id:"enums",level:3},{value:"Unfinished tales",id:"unfinished-tales",level:2},{value:"Safety",id:"safety",level:3},{value:"Lifetime and move semantics",id:"lifetime-and-move-semantics",level:3},{value:"Metaprogramming",id:"metaprogramming",level:3},{value:"Pattern matching as function overload resolution",id:"pattern-matching-as-function-overload-resolution",level:3},{value:"Error handling",id:"error-handling",level:3},{value:"Execution abstractions",id:"execution-abstractions",level:3},{value:"Abstract machine and execution model",id:"abstract-machine-and-execution-model",level:4},{value:"Lambdas",id:"lambdas",level:4},{value:"Co-routines",id:"co-routines",level:4},{value:"Concurrency",id:"concurrency",level:4}],m={toc:p};function c(e){let{components:a,...n}=e;return(0,i.kt)("wrapper",(0,t.Z)({},m,n,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"language-design"},"Language design"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"This documentation describes the design of the Carbon language, and the\nrationale for that design. This documentation is an overview of the Carbon\nproject in its current state, written for the builders of Carbon and for those\ninterested in learning more about Carbon."),(0,i.kt)("p",null,"This document is ",(0,i.kt)("em",{parentName:"p"},"not")," a complete programming manual, and, nor does it provide\ndetailed and comprehensive justification for design decisions. These\ndescriptions are found in linked dedicated designs."),(0,i.kt)("h3",{id:"this-document-is-provisional"},"This document is provisional"),(0,i.kt)("p",null,"This document includes much that is provisional or placeholder. This means that\nthe syntax used, language rules, standard library, and other aspects of the\ndesign have things that have not been decided through the Carbon process. This\npreliminary material fills in gaps until aspects of the design can be filled in."),(0,i.kt)("h2",{id:"hello-carbon"},"Hello, Carbon"),(0,i.kt)("p",null,"Here is a simple function showing some Carbon code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'import Console;\n\n// Prints the Fibonacci numbers less than `limit`.\nfn Fibonacci(limit: i64) {\n  var (a: i64, b: i64) = (0, 1);\n  while (a < limit) {\n    Console.Print(a, " ");\n    let next: i64 = a + b;\n    a = b;\n    b = next;\n  }\n  Console.Print("\\n");\n}\n')),(0,i.kt)("p",null,"Carbon is a language that should feel familiar to C++ and C developers. This\nexample has familiar constructs like ",(0,i.kt)("a",{parentName:"p",href:"#imports"},"imports"),",\n",(0,i.kt)("a",{parentName:"p",href:"#functions"},"function definitions"),", ",(0,i.kt)("a",{parentName:"p",href:"#binding-patterns"},"typed arguments"),", and\n",(0,i.kt)("a",{parentName:"p",href:"#blocks-and-statements"},"curly braces"),"."),(0,i.kt)("p",null,"A few other features that are unlike C or C++ may stand out. First,\n",(0,i.kt)("a",{parentName:"p",href:"#declarations-definitions-and-scopes"},"declarations")," start with introducer\nkeywords. ",(0,i.kt)("inlineCode",{parentName:"p"},"fn")," introduces a function declaration, and ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," introduces a\n",(0,i.kt)("a",{parentName:"p",href:"#variable-var-declarations"},"variable declaration"),". You can also see a\n",(0,i.kt)("a",{parentName:"p",href:"#tuples"},(0,i.kt)("em",{parentName:"a"},"tuple")),", a composite type written as a comma-separated list inside\nparentheses. Unlike, say, Python, these types are strongly-typed as well."),(0,i.kt)("h2",{id:"code-and-comments"},"Code and comments"),(0,i.kt)("p",null,"All source code is UTF-8 encoded text. Comments, identifiers, and strings are\nallowed to have non-ASCII characters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'var r\xe9sultat: String = "Succ\xe8s";\n')),(0,i.kt)("p",null,"Comments start with two slashes ",(0,i.kt)("inlineCode",{parentName:"p"},"//")," and go to the end of the line. They are\nrequired to be the only non-whitespace on the line."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"// Compute an approximation of \u03c0\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/code_and_name_organization/source_files"},"Source files")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"lexical_conventions"},"lexical conventions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/142"},"#142: Unicode source files")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/198"},"#198: Comments")))),(0,i.kt)("h2",{id:"build-modes"},"Build modes"),(0,i.kt)("p",null,"The behavior of the Carbon compiler depends on the ",(0,i.kt)("em",{parentName:"p"},"build mode"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In a ",(0,i.kt)("em",{parentName:"li"},"development build"),", the priority is diagnosing problems and fast build\ntime."),(0,i.kt)("li",{parentName:"ul"},"In a ",(0,i.kt)("em",{parentName:"li"},"performance build"),", the priority is fastest execution time and lowest\nmemory usage."),(0,i.kt)("li",{parentName:"ul"},"In a ",(0,i.kt)("em",{parentName:"li"},"hardened build"),", the first priority is safety and second is\nperformance.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/project/principles/safety_strategy"},"Safety strategy"))),(0,i.kt)("h2",{id:"types-are-values"},"Types are values"),(0,i.kt)("p",null,"Expressions compute values in Carbon, and these values are always strongly typed\nmuch like in C++. However, an important difference from C++ is that types are\nthemselves modeled as values; specifically, compile-time constant values. This\nmeans that the grammar for writing a type is the ",(0,i.kt)("a",{parentName:"p",href:"#expressions"},"expression"),"\ngrammar. Expressions written where a type is expected must be able to be\nevaluated at compile-time and must evaluate to a type value."),(0,i.kt)("h2",{id:"primitive-types"},"Primitive types"),(0,i.kt)("p",null,"Primitive types fall into the following categories:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the boolean type ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),","),(0,i.kt)("li",{parentName:"ul"},"signed and unsigned integer types,"),(0,i.kt)("li",{parentName:"ul"},"IEEE-754 floating-point types, and"),(0,i.kt)("li",{parentName:"ul"},"string types.")),(0,i.kt)("p",null,"These are made available through the ",(0,i.kt)("a",{parentName:"p",href:"#name-lookup-for-common-types"},"prelude"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/primitive_types"},"Primitive types"))),(0,i.kt)("h3",{id:"bool"},(0,i.kt)("inlineCode",{parentName:"h3"},"bool")),(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," is a boolean type with two possible values: ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),".\n",(0,i.kt)("a",{parentName:"p",href:"#expressions"},"Comparison expressions")," produce ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," values. The condition\narguments in ",(0,i.kt)("a",{parentName:"p",href:"#control-flow"},"control-flow statements"),", like ",(0,i.kt)("a",{parentName:"p",href:"#if-and-else"},(0,i.kt)("inlineCode",{parentName:"a"},"if")),"\nand ",(0,i.kt)("a",{parentName:"p",href:"#while"},(0,i.kt)("inlineCode",{parentName:"a"},"while")),", and\n",(0,i.kt)("a",{parentName:"p",href:"#expressions"},(0,i.kt)("inlineCode",{parentName:"a"},"if"),"-",(0,i.kt)("inlineCode",{parentName:"a"},"then"),"-",(0,i.kt)("inlineCode",{parentName:"a"},"else")," conditional expressions")," take ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," values."),(0,i.kt)("h3",{id:"integer-types"},"Integer types"),(0,i.kt)("p",null,"The signed-integer type with bit width ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," may be written ",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.Int(N)"),". For\nconvenience and brevity, the common power-of-two sizes may be written with an\n",(0,i.kt)("inlineCode",{parentName:"p"},"i")," followed by the size: ",(0,i.kt)("inlineCode",{parentName:"p"},"i8"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"i16"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"i64"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"i128"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"i256"),".\nSigned-integer\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/arithmetic#overflow-and-other-error-conditions"},"overflow")," is a\nprogramming error:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In a development build, overflow will be caught immediately when it happens\nat runtime."),(0,i.kt)("li",{parentName:"ul"},"In a performance build, the optimizer can assume that such conditions don't\noccur. As a consequence, if they do, the behavior of the program is not\ndefined."),(0,i.kt)("li",{parentName:"ul"},"In a hardened build, overflow does not result in undefined behavior.\nInstead, either the program will be aborted, or the arithmetic will evaluate\nto a mathematically incorrect result, such as a two's complement result or\nzero.")),(0,i.kt)("p",null,"The unsigned-integer types are: ",(0,i.kt)("inlineCode",{parentName:"p"},"u8"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"u16"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"u32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"u64"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"u128"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"u256"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.UInt(N)"),". Unsigned integer types wrap around on overflow, we strongly\nadvise that they are not used except when those semantics are desired. These\ntypes are intended for bit manipulation or modular arithmetic as often found in\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hash_function"},"hashing"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cryptography"},"cryptography"),", and\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pseudorandom_number_generator"},"PRNG")," use cases.\nValues which can never be negative, like sizes, but for which wrapping does not\nmake sense\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1083.md#dont-let-unsigned-arithmetic-wrap"},"should use signed integer types"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/543"},"#543: pick names for fixed-size integer types")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/820"},"#820: Implicit conversions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1083"},"#1083: Arithmetic expressions")))),(0,i.kt)("h4",{id:"integer-literals"},"Integer literals"),(0,i.kt)("p",null,"Integers may be written in decimal, hexadecimal, or binary:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"12345")," (decimal)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0x1FE")," (hexadecimal)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0b1010")," (binary)")),(0,i.kt)("p",null,"Underscores ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," may be used as digit separators, but for decimal and hexadecimal\nliterals, they can only appear in conventional locations. Numeric literals are\ncase-sensitive: ",(0,i.kt)("inlineCode",{parentName:"p"},"0x"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"0b")," must be lowercase, whereas hexadecimal digits must be\nuppercase. Integer literals never contain a ",(0,i.kt)("inlineCode",{parentName:"p"},"."),"."),(0,i.kt)("p",null,"Unlike in C++, literals do not have a suffix to indicate their type. Instead,\nnumeric literals have a type derived from their value, and can be\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicitly converted")," to any type that can\nrepresent that value."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/lexical_conventions/numeric_literals#integer-literals"},"Integer literals")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/143"},"#143: Numeric literals")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/144"},"#144: Numeric literal semantics")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/820"},"#820: Implicit conversions")))),(0,i.kt)("h3",{id:"floating-point-types"},"Floating-point types"),(0,i.kt)("p",null,"Floating-point types in Carbon have IEEE 754 semantics, use the round-to-nearest\nrounding mode, and do not set any floating-point exception state. They are named\nwith an ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and the number of bits: ",(0,i.kt)("inlineCode",{parentName:"p"},"f16"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"f128"),".\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/primitive_types#bfloat16"},(0,i.kt)("inlineCode",{parentName:"a"},"BFloat16"))," is also provided."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/543"},"#543: pick names for fixed-size integer types")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/820"},"#820: Implicit conversions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1083"},"#1083: Arithmetic expressions")))),(0,i.kt)("h4",{id:"floating-point-literals"},"Floating-point literals"),(0,i.kt)("p",null,"Floating-point types along with ",(0,i.kt)("a",{parentName:"p",href:"#user-defined-types"},"user-defined types")," may\ninitialized from ",(0,i.kt)("em",{parentName:"p"},"real-number literals"),". Decimal and hexadecimal real-number\nliterals are supported:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"123.456")," (digits on both sides of the ",(0,i.kt)("inlineCode",{parentName:"li"},"."),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"123.456e789")," (optional ",(0,i.kt)("inlineCode",{parentName:"li"},"+")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"-")," after the ",(0,i.kt)("inlineCode",{parentName:"li"},"e"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0x1.Ap123")," (optional ",(0,i.kt)("inlineCode",{parentName:"li"},"+")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"-")," after the ",(0,i.kt)("inlineCode",{parentName:"li"},"p"),")")),(0,i.kt)("p",null,"Real-number literals always have a period (",(0,i.kt)("inlineCode",{parentName:"p"},"."),") and a digit on each side of the\nperiod. When a real-number literal is interpreted as a value of a floating-point\ntype, its value is the representable real number closest to the value of the\nliteral. In the case of a tie, the nearest value whose mantissa is even is\nselected."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/lexical_conventions/numeric_literals#real-number-literals"},"Real-number literals")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/143"},"#143: Numeric literals")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/144"},"#144: Numeric literal semantics")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/820"},"#820: Implicit conversions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/866"},"#866: Allow ties in floating literals")))),(0,i.kt)("h3",{id:"string-types"},"String types"),(0,i.kt)("p",null,"There are two string types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String")," - a byte sequence treated as containing UTF-8 encoded text."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"StringView")," - a read-only reference to a byte sequence treated as\ncontaining UTF-8 encoded text.")),(0,i.kt)("h4",{id:"string-literals"},"String literals"),(0,i.kt)("p",null,"String literals may be written on a single line using a double quotation mark\n(",(0,i.kt)("inlineCode",{parentName:"p"},'"'),") at the beginning and end of the string, as in ",(0,i.kt)("inlineCode",{parentName:"p"},'"example"'),"."),(0,i.kt)("p",null,"Multi-line string literals, called ",(0,i.kt)("em",{parentName:"p"},"block string literals"),", begin and end with\nthree double quotation marks (",(0,i.kt)("inlineCode",{parentName:"p"},'"""'),"), and may have a file type indicator after\nthe first ",(0,i.kt)("inlineCode",{parentName:"p"},'"""'),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// Block string literal:\nvar block: String = """\n    The winds grow high; so do your stomachs, lords.\n    How irksome is this music to my heart!\n    When such strings jar, what hope of harmony?\n    I pray, my lords, let me compound this strife.\n        -- History of Henry VI, Part II, Act II, Scene 1, W. Shakespeare\n    """;\n')),(0,i.kt)("p",null,"The indentation of a block string literal's terminating line is removed from all\npreceding lines."),(0,i.kt)("p",null,"Strings may contain\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/lexical_conventions/string_literals#escape-sequences"},"escape sequences"),"\nintroduced with a backslash (",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),").\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/lexical_conventions/string_literals#raw-string-literals"},"Raw string literals"),"\nare available for representing strings with ",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),"s and ",(0,i.kt)("inlineCode",{parentName:"p"},'"'),"s."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/lexical_conventions/string_literals"},"String literals")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/199"},"#199: String literals")))),(0,i.kt)("h2",{id:"value-categories-and-value-phases"},"Value categories and value phases"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"FIXME:")," Should this be moved together with\n",(0,i.kt)("a",{parentName:"p",href:"#types-are-values"},"Types are values"),"?"),(0,i.kt)("p",null,"Every value has a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue"},"value category"),",\nsimilar to ",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/value_category"},"C++"),",\nthat is either ",(0,i.kt)("em",{parentName:"p"},"l-value")," or ",(0,i.kt)("em",{parentName:"p"},"r-value"),". Carbon will automatically convert an\nl-value to an r-value, but not in the other direction."),(0,i.kt)("p",null,"L-values have storage and a stable address. They may be modified, assuming their\ntype is not ",(0,i.kt)("a",{parentName:"p",href:"#const"},(0,i.kt)("inlineCode",{parentName:"a"},"const")),"."),(0,i.kt)("p",null,"R-values may not have dedicated storage. This means they cannot be modified and\ntheir address generally cannot be taken. R-values are broken down into three\nkinds, called ",(0,i.kt)("em",{parentName:"p"},"value phases"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("em",{parentName:"li"},"constant")," has a value known at compile time, and that value is available\nduring type checking, for example to use as the size of an array. These\ninclude literals (",(0,i.kt)("a",{parentName:"li",href:"#integer-literals"},"integer"),",\n",(0,i.kt)("a",{parentName:"li",href:"#floating-point-literals"},"floating-point"),", ",(0,i.kt)("a",{parentName:"li",href:"#string-literals"},"string"),"),\nconcrete type values (like ",(0,i.kt)("inlineCode",{parentName:"li"},"f64")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"Optional(i32*)"),"), expressions in terms\nof constants, and values of\n",(0,i.kt)("a",{parentName:"li",href:"#checked-and-template-parameters"},(0,i.kt)("inlineCode",{parentName:"a"},"template")," parameters"),"."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("em",{parentName:"li"},"symbolic value")," has a value that will be known at the code generation\nstage of compilation when\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Monomorphization"},"monomorphization")," happens,\nbut is not known during type checking. This includes\n",(0,i.kt)("a",{parentName:"li",href:"#checked-and-template-parameters"},"checked-generic parameters"),", and type\nexpressions with checked-generic arguments, like ",(0,i.kt)("inlineCode",{parentName:"li"},"Optional(T*)"),"."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("em",{parentName:"li"},"runtime value")," has a dynamic value only known at runtime.")),(0,i.kt)("p",null,"Carbon will automatically convert a constant to a symbolic value, or any value\nto a runtime value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mermaid"},"graph TD;\n    A(constant)--\x3eB(symbolic value)--\x3eC(runtime value);\n    D(l-value)--\x3eC;\n")),(0,i.kt)("p",null,"Constants convert to symbolic values and to runtime values. Symbolic values will\ngenerally convert into runtime values if an operation that inspects the value is\nperformed on them. Runtime values will convert into constants or to symbolic\nvalues if constant evaluation of the runtime expression succeeds."),(0,i.kt)("h2",{id:"composite-types"},"Composite types"),(0,i.kt)("h3",{id:"tuples"},"Tuples"),(0,i.kt)("p",null,"A tuple is a fixed-size collection of values that can have different types,\nwhere each value is identified by its position in the tuple. An example use of\ntuples is to return multiple values from a function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn DoubleBoth(x: i32, y: i32) -> (i32, i32) {\n  return (2 * x, 2 * y);\n}\n")),(0,i.kt)("p",null,"Breaking this example apart:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The return type is a tuple of two ",(0,i.kt)("inlineCode",{parentName:"li"},"i32")," types."),(0,i.kt)("li",{parentName:"ul"},"The expression uses tuple syntax to build a tuple of two ",(0,i.kt)("inlineCode",{parentName:"li"},"i32")," values.")),(0,i.kt)("p",null,"Both of these are expressions using the tuple syntax\n",(0,i.kt)("inlineCode",{parentName:"p"},"(<expression>, <expression>)"),". The only difference is the type of the tuple\nexpression: one is a tuple of types, the other a tuple of values. In other\nwords, a tuple type is a tuple ",(0,i.kt)("em",{parentName:"p"},"of")," types."),(0,i.kt)("p",null,"The components of a tuple are accessed positionally, so element access uses\nsubscript syntax, but the index must be a compile-time constant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn DoubleTuple(x: (i32, i32)) -> (i32, i32) {\n  return (2 * x[0], 2 * x[1]);\n}\n")),(0,i.kt)("p",null,"Tuple types are\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Structural_type_system"},"structural"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/tuples"},"Tuples"))),(0,i.kt)("h3",{id:"struct-types"},"Struct types"),(0,i.kt)("p",null,"Carbon also has\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Structural_type_system"},"structural types")," whose\nmembers are identified by name instead of position. These are called ",(0,i.kt)("em",{parentName:"p"},"structural\ndata classes"),", also known as a ",(0,i.kt)("em",{parentName:"p"},"struct types")," or ",(0,i.kt)("em",{parentName:"p"},"structs"),"."),(0,i.kt)("p",null,"Both struct types and values are written inside curly braces (",(0,i.kt)("inlineCode",{parentName:"p"},"{"),"...",(0,i.kt)("inlineCode",{parentName:"p"},"}"),"). In\nboth cases, they have a comma-separated list of members that start with a period\n(",(0,i.kt)("inlineCode",{parentName:"p"},"."),") followed by the field name."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In a struct type, the field name is followed by a colon (",(0,i.kt)("inlineCode",{parentName:"li"},":"),") and the type,\nas in: ",(0,i.kt)("inlineCode",{parentName:"li"},"{.name: String, .count: i32}"),"."),(0,i.kt)("li",{parentName:"ul"},"In a struct value, called a ",(0,i.kt)("em",{parentName:"li"},"structural data class literal")," or a ",(0,i.kt)("em",{parentName:"li"},"struct\nliteral"),", the field name is followed by an equal sign (",(0,i.kt)("inlineCode",{parentName:"li"},"="),") and the value,\nas in ",(0,i.kt)("inlineCode",{parentName:"li"},'{.key = "Joe", .count = 3}'),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#struct-types"},"Struct types")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/561"},"#561: Basic classes: use cases, struct literals, struct types, and future work")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/981"},"#981: Implicit conversions for aggregates")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/710"},"#710: Default comparison for data classes")))),(0,i.kt)("h3",{id:"pointer-types"},"Pointer types"),(0,i.kt)("p",null,"The type of pointers-to-values-of-type-",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is written ",(0,i.kt)("inlineCode",{parentName:"p"},"T*"),". Carbon pointers do\nnot support\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pointer_(computer_programming)"},"pointer arithmetic"),";\nthe only pointer ",(0,i.kt)("a",{parentName:"p",href:"#expressions"},"operations")," are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Dereference: given a pointer ",(0,i.kt)("inlineCode",{parentName:"li"},"p"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"*p")," gives the value ",(0,i.kt)("inlineCode",{parentName:"li"},"p")," points to as an\n",(0,i.kt)("a",{parentName:"li",href:"#value-categories-and-value-phases"},"l-value"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"p->m")," is syntactic sugar for\n",(0,i.kt)("inlineCode",{parentName:"li"},"(*p).m"),"."),(0,i.kt)("li",{parentName:"ul"},"Address-of: given an ",(0,i.kt)("a",{parentName:"li",href:"#value-categories-and-value-phases"},"l-value")," ",(0,i.kt)("inlineCode",{parentName:"li"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"&x"),"\nreturns a pointer to ",(0,i.kt)("inlineCode",{parentName:"li"},"x"),".")),(0,i.kt)("p",null,"There are no ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Null_pointer"},"null pointers")," in\nCarbon. To represent a pointer that may not refer to a valid object, use the\ntype ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(T*)"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"TODO:")," Perhaps Carbon will have\n",(0,i.kt)("a",{parentName:"p",href:"https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html"},"stricter pointer provenance"),"\nor restrictions on casts between pointers and integers."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/520"},"#520: should we use whitespace-sensitive operator fixity?")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/523"},"#523: what syntax should we use for pointer types?")))),(0,i.kt)("h3",{id:"arrays-and-slices"},"Arrays and slices"),(0,i.kt)("p",null,"The type of an array of holding 4 ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," values is written ",(0,i.kt)("inlineCode",{parentName:"p"},"[i32; 4]"),". There is\nan ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicit conversion")," from tuples to\narrays of the same length as long as every component of the tuple may be\nimplicitly converted to the destination element type. In cases where the size of\nthe array may be deduced, it may be omitted, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"var i: i32 = 1;\n// `[i32;]` equivalent to `[i32; 3]` here.\nvar a: [i32;] = (i, i, i);\n")),(0,i.kt)("p",null,"Elements of an array may be accessed using square brackets (",(0,i.kt)("inlineCode",{parentName:"p"},"["),"...",(0,i.kt)("inlineCode",{parentName:"p"},"]"),"), as in\n",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"a[i] = 2;\nConsole.Print(a[0]);\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:")," Slices")),(0,i.kt)("h2",{id:"expressions"},"Expressions"),(0,i.kt)("p",null,"Expressions describe some computed value. The simplest example would be a\nliteral number like ",(0,i.kt)("inlineCode",{parentName:"p"},"42"),": an expression that computes the integer value 42."),(0,i.kt)("p",null,"Some common expressions in Carbon include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Literals:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#bool"},"boolean"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"false")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#integer-literals"},"integer"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"42"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"-7")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#floating-point-literals"},"real-number"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"3.1419"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"6.022e+23")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#string-literals"},"string"),": ",(0,i.kt)("inlineCode",{parentName:"li"},'"Hello World!"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#tuples"},"tuple"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"(1, 2, 3)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#struct-types"},"struct"),": ",(0,i.kt)("inlineCode",{parentName:"li"},'{.word = "the", .count = 56}')))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#names"},"Names")," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access"},"member access"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"expressions#operators"},"Operators"),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/arithmetic"},"Arithmetic"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"-x"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"1 + 2"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"3 - 4"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"2 * 5"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"6 / 3"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"5 % 3")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/bitwise"},"Bitwise"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"2 & 3"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"2 | 4"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"3 ^ 1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"^7")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/bitwise"},"Bit shift"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"1 << 3"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"8 >> 1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/comparison_operators"},"Comparison"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"2 == 2"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"3 != 4"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"5 < 6"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"7 > 6"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"8 <= 8"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"8 >= 8")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/as_expressions"},"Conversion"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"2 as i32")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/logical_operators"},"Logical"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"a and b"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"c or d"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"not e")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#arrays-and-slices"},"Indexing"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"a[3]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#functions"},"Function")," call: ",(0,i.kt)("inlineCode",{parentName:"li"},"f(4)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#pointer-types"},"Pointer"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"*p"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"p->m"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"&x")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#move"},"Move"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"~x")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/if"},"Conditionals"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"if c then t else f"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Parentheses: ",(0,i.kt)("inlineCode",{parentName:"p"},"(7 + 8) * (3 - 1)")))),(0,i.kt)("p",null,"When an expression appears in a context in which an expression of a specific\ntype is expected, ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicit conversions"),"\nare applied to convert the expression to the target type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"expressions/"},"Expressions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/162"},"#162: Basic Syntax")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/555"},"#555: Operator precedence")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/601"},"#601: Operator tokens")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/680"},"#680: And, or, not")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/702"},"#702: Comparison operators")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/845"},"#845: as expressions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/911"},"#911: Conditional expressions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1083"},"#1083: Arithmetic expressions")))),(0,i.kt)("h2",{id:"declarations-definitions-and-scopes"},"Declarations, Definitions, and Scopes"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Declarations")," introduce a new ",(0,i.kt)("a",{parentName:"p",href:"#names"},"name")," and say what that name represents.\nFor some kinds of entities, like ",(0,i.kt)("a",{parentName:"p",href:"#functions"},"functions"),", there are two kinds of\ndeclarations: ",(0,i.kt)("em",{parentName:"p"},"forward declarations")," and ",(0,i.kt)("em",{parentName:"p"},"definitions"),". For those entities,\nthere should be exactly one definition for the name, and at most one additional\nforward declaration that introduces the name before it is defined, plus any\nnumber of declarations in a\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#prioritization-rule"},(0,i.kt)("inlineCode",{parentName:"a"},"match_first")," block"),". Forward\ndeclarations can be used to separate interface from implementation, such as to\ndeclare a name in an ",(0,i.kt)("a",{parentName:"p",href:"#files-libraries-packages"},"api file")," that is defined in an\n",(0,i.kt)("a",{parentName:"p",href:"#files-libraries-packages"},"impl file"),". Forward declarations also allow entities\nto be used before they are defined, such as to allow cyclic references. A name\nthat has been declared but not defined is called ",(0,i.kt)("em",{parentName:"p"},"incomplete"),", and in some cases\nthere are limitations on what can be done with an incomplete name. Within a\ndefinition, the defined name is incomplete until the end of the definition is\nreached, but is complete in the bodies of member functions because they are\n",(0,i.kt)("a",{parentName:"p",href:"#class-functions-and-factory-functions"},"parsed as if they appeared after the definition"),"."),(0,i.kt)("p",null,"A name is valid until the end of the innermost enclosing\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Scope_(computer_science)"},(0,i.kt)("em",{parentName:"a"},"scope")),". There are a\nfew kinds of scopes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the outermost scope, which includes the whole file,"),(0,i.kt)("li",{parentName:"ul"},"scopes that are enclosed in curly braces (",(0,i.kt)("inlineCode",{parentName:"li"},"{"),"...",(0,i.kt)("inlineCode",{parentName:"li"},"}"),"), and"),(0,i.kt)("li",{parentName:"ul"},"scopes that encompass a single declaration.")),(0,i.kt)("p",null,"For example, the names of the parameters of a ",(0,i.kt)("a",{parentName:"p",href:"#functions"},"function")," or\n",(0,i.kt)("a",{parentName:"p",href:"#classes"},"class")," are valid until the end of the declaration. The name of the\nfunction or class itself is visible until the end of the enclosing scope."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/project/principles/information_accumulation"},"Principle: Information accumulation")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/875"},"#875: Principle: information accumulation")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/472"},"#472: Open question: Calling functions defined later in the same file")))),(0,i.kt)("h2",{id:"patterns"},"Patterns"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"pattern")," says how to receive some data that is being matched against. There\nare two kinds of patterns:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Refutable")," patterns can fail to match based on the runtime value being\nmatched."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Irrefutable")," patterns are guaranteed to match, so long as the code\ntype-checks.")),(0,i.kt)("p",null,"Irrefutable patterns are used in ",(0,i.kt)("a",{parentName:"p",href:"#functions"},"function parameters"),",\n",(0,i.kt)("a",{parentName:"p",href:"#variable-var-declarations"},"variable ",(0,i.kt)("inlineCode",{parentName:"a"},"var")," declarations"),", and\n",(0,i.kt)("a",{parentName:"p",href:"#constant-let-declarations"},"constant ",(0,i.kt)("inlineCode",{parentName:"a"},"let")," declarations"),".\n",(0,i.kt)("a",{parentName:"p",href:"#match"},(0,i.kt)("inlineCode",{parentName:"a"},"match")," statements")," can include both refutable patterns and irrefutable\npatterns."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/pattern_matching"},"Pattern matching")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/162"},"#162: Basic Syntax")))),(0,i.kt)("h3",{id:"binding-patterns"},"Binding patterns"),(0,i.kt)("p",null,"The most common irrefutable pattern is a ",(0,i.kt)("em",{parentName:"p"},"binding pattern"),", consisting of a new\nname, a colon (",(0,i.kt)("inlineCode",{parentName:"p"},":"),"), and a type. It binds the matched value of that type to that\nname. It can only match values that may be\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicitly converted")," to that type. A\nunderscore (",(0,i.kt)("inlineCode",{parentName:"p"},"_"),") may be used instead of the name to match a value but without\nbinding any name to it."),(0,i.kt)("p",null,"Binding patterns default to ",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"em"},"let")," bindings"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," keyword is used to make\nit a ",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"em"},"var")," binding"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The result of a ",(0,i.kt)("inlineCode",{parentName:"li"},"let")," binding is the name is bound to an\n",(0,i.kt)("a",{parentName:"li",href:"#value-categories-and-value-phases"},"r-value"),". This means the value cannot\nbe modified, and its address generally cannot be taken."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"var")," binding has dedicated storage, and so the name is an\n",(0,i.kt)("a",{parentName:"li",href:"#value-categories-and-value-phases"},"l-value")," which can be modified and has\na stable address.")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"let"),"-binding may trigger a copy of the original value, or a move if the\noriginal value is a temporary, or the binding may be a pointer to the original\nvalue, like a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Reference_(C%2B%2B)"},(0,i.kt)("inlineCode",{parentName:"a"},"const")," reference in C++"),".\nWhich option must not be observable to the programmer. For example, Carbon will\nnot allow modifications to the original value when it is through a pointer. This\nchoice may also be influenced by the type. For example, types that don't support\nbeing copied will be passed by pointer instead."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"#checked-and-template-parameters"},"generic binding")," uses ",(0,i.kt)("inlineCode",{parentName:"p"},":!")," instead of a\ncolon (",(0,i.kt)("inlineCode",{parentName:"p"},":"),") and can only match\n",(0,i.kt)("a",{parentName:"p",href:"#value-categories-and-value-phases"},"constant or symbolic values"),", not run-time\nvalues."),(0,i.kt)("p",null,"The keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," may be used in place of the type in a binding pattern, as\nlong as the type can be deduced from the type of a value in the same\ndeclaration."),(0,i.kt)("h3",{id:"destructuring-patterns"},"Destructuring patterns"),(0,i.kt)("p",null,"There are also irrefutable ",(0,i.kt)("em",{parentName:"p"},"destructuring patterns"),", such as ",(0,i.kt)("em",{parentName:"p"},"tuple\ndestructuring"),". A tuple destructuring pattern looks like a tuple of patterns. It\nmay only be used to match tuple values whose components match the component\npatterns of the tuple. An example use is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"// `Bar()` returns a tuple consisting of an\n// `i32` value and 2-tuple of `f32` values.\nfn Bar() -> (i32, (f32, f32));\n\nfn Foo() -> i64 {\n  // Pattern in `var` declaration:\n  var (p: i64, _: auto) = Bar();\n  return p;\n}\n")),(0,i.kt)("p",null,"The pattern used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," declaration destructures the tuple value returned\nby ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar()"),". The first component pattern, ",(0,i.kt)("inlineCode",{parentName:"p"},"p: i64"),", corresponds to the first\ncomponent of the value returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar()"),", which has type ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),". This is\nallowed since there is an implicit conversion from ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"i64"),". The result of\nthis conversion is assigned to the name ",(0,i.kt)("inlineCode",{parentName:"p"},"p"),". The second component pattern,\n",(0,i.kt)("inlineCode",{parentName:"p"},"_: auto"),", matches the second component of the value returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar()"),", which\nhas type ",(0,i.kt)("inlineCode",{parentName:"p"},"(f32, f32)"),"."),(0,i.kt)("h3",{id:"refutable-patterns"},"Refutable patterns"),(0,i.kt)("p",null,"Additional kinds of patterns are allowed in ",(0,i.kt)("a",{parentName:"p",href:"#match"},(0,i.kt)("inlineCode",{parentName:"a"},"match")," statements"),", that\nmay or may not match based on the runtime value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," expression:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("em",{parentName:"li"},"expression pattern")," is an expression, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"42"),", whose value must be\nequal to match."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("em",{parentName:"li"},"choice pattern")," matches one case from a choice type, as described in\n",(0,i.kt)("a",{parentName:"li",href:"#choice-types"},"the choice types section"),"."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("em",{parentName:"li"},"dynamic cast pattern")," is tests the dynamic type, as described in\n",(0,i.kt)("a",{parentName:"li",href:"#inheritance"},"inheritance"),".")),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"#match"},(0,i.kt)("inlineCode",{parentName:"a"},"match"))," for examples of refutable patterns."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/pattern_matching"},"Pattern matching")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1283"},"#1283: how should pattern matching and implicit conversion interact?")))),(0,i.kt)("h2",{id:"name-binding-declarations"},"Name-binding declarations"),(0,i.kt)("p",null,"There are two kinds of name-binding declarations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"constant declarations, introduced with ",(0,i.kt)("inlineCode",{parentName:"li"},"let"),", and"),(0,i.kt)("li",{parentName:"ul"},"variable declarations, introduced with ",(0,i.kt)("inlineCode",{parentName:"li"},"var"),".")),(0,i.kt)("p",null,"There are no forward declarations of these; all name-binding declarations are\n",(0,i.kt)("a",{parentName:"p",href:"#declarations-definitions-and-scopes"},"definitions"),"."),(0,i.kt)("h3",{id:"constant-let-declarations"},"Constant ",(0,i.kt)("inlineCode",{parentName:"h3"},"let")," declarations"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," declaration matches an ",(0,i.kt)("a",{parentName:"p",href:"#patterns"},"irrefutable pattern")," to a value. In\nthis example, the name ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is bound to the value ",(0,i.kt)("inlineCode",{parentName:"p"},"42")," with type ",(0,i.kt)("inlineCode",{parentName:"p"},"i64"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"let x: i64 = 42;\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"x: i64")," is the pattern, which is followed by an equal sign (",(0,i.kt)("inlineCode",{parentName:"p"},"="),") and the\nvalue to match, ",(0,i.kt)("inlineCode",{parentName:"p"},"42"),". The names from ",(0,i.kt)("a",{parentName:"p",href:"#binding-patterns"},"binding patterns")," are\nintroduced into the enclosing ",(0,i.kt)("a",{parentName:"p",href:"#declarations-definitions-and-scopes"},"scope"),"."),(0,i.kt)("h3",{id:"variable-var-declarations"},"Variable ",(0,i.kt)("inlineCode",{parentName:"h3"},"var")," declarations"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," declaration is similar, except with ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," bindings, so ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," here is an\n",(0,i.kt)("a",{parentName:"p",href:"#value-categories-and-value-phases"},"l-value")," with storage and an address, and\nso may be modified:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"var x: i64 = 42;\nx = 7;\n")),(0,i.kt)("p",null,"Variables with a type that has ",(0,i.kt)("a",{parentName:"p",href:"#unformed-state"},"an unformed state")," do not need\nto be initialized in the variable declaration, but do need to be assigned before\nthey are used."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/variables"},"Variables")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/162"},"#162: Basic Syntax")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/257"},"#257: Initialization of memory and variables")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/339"},"#339: Add ",(0,i.kt)("inlineCode",{parentName:"a"},"var <type> <identifier> [ = <value> ];")," syntax for variables")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/618"},"#618: var ordering")))),(0,i.kt)("h3",{id:"auto"},(0,i.kt)("inlineCode",{parentName:"h3"},"auto")),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," is used as the type in a ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," declaration, the type is the\nstatic type of the initializer expression, which is required."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var x: i64 = 2;\n// The type of `y` is inferred to be `i64`.\nlet y: auto = x + 3;\n// The type of `z` is inferred to be `bool`.\nvar z: auto = (y > 1);\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/type_inference"},"Type inference")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/851"},"#851: auto keyword for vars")))),(0,i.kt)("h2",{id:"functions"},"Functions"),(0,i.kt)("p",null,"Functions are the core unit of behavior. For example, this is a\n",(0,i.kt)("a",{parentName:"p",href:"#declarations-definitions-and-scopes"},"forward declaration")," of a function that\nadds two 64-bit integers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Add(a: i64, b: i64) -> i64;\n")),(0,i.kt)("p",null,"Breaking this apart:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fn")," is the keyword used to introduce a function."),(0,i.kt)("li",{parentName:"ul"},"Its name is ",(0,i.kt)("inlineCode",{parentName:"li"},"Add"),". This is the name added to the enclosing\n",(0,i.kt)("a",{parentName:"li",href:"#declarations-definitions-and-scopes"},"scope"),"."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"#parameters"},"parameter list")," in parentheses (",(0,i.kt)("inlineCode",{parentName:"li"},"("),"...",(0,i.kt)("inlineCode",{parentName:"li"},")"),") is a\ncomma-separated list of ",(0,i.kt)("a",{parentName:"li",href:"#patterns"},"irrefutable patterns"),"."),(0,i.kt)("li",{parentName:"ul"},"It returns an ",(0,i.kt)("inlineCode",{parentName:"li"},"i64")," result. Functions that return nothing omit the ",(0,i.kt)("inlineCode",{parentName:"li"},"->")," and\nreturn type.")),(0,i.kt)("p",null,"You would call this function like ",(0,i.kt)("inlineCode",{parentName:"p"},"Add(1, 2)"),"."),(0,i.kt)("p",null,"A function definition is a function declaration that has a body\n",(0,i.kt)("a",{parentName:"p",href:"#blocks-and-statements"},"block")," instead of a semicolon:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Add(a: i64, b: i64) -> i64 {\n  return a + b;\n}\n")),(0,i.kt)("p",null,"The names of the parameters are in scope until the end of the definition or\ndeclaration. The parameter names in a forward declaration may be omitted using\n",(0,i.kt)("inlineCode",{parentName:"p"},"_"),", but must match the definition if they are specified."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/functions"},"Functions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/162"},"#162: Basic Syntax")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/438"},"#438: Add statement syntax for function declarations")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/476"},"#476: Optional argument names (unused arguments)")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1132"},"#1132: How do we match forward declarations with their definitions?")))),(0,i.kt)("h3",{id:"parameters"},"Parameters"),(0,i.kt)("p",null,"The bindings in the parameter list default to\n",(0,i.kt)("a",{parentName:"p",href:"#binding-patterns"},(0,i.kt)("inlineCode",{parentName:"a"},"let")," bindings"),", and so the parameter names are treated as\n",(0,i.kt)("a",{parentName:"p",href:"#value-categories-and-value-phases"},"r-values"),". This is appropriate for input\nparameters. This binding will be implemented using a pointer, unless it is legal\nto copy and copying is cheaper."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," keyword is added before the binding, then the arguments will be\ncopied (or moved from a temporary) to new storage, and so can be mutated in the\nfunction body. The copy ensures that any mutations will not be visible to the\ncaller."),(0,i.kt)("p",null,"Use a ",(0,i.kt)("a",{parentName:"p",href:"#pointer-types"},"pointer")," parameter type to represent an\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Parameter_(computer_programming)#Output_parameters"},"input/output parameter"),",\nallowing a function to modify a variable of the caller's. This makes the\npossibility of those modifications visible: by taking the address using ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," in\nthe caller, and dereferencing using ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," in the callee."),(0,i.kt)("p",null,"Outputs of a function should prefer to be returned. Multiple values may be\nreturned using a ",(0,i.kt)("a",{parentName:"p",href:"#tuples"},"tuple")," or ",(0,i.kt)("a",{parentName:"p",href:"#struct-types"},"struct")," type."),(0,i.kt)("h3",{id:"auto-return-type"},(0,i.kt)("inlineCode",{parentName:"h3"},"auto")," return type"),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," is used in place of the return type, the return type of the function\nis inferred from the function body. It is set to ",(0,i.kt)("a",{parentName:"p",href:"#common-type"},"common type")," of\nthe static type of arguments to the ",(0,i.kt)("a",{parentName:"p",href:"#return"},(0,i.kt)("inlineCode",{parentName:"a"},"return")," statements")," in the\nfunction. This is not allowed in a forward declaration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Return type is inferred to be `bool`, the type of `a > 0`.\nfn Positive(a: i64) -> auto {\n  return a > 0;\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/type_inference"},"Type inference")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/functions#return-clause"},"Function return clause")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/826"},"#826: Function return type inference")))),(0,i.kt)("h3",{id:"blocks-and-statements"},"Blocks and statements"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"block")," is a sequence of ",(0,i.kt)("em",{parentName:"p"},"statements"),". A block defines a\n",(0,i.kt)("a",{parentName:"p",href:"#declarations-definitions-and-scopes"},"scope")," and, like other scopes, is\nenclosed in curly braces (",(0,i.kt)("inlineCode",{parentName:"p"},"{"),"...",(0,i.kt)("inlineCode",{parentName:"p"},"}"),"). Each statement is terminated by a\nsemicolon or block. ",(0,i.kt)("a",{parentName:"p",href:"#expressions"},"Expressions")," and\n",(0,i.kt)("a",{parentName:"p",href:"#variable-var-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"var"))," and ",(0,i.kt)("a",{parentName:"p",href:"#constant-let-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"let"))," are\nvalid statements."),(0,i.kt)("p",null,"Statements within a block are normally executed in the order they appear in the\nsource code, except when modified by control-flow statements."),(0,i.kt)("p",null,"The body of a function is defined by a block, and some\n",(0,i.kt)("a",{parentName:"p",href:"#control-flow"},"control-flow statements")," have their own blocks of code. These\nare nested within the enclosing scope. For example, here is a function\ndefinition with a block of statements defining the body of the function, and a\nnested block as part of a ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," statement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Foo() {\n  Bar();\n  while (Baz()) {\n    Quux();\n  }\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/blocks_and_statements"},"Blocks and statements")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/162"},"#162: Basic Syntax")))),(0,i.kt)("h3",{id:"assignment-statements"},"Assignment statements"),(0,i.kt)("p",null,"Assignment statements mutate the value of the\n",(0,i.kt)("a",{parentName:"p",href:"#value-categories-and-value-phases"},"l-value")," described on the left-hand side of\nthe assignment."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Assignment: ",(0,i.kt)("inlineCode",{parentName:"li"},"x = y;"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," is assigned the value of ",(0,i.kt)("inlineCode",{parentName:"li"},"y"),"."),(0,i.kt)("li",{parentName:"ul"},"Increment and decrement: ",(0,i.kt)("inlineCode",{parentName:"li"},"++i;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"--j;"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"i")," is set to ",(0,i.kt)("inlineCode",{parentName:"li"},"i + 1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"j")," is set\nto ",(0,i.kt)("inlineCode",{parentName:"li"},"j - 1"),"."),(0,i.kt)("li",{parentName:"ul"},"Compound assignment: ",(0,i.kt)("inlineCode",{parentName:"li"},"x += y;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x -= y;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x *= y;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x /= y;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x &= y;"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"x |= y;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x ^= y;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x <<= y;"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x >>= y;"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"x @= y;")," is equivalent to\n",(0,i.kt)("inlineCode",{parentName:"li"},"x = x @ y;")," for each operator ",(0,i.kt)("inlineCode",{parentName:"li"},"@"),".")),(0,i.kt)("p",null,"Unlike C++, these assignments are statements, not expressions, and don't return\na value."),(0,i.kt)("h3",{id:"control-flow"},"Control flow"),(0,i.kt)("p",null,"Blocks of statements are generally executed sequentially. Control-flow\nstatements give additional control over the flow of execution and which\nstatements are executed."),(0,i.kt)("p",null,"Some control-flow statements include ",(0,i.kt)("a",{parentName:"p",href:"#blocks-and-statements"},"blocks"),". Those\nblocks will always be within curly braces ",(0,i.kt)("inlineCode",{parentName:"p"},"{"),"...",(0,i.kt)("inlineCode",{parentName:"p"},"}"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"// Curly braces { ... } are required.\nif (condition) {\n  ExecutedWhenTrue();\n} else {\n  ExecutedWhenFalse();\n}\n")),(0,i.kt)("p",null,"This is unlike C++, which allows control-flow constructs to omit curly braces\naround a single statement."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/control_flow/"},"Control flow")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/162"},"#162: Basic Syntax")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/623"},"#623: Require braces")))),(0,i.kt)("h4",{id:"if-and-else"},(0,i.kt)("inlineCode",{parentName:"h4"},"if")," and ",(0,i.kt)("inlineCode",{parentName:"h4"},"else")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"if")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," provide conditional execution of statements. An ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statement\nconsists of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("inlineCode",{parentName:"li"},"if")," introducer followed by a condition in parentheses. If the condition\nevaluates to ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),", the block following the condition is executed,\notherwise it is skipped."),(0,i.kt)("li",{parentName:"ul"},"This may be followed by zero or more ",(0,i.kt)("inlineCode",{parentName:"li"},"else if")," clauses, whose conditions are\nevaluated if all prior conditions evaluate to ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),", with a block that is\nexecuted if that evaluation is to ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),"."),(0,i.kt)("li",{parentName:"ul"},"A final optional ",(0,i.kt)("inlineCode",{parentName:"li"},"else")," clause, with a block that is executed if all\nconditions evaluate to ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),".")),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'if (fruit.IsYellow()) {\n  Console.Print("Banana!");\n} else if (fruit.IsOrange()) {\n  Console.Print("Orange!");\n} else {\n  Console.Print("Vegetable!");\n}\n')),(0,i.kt)("p",null,"This code will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Print ",(0,i.kt)("inlineCode",{parentName:"li"},"Banana!")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"fruit.IsYellow()")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),"."),(0,i.kt)("li",{parentName:"ul"},"Print ",(0,i.kt)("inlineCode",{parentName:"li"},"Orange!")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"fruit.IsYellow()")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"fruit.IsOrange()")," is\n",(0,i.kt)("inlineCode",{parentName:"li"},"true"),"."),(0,i.kt)("li",{parentName:"ul"},"Print ",(0,i.kt)("inlineCode",{parentName:"li"},"Vegetable!")," if both of the above return ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/control_flow/conditionals"},"Control flow")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/285"},"#285: if/else")))),(0,i.kt)("h4",{id:"loops"},"Loops"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/control_flow/loops"},"Loops"))),(0,i.kt)("h5",{id:"while"},(0,i.kt)("inlineCode",{parentName:"h5"},"while")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"while")," statements loop for as long as the passed expression returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". For\nexample, this prints ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"Done!"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'var x: i32 = 0;\nwhile (x < 3) {\n  Console.Print(x);\n  ++x;\n}\nConsole.Print("Done!");\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/control_flow/loops#while"},(0,i.kt)("inlineCode",{parentName:"a"},"while")," loops")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/340"},"#340: Add C++-like ",(0,i.kt)("inlineCode",{parentName:"a"},"while")," loops")))),(0,i.kt)("h5",{id:"for"},(0,i.kt)("inlineCode",{parentName:"h5"},"for")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"for")," statements support range-based looping, typically over containers. For\nexample, this prints each ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," value in ",(0,i.kt)("inlineCode",{parentName:"p"},"names"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"for (var name: String in names) {\n  Console.Print(name);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/control_flow/loops#for"},(0,i.kt)("inlineCode",{parentName:"a"},"for")," loops")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/353"},"#353: Add C++-like ",(0,i.kt)("inlineCode",{parentName:"a"},"for")," loops")))),(0,i.kt)("h5",{id:"break"},(0,i.kt)("inlineCode",{parentName:"h5"},"break")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," statement immediately ends a ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop. Execution will\ncontinue starting from the end of the loop's scope. For example, this processes\nsteps until a manual step is hit (if no manual step is hit, all steps are\nprocessed):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'for (var step: Step in steps) {\n  if (step.IsManual()) {\n    Console.Print("Reached manual step!");\n    break;\n  }\n  step.Process();\n}\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/control_flow/loops#break"},(0,i.kt)("inlineCode",{parentName:"a"},"break")))),(0,i.kt)("h5",{id:"continue"},(0,i.kt)("inlineCode",{parentName:"h5"},"continue")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"continue")," statement immediately goes to the next loop of a ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"for"),". In a ",(0,i.kt)("inlineCode",{parentName:"p"},"while"),", execution continues with the ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," expression. For\nexample, this prints all non-empty lines of a file, using ",(0,i.kt)("inlineCode",{parentName:"p"},"continue")," to skip\nempty lines:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"var f: File = OpenFile(path);\nwhile (!f.EOF()) {\n  var line: String = f.ReadLine();\n  if (line.IsEmpty()) {\n    continue;\n  }\n  Console.Print(line);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/control_flow/loops#continue"},(0,i.kt)("inlineCode",{parentName:"a"},"continue")))),(0,i.kt)("h4",{id:"return"},(0,i.kt)("inlineCode",{parentName:"h4"},"return")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement ends the flow of execution within a function, returning\nexecution to the caller."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"// Prints the integers 1 .. `n` and then\n// returns to the caller.\nfn PrintFirstN(n: i32) {\n  var i: i32 = 0;\n  while (true) {\n    i += 1;\n    if (i > n) {\n      // None of the rest of the function is\n      // executed after a `return`.\n      return;\n    }\n    Console.Print(i);\n  }\n}\n")),(0,i.kt)("p",null,"If the function returns a value to the caller, that value is provided by an\nexpression in the return statement. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Sign(i: i32) -> i32 {\n  if (i > 0) {\n    return 1;\n  }\n  if (i < 0) {\n    return -1;\n  }\n  return 0;\n}\n\nAssert(Sign(-3) == -1);\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/control_flow/return"},(0,i.kt)("inlineCode",{parentName:"a"},"return"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/functions#return-statements"},(0,i.kt)("inlineCode",{parentName:"a"},"return")," statements")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/415"},"#415: return")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/538"},"#538: return with no argument")))),(0,i.kt)("h5",{id:"returned-var"},(0,i.kt)("inlineCode",{parentName:"h5"},"returned var")),(0,i.kt)("p",null,"To avoid a copy when returning a variable, add a ",(0,i.kt)("inlineCode",{parentName:"p"},"returned")," prefix to the\nvariable's declaration and use ",(0,i.kt)("inlineCode",{parentName:"p"},"return var")," instead of returning an expression,\nas in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn MakeCircle(radius: i32) -> Circle {\n  returned var c: Circle;\n  c.radius = radius;\n  // `return c` would be invalid because `returned` is in use.\n  return var;\n}\n")),(0,i.kt)("p",null,"This is instead of\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization"},'the "named return value optimization" of C++'),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/control_flow/return#returned-var"},(0,i.kt)("inlineCode",{parentName:"a"},"returned var"))),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/257"},"#257: Initialization of memory and variables")))),(0,i.kt)("h4",{id:"match"},(0,i.kt)("inlineCode",{parentName:"h4"},"match")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"match")," is a control flow similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," of C and C++ and mirrors similar\nconstructs in other languages, such as Swift. The ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," keyword is followed by\nan expression in parentheses, whose value is matched against the ",(0,i.kt)("inlineCode",{parentName:"p"},"case"),"\ndeclarations, each of which contains a ",(0,i.kt)("a",{parentName:"p",href:"#refutable-patterns"},"refutable pattern"),",\nin order. The refutable pattern may optionally be followed by an ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),"\nexpression, which may use the names from bindings in the pattern."),(0,i.kt)("p",null,"The code for the first matching ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," is executed. An optional ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," block\nmay be placed after the ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," declarations, it will be executed if none of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"case")," declarations match."),(0,i.kt)("p",null,"An example ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Bar() -> (i32, (f32, f32));\n\nfn Foo() -> f32 {\n  match (Bar()) {\n    case (42, (x: f32, y: f32)) => {\n      return x - y;\n    }\n    case (p: i32, (x: f32, _: f32)) if (p < 13) => {\n      return p * x;\n    }\n    case (p: i32, _: auto) if (p > 3) => {\n      return p * Pi;\n    }\n    default => {\n      return Pi;\n    }\n  }\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/pattern_matching"},"Pattern matching")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1283"},"#1283: how should pattern matching and implicit conversion interact?")))),(0,i.kt)("h2",{id:"user-defined-types"},"User-defined types"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:"),' Maybe rename to "nominal types"?')),(0,i.kt)("h3",{id:"classes"},"Classes"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Nominal classes"),", or just\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Class_(computer_programming)"},(0,i.kt)("em",{parentName:"a"},"classes")),", are a\nway for users to define their own\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Data_structure"},"data structures")," or\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Record_(computer_science)"},"record types"),"."),(0,i.kt)("p",null,"This is an example of a class\n",(0,i.kt)("a",{parentName:"p",href:"#declarations-definitions-and-scopes"},"definition"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Widget {\n  var x: i32;\n  var y: i32;\n  var payload: String;\n}\n")),(0,i.kt)("p",null,"Breaking this apart:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This defines a class named ",(0,i.kt)("inlineCode",{parentName:"li"},"Widget"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"Widget")," is the name added to the\nenclosing ",(0,i.kt)("a",{parentName:"li",href:"#declarations-definitions-and-scopes"},"scope"),"."),(0,i.kt)("li",{parentName:"ul"},"The name ",(0,i.kt)("inlineCode",{parentName:"li"},"Widget")," is followed by curly braces (",(0,i.kt)("inlineCode",{parentName:"li"},"{"),"...",(0,i.kt)("inlineCode",{parentName:"li"},"}"),") containing the\nclass ",(0,i.kt)("em",{parentName:"li"},"body"),", making this a\n",(0,i.kt)("a",{parentName:"li",href:"#declarations-definitions-and-scopes"},"definition"),". A\n",(0,i.kt)("a",{parentName:"li",href:"#declarations-definitions-and-scopes"},"forward declaration")," would instead\nhave a semicolon(",(0,i.kt)("inlineCode",{parentName:"li"},";"),")."),(0,i.kt)("li",{parentName:"ul"},"Those braces delimit the class'\n",(0,i.kt)("a",{parentName:"li",href:"#declarations-definitions-and-scopes"},"scope"),"."),(0,i.kt)("li",{parentName:"ul"},"Fields, or\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Instance_variable"},"instances variables"),", are\ndefined using ",(0,i.kt)("a",{parentName:"li",href:"#variable-var-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"var")," declarations"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"Widget")," has\ntwo ",(0,i.kt)("inlineCode",{parentName:"li"},"i32")," fields (",(0,i.kt)("inlineCode",{parentName:"li"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"y"),"), and one ",(0,i.kt)("inlineCode",{parentName:"li"},"String")," field (",(0,i.kt)("inlineCode",{parentName:"li"},"payload"),").")),(0,i.kt)("p",null,"The order of the field declarations determines the fields' memory-layout order."),(0,i.kt)("p",null,"Classes may have other kinds of members beyond fields declared in its scope:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#class-functions-and-factory-functions"},"Class functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#methods"},"Methods")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#aliases"},(0,i.kt)("inlineCode",{parentName:"a"},"alias"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#constant-let-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"let"))," to define class constants. ",(0,i.kt)("strong",{parentName:"li"},"TODO:"),"\nAnother syntax to define constants associated with the class like\n",(0,i.kt)("inlineCode",{parentName:"li"},"class let")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"static let"),"?"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"class"),", to define a\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Inner_class"},(0,i.kt)("em",{parentName:"a"},"member class")," or ",(0,i.kt)("em",{parentName:"a"},"nested class")))),(0,i.kt)("p",null,"Within the scope of a class, the unqualified name ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," can be used to refer to\nthe class itself."),(0,i.kt)("p",null,"Members of a class are ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access"},"accessed")," using the dot\n(",(0,i.kt)("inlineCode",{parentName:"p"},"."),") notation, so given an instance ",(0,i.kt)("inlineCode",{parentName:"p"},"dial")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Widget"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dial.payload"),"\nrefers to its ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," field."),(0,i.kt)("p",null,"Both ",(0,i.kt)("a",{parentName:"p",href:"#struct-types"},"structural data classes")," and nominal classes are considered\n",(0,i.kt)("em",{parentName:"p"},"class types"),', but they are commonly referred to as "structs" and "classes"\nrespectively when that is not confusing. Like structs, classes refer to their\nmembers by name. Unlike structs, classes are\n',(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Nominal_type_system#Nominal_typing"},"nominal types"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#nominal-class-types"},"Classes")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/722"},"#722: Nominal classes and methods")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/989"},"#989: Member access expressions")))),(0,i.kt)("h4",{id:"assignment"},"Assignment"),(0,i.kt)("p",null,"There is an ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicit conversions")," defined\nbetween a ",(0,i.kt)("a",{parentName:"p",href:"#struct-types"},"struct literal")," and a class type with the same fields,\nin any scope that has ",(0,i.kt)("a",{parentName:"p",href:"#access-control"},"access")," to all of the class' fields.\nThis may be used to assign or initialize a variable with a class type, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'var sprocket: Widget = {.x = 3, .y = 4, .payload = "Sproing"};\nsprocket = {.x = 2, .y = 1, .payload = "Bounce"};\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#construction"},"Classes: Construction")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/981"},"#981: Implicit conversions for aggregates")))),(0,i.kt)("h4",{id:"class-functions-and-factory-functions"},"Class functions and factory functions"),(0,i.kt)("p",null,"Classes may also contain ",(0,i.kt)("em",{parentName:"p"},"class functions"),". These are functions that are\naccessed as members of the type, like\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods"},"static member functions in C++"),",\nas opposed to ",(0,i.kt)("a",{parentName:"p",href:"#methods"},"methods")," that are members of instances. They are\ncommonly used to define a function that creates instances. Carbon does not have\nseparate\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)"},"constructors"),"\nlike C++ does."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Point {\n  // Class function that instantiates `Point`.\n  // `Self` in class scope means the class currently being defined.\n  fn Origin() -> Self {\n    return {.x = 0, .y = 0};\n  }\n  var x: i32;\n  var y: i32;\n}\n")),(0,i.kt)("p",null,"Note that if the definition of a function is provided inside the class scope,\nthe body is treated as if it was defined immediately after the outermost class\ndefinition. This means that members such as the fields will be considered\ndeclared even if their declarations are later in the source than the class\nfunction."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"#returned-var"},(0,i.kt)("inlineCode",{parentName:"a"},"returned var")," feature")," can be used if the address of the\ninstance being created is needed in a factory function, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Registered {\n  fn Make() -> Self {\n    returned var result: Self = {...};\n    StoreMyPointerSomewhere(&result);\n    return var;\n  }\n}\n")),(0,i.kt)("p",null,"This approach can also be used for types that can't be copied or moved."),(0,i.kt)("h4",{id:"methods"},"Methods"),(0,i.kt)("p",null,"Class type definitions can include methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Point {\n  // Method defined inline\n  fn Distance[me: Self](x2: i32, y2: i32) -> f32 {\n    var dx: i32 = x2 - me.x;\n    var dy: i32 = y2 - me.y;\n    return Math.Sqrt(dx * dx + dy * dy);\n  }\n  // Mutating method declaration\n  fn Offset[addr me: Self*](dx: i32, dy: i32);\n\n  var x: i32;\n  var y: i32;\n}\n\n// Out-of-line definition of method declared inline\nfn Point.Offset[addr me: Self*](dx: i32, dy: i32) {\n  me->x += dx;\n  me->y += dy;\n}\n\nvar origin: Point = {.x = 0, .y = 0};\nAssert(Math.Abs(origin.Distance(3, 4) - 5.0) < 0.001);\norigin.Offset(3, 4);\nAssert(origin.Distance(3, 4) == 0.0);\n")),(0,i.kt)("p",null,"This defines a ",(0,i.kt)("inlineCode",{parentName:"p"},"Point")," class type with two integer data members ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," and\ntwo methods ",(0,i.kt)("inlineCode",{parentName:"p"},"Distance")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Offset"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Methods are defined as class functions with a ",(0,i.kt)("inlineCode",{parentName:"li"},"me")," parameter inside square\nbrackets ",(0,i.kt)("inlineCode",{parentName:"li"},"["),"...",(0,i.kt)("inlineCode",{parentName:"li"},"]")," before the regular explicit parameter list in parens\n",(0,i.kt)("inlineCode",{parentName:"li"},"("),"...",(0,i.kt)("inlineCode",{parentName:"li"},")"),"."),(0,i.kt)("li",{parentName:"ul"},"Methods are called using the member syntax, ",(0,i.kt)("inlineCode",{parentName:"li"},"origin.Distance("),"...",(0,i.kt)("inlineCode",{parentName:"li"},")")," and\n",(0,i.kt)("inlineCode",{parentName:"li"},"origin.Offset("),"...",(0,i.kt)("inlineCode",{parentName:"li"},")"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Distance")," computes and returns the distance to another point, without\nmodifying the ",(0,i.kt)("inlineCode",{parentName:"li"},"Point"),". This is signified using ",(0,i.kt)("inlineCode",{parentName:"li"},"[me: Self]")," in the method\ndeclaration."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"origin.Offset("),"...",(0,i.kt)("inlineCode",{parentName:"li"},")")," does modify the value of ",(0,i.kt)("inlineCode",{parentName:"li"},"origin"),". This is signified\nusing ",(0,i.kt)("inlineCode",{parentName:"li"},"[addr me: Self*]")," in the method declaration. Since calling this\nmethod requires taking the address of ",(0,i.kt)("inlineCode",{parentName:"li"},"origin"),", it may only be called on\n",(0,i.kt)("a",{parentName:"li",href:"#const"},"non-",(0,i.kt)("inlineCode",{parentName:"a"},"const"))," ",(0,i.kt)("a",{parentName:"li",href:"#value-categories-and-value-phases"},"l-values"),"."),(0,i.kt)("li",{parentName:"ul"},"Methods may be declared lexically inline like ",(0,i.kt)("inlineCode",{parentName:"li"},"Distance"),", or lexically out\nof line like ",(0,i.kt)("inlineCode",{parentName:"li"},"Offset"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#methods"},"Methods")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/722"},"#722: Nominal classes and methods")))),(0,i.kt)("h4",{id:"inheritance"},"Inheritance"),(0,i.kt)("p",null,"The philosophy of inheritance support in Carbon is to focus on use cases where\ninheritance is a good match, and use other features for other cases. For\nexample, ",(0,i.kt)("a",{parentName:"p",href:"#mixins"},"mixins")," for implementation reuse and ",(0,i.kt)("a",{parentName:"p",href:"#generics"},"generics"),"\nfor separating interface from implementation. This allows Carbon to move away\nfrom ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Multiple_inheritance"},"multiple inheritance"),",\nwhich doesn't have as efficient of an implementation strategy."),(0,i.kt)("p",null,"Classes by default are\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Non-subclassable_classes"},(0,i.kt)("em",{parentName:"a"},"final")),",\nwhich means they may not be extended. A class may be declared as allowing\nextension using either the ",(0,i.kt)("inlineCode",{parentName:"p"},"base class")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract class")," introducer instead\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"class"),". An ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract class")," is a base class that may not itself be\ninstantiated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"base class MyBaseClass { ... }\n")),(0,i.kt)("p",null,"Either kind of base class may be ",(0,i.kt)("em",{parentName:"p"},"extended")," to get a ",(0,i.kt)("em",{parentName:"p"},"derived class"),". Derived\nclasses are final unless they are themselves declared ",(0,i.kt)("inlineCode",{parentName:"p"},"base")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract"),".\nClasses may only extend a single class. Carbon only supports single inheritance,\nand will use mixins instead of multiple inheritance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"base class MiddleDerived extends MyBaseClass { ... }\nclass FinalDerived extends MiddleDerived { ... }\n// \u274c Forbidden: class Illegal extends FinalDerived { ... }\n")),(0,i.kt)("p",null,"A base class may define\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_function"},"virtual methods"),". These are\nmethods whose implementation may be overridden in a derived class. By default\nmethods are ",(0,i.kt)("em",{parentName:"p"},"non-virtual"),", the declaration of a virtual method must be prefixed\nby one of these three keywords:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A method marked ",(0,i.kt)("inlineCode",{parentName:"li"},"virtual")," has a definition in this class but not in any\nbase."),(0,i.kt)("li",{parentName:"ul"},"A method marked ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract")," does not have a definition in this class, but\nmust have a definition in any non-",(0,i.kt)("inlineCode",{parentName:"li"},"abstract")," derived class."),(0,i.kt)("li",{parentName:"ul"},"A method marked ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," has a definition in this class, overriding any\ndefinition in a base class.")),(0,i.kt)("p",null,"A pointer to a derived class may be cast to a pointer to one of its base\nclasses. Calling a virtual method through a pointer to a base class will use the\noverridden definition provided in the derived class. Base classes with ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual"),"\nmethods may use\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Run-time_type_information"},"run-time type information"),"\nin a match statement to dynamically test whether the dynamic type of a value is\nsome derived class, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"var base_ptr: MyBaseType* = ...;\nmatch (base_ptr) {\n  case dyn p: MiddleDerived* => { ... }\n}\n")),(0,i.kt)("p",null,"For purposes of construction, a derived class acts like its first field is\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"base")," with the type of its immediate base class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class MyDerivedType extends MyBaseType {\n  fn Make() -> MyDerivedType {\n    return {.base = MyBaseType.Make(), .derived_field = 7};\n  }\n  var derived_field: i32;\n}\n")),(0,i.kt)("p",null,"Abstract classes can't be instantiated, so instead they should define class\nfunctions returning ",(0,i.kt)("inlineCode",{parentName:"p"},"partial Self"),". Those functions should be marked\n",(0,i.kt)("a",{parentName:"p",href:"#access-control"},(0,i.kt)("inlineCode",{parentName:"a"},"protected"))," so they may only be used by derived classes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"abstract class AbstractClass {\n  protected fn Make() -> partial Self {\n    return {.field_1 = 3, .field_2 = 9};\n  }\n  // ...\n  var field_1: i32;\n  var field_2: i32;\n}\n// \u274c Error: can't instantiate abstract class\nvar abc: AbstractClass = ...;\n\nclass DerivedFromAbstract extends AbstractClass {\n  fn Make() -> Self {\n    // AbstractClass.Make() returns a\n    // `partial AbstractClass` that can be used as\n    // the `.base` member when constructing a value\n    // of a derived class.\n    return {.base = AbstractClass.Make(),\n            .derived_field = 42 };\n  }\n\n  var derived_field: i32;\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#inheritance"},"Inheritance")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/777"},"#777: Inheritance")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/820"},"#820: Implicit conversions")))),(0,i.kt)("h4",{id:"access-control"},"Access control"),(0,i.kt)("p",null,"Class members are by default publicly accessible. The ",(0,i.kt)("inlineCode",{parentName:"p"},"private")," keyword prefix\ncan be added to the member's declaration to restrict it to members of the class\nor any friends. A ",(0,i.kt)("inlineCode",{parentName:"p"},"private virtual")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"private abstract")," method may be\nimplemented in derived classes, even though it may not be called."),(0,i.kt)("p",null,"Friends may be declared using a ",(0,i.kt)("inlineCode",{parentName:"p"},"friend")," declaration inside the class naming an\nexisting function or type. Unlike C++, ",(0,i.kt)("inlineCode",{parentName:"p"},"friend")," declarations may only refer to\nnames resolvable by the compiler, and don't act like forward declarations."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"protected")," is like ",(0,i.kt)("inlineCode",{parentName:"p"},"private"),", but also gives access to derived classes."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#access-control"},"Access control for class members")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/665"},"#665: ",(0,i.kt)("inlineCode",{parentName:"a"},"private")," vs ",(0,i.kt)("inlineCode",{parentName:"a"},"public")," ",(0,i.kt)("em",{parentName:"a"},"syntax")," strategy, as well as other visibility tools like ",(0,i.kt)("inlineCode",{parentName:"a"},"external"),"/",(0,i.kt)("inlineCode",{parentName:"a"},"api"),"/etc.")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/971"},"#971: Private interfaces in public API files")))),(0,i.kt)("h4",{id:"destructors"},"Destructors"),(0,i.kt)("p",null,"A destructor for a class is custom code executed when the lifetime of a value of\nthat type ends. They are defined with the ",(0,i.kt)("inlineCode",{parentName:"p"},"destructor")," keyword followed by\neither ",(0,i.kt)("inlineCode",{parentName:"p"},"[me: Self]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"[addr me: Self*]")," (as is done with ",(0,i.kt)("a",{parentName:"p",href:"#methods"},"methods"),")\nand the block of code in the class definition, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class MyClass {\n  destructor [me: Self] { ... }\n}\n")),(0,i.kt)("p",null,"or:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class MyClass {\n  // Can modify `me` in the body.\n  destructor [addr me: Self*] { ... }\n}\n")),(0,i.kt)("p",null,"The destructor for a class is run before the destructors of its data members.\nThe data members are destroyed in reverse order of declaration. Derived classes\nare destroyed before their base classes."),(0,i.kt)("p",null,"A destructor in an abstract or base class may be declared ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual")," like with\n",(0,i.kt)("a",{parentName:"p",href:"#inheritance"},"methods"),". Destructors in classes derived from one with a virtual\ndestructor must be declared with the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," keyword prefix. It is illegal to\ndelete an instance of a derived class through a pointer to a base class unless\nthe base class is declared ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),". To delete a pointer to a\nnon-abstract base class when it is known not to point to a value with a derived\ntype, use ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsafeDelete"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#destructors"},"Destructors")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1154"},"#1154: Destructors")))),(0,i.kt)("h4",{id:"const"},(0,i.kt)("inlineCode",{parentName:"h4"},"const")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," This is provisional, no design for ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," has been through the\nproposal process yet."),(0,i.kt)("p",null,"For every type ",(0,i.kt)("inlineCode",{parentName:"p"},"MyClass"),", there is the type ",(0,i.kt)("inlineCode",{parentName:"p"},"const MyClass")," such that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The data representation is the same, so a ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass*")," value may be implicitly\nconverted to a ",(0,i.kt)("inlineCode",{parentName:"li"},"(const MyClass)*"),"."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"const MyClass")," ",(0,i.kt)("a",{parentName:"li",href:"#value-categories-and-value-phases"},"l-value")," may\nautomatically convert to a ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass")," r-value, the same way that a ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass"),"\nl-value can."),(0,i.kt)("li",{parentName:"ul"},"If member ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass")," has type ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),", then member ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"const MyClass"),"\nhas type ",(0,i.kt)("inlineCode",{parentName:"li"},"const T"),"."),(0,i.kt)("li",{parentName:"ul"},"The API of a ",(0,i.kt)("inlineCode",{parentName:"li"},"const MyClass")," is a subset of ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass"),", excluding all methods\ntaking ",(0,i.kt)("inlineCode",{parentName:"li"},"[addr me: Self*]"),".")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," binds more tightly than postfix-",(0,i.kt)("inlineCode",{parentName:"p"},"*")," for forming a pointer\ntype, so ",(0,i.kt)("inlineCode",{parentName:"p"},"const MyClass*")," is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"(const MyClass)*"),"."),(0,i.kt)("p",null,"This example uses the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Point")," from the\n",(0,i.kt)("a",{parentName:"p",href:"#methods"},'"methods" section'),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"var origin: Point = {.x = 0, .y = 0};\n\n// \u2705 Allowed conversion from `Point*` to\n// `const Point*`:\nlet p: const Point* = &origin;\n\n// \u2705 Allowed conversion of `const Point` l-value\n// to `Point` r-value.\nlet five: f32 = p->Distance(3, 4);\n\n// \u274c Error: mutating method `Offset` excluded\n// from `const Point` API.\np->Offset(3, 4);\n\n// \u274c Error: mutating method `AssignAdd.Op`\n// excluded from `const i32` API.\np->x += 2;\n")),(0,i.kt)("h4",{id:"unformed-state"},"Unformed state"),(0,i.kt)("p",null,"Types indicate that they support unformed states by\n",(0,i.kt)("a",{parentName:"p",href:"#interfaces-and-implementations"},"implementing a particular interface"),",\notherwise variables of that type must be explicitly initialized when they are\ndeclared."),(0,i.kt)("p",null,"An unformed state for an object is one that satisfies the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Assignment from a fully formed value is correct using the normal assignment\nimplementation for the type."),(0,i.kt)("li",{parentName:"ul"},"Destruction must be correct using the type's normal destruction\nimplementation."),(0,i.kt)("li",{parentName:"ul"},"Destruction must be optional. The behavior of the program must be equivalent\nwhether the destructor is run or not for an unformed object, including not\nleaking resources.")),(0,i.kt)("p",null,"A type might have more than one in-memory representation for the unformed state,\nand those representations may be the same as valid fully formed values for that\ntype. For example, all values are legal representations of the unformed state\nfor any type with a trivial destructor like ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),". Types may define additional\ninitialization for the ",(0,i.kt)("a",{parentName:"p",href:"#build-modes"},"hardened build mode"),". For example, this\ncauses integers to be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," when in unformed state in this mode."),(0,i.kt)("p",null,"Any operation on an unformed object ",(0,i.kt)("em",{parentName:"p"},"other")," than destruction or assignment from\na fully formed value is an error, even if its in-memory representation is that\nof a valid value for that type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/257"},"#257: Initialization of memory and variables")))),(0,i.kt)("h4",{id:"move"},"Move"),(0,i.kt)("p",null,"Carbon will allow types to define if and how they are moved. This can happen\nwhen returning a value from a function or by using the ",(0,i.kt)("em",{parentName:"p"},"move operator")," ",(0,i.kt)("inlineCode",{parentName:"p"},"~x"),".\nThis leaves ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," in an ",(0,i.kt)("a",{parentName:"p",href:"#unformed-state"},"unformed state")," and returns its old\nvalue."),(0,i.kt)("h4",{id:"mixins"},"Mixins"),(0,i.kt)("p",null,"Mixins allow reuse with different trade-offs compared to\n",(0,i.kt)("a",{parentName:"p",href:"#inheritance"},"inheritance"),". Mixins focus on implementation reuse, such as might\nbe done using\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"},"CRTP")," or\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Multiple_inheritance"},"multiple inheritance")," in\nC++."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"TODO:")," The design for mixins is still under development."),(0,i.kt)("h3",{id:"choice-types"},"Choice types"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"choice type")," is a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tagged_union"},"tagged union"),",\nthat can store different types of data in a storage space that can hold the\nlargest. A choice type has a name, and a list of cases separated by commas\n(",(0,i.kt)("inlineCode",{parentName:"p"},","),"). Each case has a name and an optional parameter list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"choice IntResult {\n  Success(value: i32),\n  Failure(error: String),\n  Cancelled\n}\n")),(0,i.kt)("p",null,"The value of a choice type is one of the cases, plus the values of the\nparameters to that case, if any. A value can be constructed by naming the case\nand providing values for the parameters, if any:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'fn ParseAsInt(s: String) -> IntResult {\n  var r: i32 = 0;\n  for (c: i32 in s) {\n    if (not IsDigit(c)) {\n      // Equivalent to `IntResult.Failure(...)`\n      return .Failure("Invalid character");\n    }\n    // ...\n  }\n  return .Success(r);\n}\n')),(0,i.kt)("p",null,"Choice type values may be consumed using a ",(0,i.kt)("a",{parentName:"p",href:"#match"},(0,i.kt)("inlineCode",{parentName:"a"},"match")," statement"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"match (ParseAsInt(s)) {\n  case .Success(value: i32) => {\n    return value;\n  }\n  case .Failure(error: String) => {\n    Display(error);\n  }\n  case .Cancelled => {\n    Terminate();\n  }\n}\n")),(0,i.kt)("p",null,"They can also represent an\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Enumerated_type"},"enumerated type"),", if no\nadditional data is associated with the choices, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"choice LikeABoolean { False, True }\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/157"},"#157: Design direction for sum types")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/162"},"#162: Basic Syntax")))),(0,i.kt)("h2",{id:"names"},"Names"),(0,i.kt)("p",null,"Names are introduced by ",(0,i.kt)("a",{parentName:"p",href:"#declarations-definitions-and-scopes"},"declarations")," and\nare valid until the end of the scope in which they appear. Code may not refer to\nnames earlier in the source than they are declared. In executable scopes such as\nfunction bodies, names declared later are not found. In declarative scopes such\nas packages, classes, and interfaces, it is an error to refer to names declared\nlater, except that inline class member function bodies are\n",(0,i.kt)("a",{parentName:"p",href:"#class-functions-and-factory-functions"},"parsed as if they appeared after the class"),"."),(0,i.kt)("p",null,"A name in Carbon is formed from a sequence of letters, numbers, and underscores,\nand starts with a letter. We intend to follow\n",(0,i.kt)("a",{parentName:"p",href:"https://unicode.org/reports/tr31/"},"Unicode's Annex 31")," in selecting valid\nidentifier characters, but a concrete set of valid characters has not been\nselected yet."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"lexical_conventions"},"Lexical conventions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/project/principles/information_accumulation"},"Principle: Information accumulation")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/142"},"#142: Unicode source files")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/472"},"#472: Open question: Calling functions defined later in the same file")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/875"},"#875: Principle: information accumulation")))),(0,i.kt)("h3",{id:"files-libraries-packages"},"Files, libraries, packages"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Files")," are grouped into libraries, which are in turn grouped into\npackages."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Libraries")," are the granularity of code reuse through imports."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Packages")," are the unit of distribution.")),(0,i.kt)("p",null,"Each library must have exactly one ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," file. This file includes declarations\nfor all public names of the library. Definitions for those declarations must be\nin some file in the library, either the ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," file or an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," file."),(0,i.kt)("p",null,"Every package has its own namespace. This means libraries within a package need\nto coordinate to avoid name conflicts, but not across packages."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"code_and_name_organization"},"Code and name organization")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/107"},"#107: Code and name organization")))),(0,i.kt)("h3",{id:"package-declaration"},"Package declaration"),(0,i.kt)("p",null,"Files start with an optional package declaration, consisting of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"package")," keyword introducer,"),(0,i.kt)("li",{parentName:"ul"},"an optional identifier specifying the package name,"),(0,i.kt)("li",{parentName:"ul"},"optional ",(0,i.kt)("inlineCode",{parentName:"li"},"library")," followed by a string with the library name,"),(0,i.kt)("li",{parentName:"ul"},"either ",(0,i.kt)("inlineCode",{parentName:"li"},"api")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"impl"),", and"),(0,i.kt)("li",{parentName:"ul"},"a terminating semicolon (",(0,i.kt)("inlineCode",{parentName:"li"},";"),").")),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// Package name is `Geometry`.\n// Library name is "Shapes".\n// This file is an `api` file, not an `impl` file.\npackage Geometry library "Shapes" api;\n')),(0,i.kt)("p",null,"Parts of this declaration may be omitted:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the package name is omitted, as in ",(0,i.kt)("inlineCode",{parentName:"li"},'package library "Main" api;'),", the\nfile contributes to the default package. No other package may import from\nthe default package."),(0,i.kt)("li",{parentName:"ul"},"If the library keyword is not specified, as in ",(0,i.kt)("inlineCode",{parentName:"li"},"package Geometry api;"),", this\nfile contributes to the default library."),(0,i.kt)("li",{parentName:"ul"},"If a file has no package declaration at all, it is the ",(0,i.kt)("inlineCode",{parentName:"li"},"api")," file belonging\nto the default package and default library. This is particularly for tests\nand smaller examples. No other library can import this library even from\nwithin the default package. It can be split across multiple ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," files\nusing a ",(0,i.kt)("inlineCode",{parentName:"li"},"package impl;")," package declaration.")),(0,i.kt)("p",null,"A program need not use the default package, but if it does, it should contain\nthe entry-point function. By default, the entry-point function is ",(0,i.kt)("inlineCode",{parentName:"p"},"Run")," from the\ndefault package."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"code_and_name_organization"},"Code and name organization")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/107"},"#107: Code and name organization")))),(0,i.kt)("h3",{id:"imports"},"Imports"),(0,i.kt)("p",null,"After the package declaration, files may include ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," declarations. These\ninclude the package name and optionally ",(0,i.kt)("inlineCode",{parentName:"p"},"library")," followed by the library name.\nIf the library is omitted, the default library for that package is imported."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// Import the "Vector" library from the\n// `LinearAlgebra` package.\nimport LinearAlgebra library "Vector";\n// Import the default library from the\n// `ArbitraryPrecision` package.\nimport ArbitraryPrecision;\n')),(0,i.kt)("p",null,"The syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"import PackageName ...")," introduces the name ",(0,i.kt)("inlineCode",{parentName:"p"},"PackageName")," as a\n",(0,i.kt)("a",{parentName:"p",href:"#name-visibility"},(0,i.kt)("inlineCode",{parentName:"a"},"private"))," name naming the given package. It cannot be used\nto import libraries of the current package. Importing additional libraries from\nthat package makes additional members of ",(0,i.kt)("inlineCode",{parentName:"p"},"PackageName")," visible."),(0,i.kt)("p",null,"Libraries from the current package are imported by omitting the package name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// Import the "Vertex" library from the same package.\nimport library "Vertex";\n// Import the default library from the same package.\nimport library default;\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"import library ...")," syntax adds all the public top-level names within the\ngiven library to the top-level scope of the current file as\n",(0,i.kt)("a",{parentName:"p",href:"#name-visibility"},(0,i.kt)("inlineCode",{parentName:"a"},"private"))," names, and similarly for names in\n",(0,i.kt)("a",{parentName:"p",href:"#namespaces"},"namespaces"),"."),(0,i.kt)("p",null,"Every ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," file automatically imports the ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," file for its library."),(0,i.kt)("p",null,"All ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," declarations must appear before all other non-",(0,i.kt)("inlineCode",{parentName:"p"},"package"),"\ndeclarations in the file."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"code_and_name_organization"},"Code and name organization")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/107"},"#107: Code and name organization")))),(0,i.kt)("h3",{id:"name-visibility"},"Name visibility"),(0,i.kt)("p",null,"The names visible from an imported library are determined by these rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Declarations in an ",(0,i.kt)("inlineCode",{parentName:"li"},"api")," file are by default ",(0,i.kt)("em",{parentName:"li"},"public"),", which means visible\nto any file that imports that library. This matches class members, which are\nalso ",(0,i.kt)("a",{parentName:"li",href:"#access-control"},"default public"),"."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," prefix on a declaration in an ",(0,i.kt)("inlineCode",{parentName:"li"},"api")," file makes the name ",(0,i.kt)("em",{parentName:"li"},"library\nprivate"),". This means the name is visible in the file and all ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," files\nfor the same library."),(0,i.kt)("li",{parentName:"ul"},"The visibility of a name is determined by its first declaration, considering\n",(0,i.kt)("inlineCode",{parentName:"li"},"api")," files before ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," files. The ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," prefix is only allowed on the\nfirst declaration."),(0,i.kt)("li",{parentName:"ul"},"A name declared in an ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," file and not the corresponding ",(0,i.kt)("inlineCode",{parentName:"li"},"api")," file is\n",(0,i.kt)("em",{parentName:"li"},"file private"),", meaning visible in just that file. Its first declaration\nmust be marked with a ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," prefix. ",(0,i.kt)("strong",{parentName:"li"},"TODO:")," This needs to be finalized\nin a proposal to resolve inconsistency between\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/665#issuecomment-914661914"},"#665"),"\nand ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1136"},"#1136"),"."),(0,i.kt)("li",{parentName:"ul"},"Private names don't conflict with names outside the region they're private\nto: two different libraries can have different private names ",(0,i.kt)("inlineCode",{parentName:"li"},"foo")," without\nconflict, but a private name conflicts with a public name in the same scope.")),(0,i.kt)("p",null,"At most one ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," file in a package transitively used in a program may declare a\ngiven name public."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/code_and_name_organization/#exporting-entities-from-an-api-file"},"Exporting entities from an API file")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/665"},"#665: ",(0,i.kt)("inlineCode",{parentName:"a"},"private")," vs ",(0,i.kt)("inlineCode",{parentName:"a"},"public")," ",(0,i.kt)("em",{parentName:"a"},"syntax")," strategy, as well as other visibility tools like ",(0,i.kt)("inlineCode",{parentName:"a"},"external"),"/",(0,i.kt)("inlineCode",{parentName:"a"},"api"),"/etc.")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/752"},"#752: api file default public")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/931"},"#931: Generic impls access (details 4)")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1136"},"#1136: what is the top-level scope in a source file, and what names are found there?")))),(0,i.kt)("h3",{id:"package-scope"},"Package scope"),(0,i.kt)("p",null,"The top-level scope in a package is the scope of the package. This means:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Within this scope (and its sub-namespaces), all visible names from the same\npackage appear. This includes names from the same file, names from the ",(0,i.kt)("inlineCode",{parentName:"li"},"api"),"\nfile of a library when inside an ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," file, and names from imported\nlibraries of the same package."),(0,i.kt)("li",{parentName:"ul"},"In scopes where package members might have a name conflict with something\nelse, the syntax ",(0,i.kt)("inlineCode",{parentName:"li"},"package.Foo")," can be used to name the ",(0,i.kt)("inlineCode",{parentName:"li"},"Foo")," member of the\ncurrent package.")),(0,i.kt)("p",null,"In this example, the names ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," are used in a scope where they could mean\ntwo different things, and\n",(0,i.kt)("a",{parentName:"p",href:"#name-lookup"},"qualifications are needed to disambiguate"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"import P;\nfn F();\nclass C {\n  fn F();\n  class P {\n    fn H();\n  }\n  fn G() {\n    // \u274c Error: ambiguous whether `F` means\n    // `package.F` or `package.C.F`.\n    F();\n   // \u2705 Allowed: fully qualified\n    package.F();\n    package.C.F();\n    // \u2705 Allowed: unambiguous\n    C.F();\n    // \u274c Error: ambiguous whether `P` means\n    // `package.P` or `package.P.F`.\n    P.H();\n    // \u2705 Allowed\n    package.P.H();\n    package.C.P.H();\n    C.P.H();\n  }\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"code_and_name_organization"},"Code and name organization")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/107"},"#107: Code and name organization")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/752"},"#752: api file default public")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1136"},"#1136: what is the top-level scope in a source file, and what names are found there?")))),(0,i.kt)("h3",{id:"namespaces"},"Namespaces"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace")," declaration defines a name that may be used as a prefix of names\ndeclared afterward. When defining a member of a namespace, other members of that\nnamespace are considered in scope and may be found by\n",(0,i.kt)("a",{parentName:"p",href:"#name-lookup"},"name lookup")," without the namespace prefix. In this example,\npackage ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," defines some of its members inside a namespace ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"package P api;\n\n// Defines namespace `N` within the current package.\nnamespace N;\n\n// Defines namespaces `M` and `M.L`.\nnamespace M.L;\n\nfn F();\n// \u2705 Allowed: Declares function `G` in namespace `N`.\nprivate fn N.G();\n// \u274c Error: `Bad` hasn't been declared.\nfn Bad.H();\n\nfn J() {\n  // \u274c Error: No `package.G`\n  G();\n}\n\nfn N.K() {\n  // \u2705 Allowed: Looks in both `package` and `package.N`.\n  // Finds `package.F` and `package.N.G`.\n  F();\n  G();\n}\n\n// \u2705 Allowed: Declares function `R` in namespace `M.L`.\nfn M.L.R();\n// \u2705 Allowed: Declares function `Q` in namespace `M`.\nfn M.Q();\n")),(0,i.kt)("p",null,"Another package importing ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," can refer to the public members of that namespace\nby prefixing with the package name ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," followed by the namespace:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"import P;\n\n// \u2705 Allowed: `F` is public member of `P`.\nP.F();\n// \u274c Error: `N.G` is a private member of `P`.\nP.N.G();\n// \u2705 Allowed: `N.K` is public member of `P`.\nP.N.K();\n// \u2705 Allowed: `M.L.R` is public member of `P`.\nP.M.L.R();\n// \u2705 Allowed: `M.Q` is public member of `P`.\nP.M.Q();\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/code_and_name_organization/#namespaces"},'"Namespaces" in "Code and name organization"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/member_access#package-and-namespace-members"},'"Package and namespace members" in "Qualified names and member access"')))),(0,i.kt)("h3",{id:"naming-conventions"},"Naming conventions"),(0,i.kt)("p",null,"Our naming conventions are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For idiomatic Carbon code:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"UpperCamelCase")," will be used when the named entity cannot have a\ndynamically varying value. For example, functions, namespaces, or\ncompile-time constant values. Note that\n",(0,i.kt)("a",{parentName:"li",href:"#inheritance"},(0,i.kt)("inlineCode",{parentName:"a"},"virtual")," methods")," are named the same way to be\nconsistent with other functions and methods."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lower_snake_case")," will be used when the named entity's value won't be\nknown until runtime, such as for variables."))),(0,i.kt)("li",{parentName:"ul"},"For Carbon-provided features:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Keywords and type literals will use ",(0,i.kt)("inlineCode",{parentName:"li"},"lower_snake_case"),"."),(0,i.kt)("li",{parentName:"ul"},"Other code will use the conventions for idiomatic Carbon code.")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/naming_conventions"},"Naming conventions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/861"},"#861: Naming conventions")))),(0,i.kt)("h3",{id:"aliases"},"Aliases"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"alias")," declares a name as equivalent to another name, for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"alias NewName = SomePackage.OldName;\n")),(0,i.kt)("p",null,"Note that the right-hand side of the equal sign (",(0,i.kt)("inlineCode",{parentName:"p"},"="),") is a name not a value, so\n",(0,i.kt)("inlineCode",{parentName:"p"},"alias four = 4;")," is not allowed. This allows ",(0,i.kt)("inlineCode",{parentName:"p"},"alias")," to work with entities like\nnamespaces, which aren't values in Carbon."),(0,i.kt)("p",null,"This can be used during an incremental migration when changing a name, or to\ninclude a name in a public API. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"alias")," may be used to include a\nname from an interface implementation as a member of a class or\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#named-constraints"},"named constraint"),", possibly renamed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class ContactInfo {\n  external impl as Printable;\n  external impl as ToPrinterDevice;\n  alias PrintToScreen = Printable.Print;\n  alias PrintToPrinter = ToPrinterDevice.Print;\n  ...\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/aliases"},"Aliases")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/code_and_name_organization/#aliasing"},'"Aliasing" in "Code and name organization"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#external-impl"},(0,i.kt)("inlineCode",{parentName:"a"},"alias")," a name from an external impl")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#named-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"alias")," a name in a named constraint")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"#553: Generics details part 1")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/749"},"#749: Alias syntax")))),(0,i.kt)("h3",{id:"name-lookup"},"Name lookup"),(0,i.kt)("p",null,"The general principle of Carbon name lookup is that we look up names in all\nrelevant scopes, and report an error if the name is found to refer to more than\none different entity. So Carbon requires disambiguation by adding qualifiers\ninstead of doing any\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Variable_shadowing"},"shadowing")," of names. For an\nexample, see ",(0,i.kt)("a",{parentName:"p",href:"#package-scope"},'the "package scope" section'),"."),(0,i.kt)("p",null,"Unqualified name lookup walks the semantically-enclosing scopes, not only the\nlexically-enclosing ones. So when a lookup is performed within\n",(0,i.kt)("inlineCode",{parentName:"p"},"fn MyNamespace.MyClass.MyNestedClass.MyFunction()"),", we will look in\n",(0,i.kt)("inlineCode",{parentName:"p"},"MyNestedClass"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MyClass"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MyNamespace"),", and the package scope, even when the\nlexically-enclosing scope is the package scope. This means that the definition\nof a method will look for names in the class' scope even if it is written\nlexically out of line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class C {\n  fn F();\n  fn G();\n}\nfn C.G() {\n  // \u2705 Allowed: resolves to `package.C.F`.\n  F();\n}\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access"},"Member name lookup")," follows a similar philosophy.\nIf a ",(0,i.kt)("a",{parentName:"p",href:"#checked-and-template-parameters"},"checked-generic type parameter")," is known\nto implement multiple interfaces due to a constraint using\n",(0,i.kt)("a",{parentName:"p",href:"#combining-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"&"))," or\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#where-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"where")," clauses"),", member name lookup\ninto that type will look in all of the interfaces. If it is found in multiple,\nthe name must be disambiguated by qualifying using compound member access\n(",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#qualified-member-names-and-compound-member-access"},"2"),"). A\n",(0,i.kt)("a",{parentName:"p",href:"#checked-and-template-parameters"},"template-generic type parameter")," performs\nlook up into the caller's type in addition to the constraint."),(0,i.kt)("p",null,"Carbon also rejects cases that would be invalid if all declarations in the file,\nincluding ones appearing later, were visible everywhere, not only after their\npoint of appearance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class C {\n  fn F();\n  fn G();\n}\nfn C.G() {\n  F();\n}\n// Error: use of `F` in `C.G` would be ambiguous\n// if this declaration was earlier.\nfn F();\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/name_lookup"},"Name lookup")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/#qualified-names-and-member-access"},'"Qualified names and member access" section of "Expressions"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/member_access"},"Qualified names and member access")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/project/principles/information_accumulation"},"Principle: Information accumulation")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/875"},"#875: Principle: information accumulation")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/989"},"#989: Member access expressions")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1136"},"#1136: what is the top-level scope in a source file, and what names are found there?")))),(0,i.kt)("h4",{id:"name-lookup-for-common-types"},"Name lookup for common types"),(0,i.kt)("p",null,'Common types that we expect to be used universally will be provided for every\nfile are made available as if there was a special "prelude" package that was\nimported automatically into every ',(0,i.kt)("inlineCode",{parentName:"p"},"api")," file. Dedicated type literal syntaxes\nlike ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," refer to types defined within this package, based on the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/principles/library_apis_only"},'"all APIs are library APIs" principle'),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/name_lookup"},"Name lookup")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/project/principles/library_apis_only"},"Principle: All APIs are library APIs")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/750"},"#750: Naming conventions for Carbon-provided features")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1058"},"#1058: How should interfaces for core functionality be named?")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1280"},"#1280: Principle: All APIs are library APIs")))),(0,i.kt)("h2",{id:"generics"},"Generics"),(0,i.kt)("p",null,"Generics allow Carbon constructs like ",(0,i.kt)("a",{parentName:"p",href:"#functions"},"functions")," and\n",(0,i.kt)("a",{parentName:"p",href:"#classes"},"classes")," to be written with compile-time parameters and apply\ngenerically to different types using those parameters. For example, this ",(0,i.kt)("inlineCode",{parentName:"p"},"Min"),"\nfunction has a type parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," that can be any type that implements the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Ordered")," interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'fn Min[T:! Ordered](x: T, y: T) -> T {\n  // Can compare `x` and `y` since they have\n  // type `T` known to implement `Ordered`.\n  return if x <= y then x else y;\n}\n\nvar a: i32 = 1;\nvar b: i32 = 2;\n// `T` is deduced to be `i32`\nAssert(Min(a, b) == 1);\n// `T` is deduced to be `String`\nAssert(Min("abc", "xyz") == "abc");\n')),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," type parameter is in the deduced parameter list in square brackets\n(",(0,i.kt)("inlineCode",{parentName:"p"},"["),"...",(0,i.kt)("inlineCode",{parentName:"p"},"]"),") before the explicit parameter list in parentheses (",(0,i.kt)("inlineCode",{parentName:"p"},"("),"...",(0,i.kt)("inlineCode",{parentName:"p"},")"),"), the\nvalue of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is determined from the types of the explicit arguments instead of\nbeing passed as a separate explicit argument."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("strong",{parentName:"p"},"TODO:")," Revisit"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/overview"},"Generics: Overview")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/524"},"#524: Generics overview")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"#553: Generics details part 1")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/950"},"#950: Generic details 6: remove facets")))),(0,i.kt)("h3",{id:"checked-and-template-parameters"},"Checked and template parameters"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},":!")," indicates that ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is a ",(0,i.kt)("em",{parentName:"p"},"checked"),' parameter passed at compile time.\n"Checked" here means that the body of ',(0,i.kt)("inlineCode",{parentName:"p"},"Min")," is type checked when the function is\ndefined, independent of the specific type values ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is instantiated with, and\nname lookup is delegated to the constraint on ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," (",(0,i.kt)("inlineCode",{parentName:"p"},"Ordered")," in this case). This\ntype checking is equivalent to saying the function would pass type checking\ngiven any type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," that implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ordered")," interface. Then calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"Min"),"\nonly need to check that the deduced type value of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Ordered"),"."),(0,i.kt)("p",null,"The parameter could alternatively be declared to be a ",(0,i.kt)("em",{parentName:"p"},"template")," parameter by\nprefixing with the ",(0,i.kt)("inlineCode",{parentName:"p"},"template")," keyword, as in ",(0,i.kt)("inlineCode",{parentName:"p"},"template T:! Type"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Convert[template T:! Type](source: T, template U:! Type) -> U {\n  var converted: U = source;\n  return converted;\n}\n\nfn Foo(i: i32) -> f32 {\n  // Instantiates with the `T` implicit argument set to `i32` and the `U`\n  // explicit argument set to `f32`, then calls with the runtime value `i`.\n  return Convert(i, f32);\n}\n")),(0,i.kt)("p",null,"Carbon templates follow the same fundamental paradigm as\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Template_(C%2B%2B)"},"C++ templates"),": they are\ninstantiated when called, resulting in late type checking, duck typing, and lazy\nbinding."),(0,i.kt)("p",null,"One difference from C++ templates, Carbon template instantiation is not\ncontrolled by the SFINAE rule of C++\n(",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/sfinae"},"2"),") but by explicit ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),"\nclauses evaluated at compile-time. The ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," clause is at the end of the\ndeclaration, and the condition can only use constant values known at\ntype-checking time, including ",(0,i.kt)("inlineCode",{parentName:"p"},"template")," parameters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Array(template T:! Type, template N:! i64)\n    if N >= 0 and N < MaxArraySize / sizeof(T);\n")),(0,i.kt)("p",null,"Member lookup into a template type parameter is done in the actual type value\nprovided by the caller, ",(0,i.kt)("em",{parentName:"p"},"in addition")," to any constraints. This means member name\nlookup and type checking for anything\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology#dependent-names"},"dependent")," on the template parameter\ncan't be completed until the template is instantiated with a specific concrete\ntype. When the constraint is just ",(0,i.kt)("inlineCode",{parentName:"p"},"Type"),", this gives semantics similar to C++\ntemplates. Constraints can then be added incrementally, with the compiler\nverifying that the semantics stay the same. Once all constraints have been\nadded, removing the word ",(0,i.kt)("inlineCode",{parentName:"p"},"template")," to switch to a checked parameter is safe."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"#value-categories-and-value-phases"},"value phase")," of a checked parameter is\na symbolic value whereas the value phase of a template parameter is constant."),(0,i.kt)("p",null,"Although checked generics are generally preferred, templates enable translation\nof code between C++ and Carbon, and address some cases where the type checking\nrigor of generics are problematic."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/templates"},"Templates")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"#553: Generics details part 1")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/949"},"#949: Constrained template name lookup")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/989"},"#989: Member access expressions")))),(0,i.kt)("h3",{id:"interfaces-and-implementations"},"Interfaces and implementations"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Interfaces")," specify a set of requirements that a types might satisfy.\nInterfaces act both as constraints on types a caller might supply and\ncapabilities that may be assumed of types that satisfy that constraint."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'interface Printable {\n  // Inside an interface definition `Self` means\n  // "the type implementing this interface".\n  fn Print[me: Self]();\n}\n')),(0,i.kt)("p",null,"In addition to function requirements, interfaces can contain:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#interface-requiring-other-interfaces"},"requirements that other interfaces be implemented"),"\nor\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#interface-extension"},"interfaces that this interface extends")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#associated-types"},"associated types")," and other\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#associated-constants"},"associated constants")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#interface-defaults"},"interface defaults")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#final-members"},(0,i.kt)("inlineCode",{parentName:"a"},"final")," interface members"))),(0,i.kt)("p",null,"Types only implement an interface if there is an explicit ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declaration\nthat they do. Simply having a ",(0,i.kt)("inlineCode",{parentName:"p"},"Print")," function with the right signature is not\nsufficient."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'class Circle {\n  var radius: f32;\n\n  impl as Printable {\n    fn Print[me: Self]() {\n      Console.WriteLine("Circle with radius: {0}", me.radius);\n    }\n  }\n}\n')),(0,i.kt)("p",null,"In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"Print")," is a member of ",(0,i.kt)("inlineCode",{parentName:"p"},"Circle"),". Interfaces may also be\nimplemented ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#external-impl"},"externally"),", which means the\nmembers of the interface are not direct members of the type. Those methods may\nstill be called using compound member access syntax\n(",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#qualified-member-names-and-compound-member-access"},"2"),") to\nqualify the name of the member, as in ",(0,i.kt)("inlineCode",{parentName:"p"},"x.(Printable.Print)()"),". External\nimplementations don't have to be in the same library as the type definition,\nsubject to the orphan rule (",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#impl-lookup"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#orphan-rule"},"2"),") for\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology#coherence"},"coherence"),"."),(0,i.kt)("p",null,"Interfaces and implementations may be\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#forward-declarations-and-cyclic-references"},"forward declared"),"\nby replacing the definition scope in curly braces (",(0,i.kt)("inlineCode",{parentName:"p"},"{"),"...",(0,i.kt)("inlineCode",{parentName:"p"},"}"),") with a semicolon."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#interfaces"},"Generics: Interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#implementing-interfaces"},"Generics: Implementing interfaces")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"#553: Generics details part 1")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/731"},"#731: Generics details 2: adapters, associated types, parameterized interfaces")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/624"},"#624: Coherence: terminology, rationale, alternatives considered")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/990"},"#990: Generics details 8: interface default and final members")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1084"},"#1084: Generics details 9: forward declarations")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1132"},"#1132: How do we match forward declarations with their definitions?")))),(0,i.kt)("h3",{id:"combining-constraints"},"Combining constraints"),(0,i.kt)("p",null,"A function can require calling types to implement multiple interfaces by\ncombining them using an ampersand (",(0,i.kt)("inlineCode",{parentName:"p"},"&"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn PrintMin[T:! Ordered & Printable](x: T, y: T) {\n  // Can compare since type `T` implements `Ordered`.\n  if (x <= y) {\n    // Can call `Print` since type `T` implements `Printable`.\n    x.Print();\n  } else {\n    y.Print();\n  }\n}\n")),(0,i.kt)("p",null,"The body of the function may call functions that are in either interface, except\nfor names that are members of both. In that case, use the compound member access\nsyntax (",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#qualified-member-names-and-compound-member-access"},"2"),") to\nqualify the name of the member, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn DrawTies[T:! Renderable & GameResult](x: T) {\n  if (x.(GameResult.Draw)()) {\n    x.(Renderable.Draw)();\n  }\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#combining-interfaces-by-anding-type-of-types"},"Combining interfaces by anding type-of-types")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/531"},"#531: Combine interfaces with ",(0,i.kt)("inlineCode",{parentName:"a"},"+")," or ",(0,i.kt)("inlineCode",{parentName:"a"},"&"))),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"#553: Generics details part 1")))),(0,i.kt)("h3",{id:"associated-types"},"Associated types"),(0,i.kt)("p",null,"An associated type is a type member of an interface whose value is determined by\nthe implementation of that interface for a specific type. These values are set\nto compile-time values in implementations, and so use the\n",(0,i.kt)("a",{parentName:"p",href:"#checked-and-template-parameters"},(0,i.kt)("inlineCode",{parentName:"a"},":!")," generic syntax")," inside a\n",(0,i.kt)("a",{parentName:"p",href:"#constant-let-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"let")," declaration")," without an initializer. This\nallows types in the signatures of functions in the interface to vary. For\nexample, an interface describing a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"},"stack")," might use an\nassociated type to represent the type of elements stored in the stack."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface StackInterface {\n  let ElementType:! Movable;\n  fn Push[addr me: Self*](value: ElementType);\n  fn Pop[addr me: Self*]() -> ElementType;\n  fn IsEmpty[addr me: Self*]() -> bool;\n}\n")),(0,i.kt)("p",null,"Then different types implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"StackInterface")," can specify different type\nvalues for the ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," member of the interface using a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class IntStack {\n  impl as StackInterface where .ElementType == i32 {\n    fn Push[addr me: Self*](value: i32);\n    // ...\n  }\n}\n\nclass FruitStack {\n  impl as StackInterface where .ElementType == Fruit {\n    fn Push[addr me: Self*](value: Fruit);\n    // ...\n  }\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#associated-types"},"Generics: Associated types")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/731"},"#731: Generics details 2: adapters, associated types, parameterized interfaces")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1013"},"#1013: Generics: Set associated constants using ",(0,i.kt)("inlineCode",{parentName:"a"},"where")," constraints")))),(0,i.kt)("h3",{id:"generic-entities"},"Generic entities"),(0,i.kt)("p",null,"Many Carbon entities, not just functions, may be made generic by adding\n",(0,i.kt)("a",{parentName:"p",href:"#checked-and-template-parameters"},"checked or template parameters"),"."),(0,i.kt)("h4",{id:"generic-classes"},"Generic Classes"),(0,i.kt)("p",null,"Classes may be defined with an optional explicit parameter list. All parameters\nto a class must be generic, and so defined with ",(0,i.kt)("inlineCode",{parentName:"p"},":!"),", either with or without the\n",(0,i.kt)("inlineCode",{parentName:"p"},"template")," prefix. For example, to define a stack that can hold values of any\ntype ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"class Stack(T:! Type) {\n  fn Push[addr me: Self*](value: T);\n  fn Pop[addr me: Self*]() -> T;\n\n  var storage: Array(T);\n}\n\nvar int_stack: Stack(i32);\n")),(0,i.kt)("p",null,"In this example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Stack")," is a type parameterized by a type ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"T")," may be used within the definition of ",(0,i.kt)("inlineCode",{parentName:"li"},"Stack")," anywhere a normal type\nwould be used."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Array(T)")," instantiates generic type ",(0,i.kt)("inlineCode",{parentName:"li"},"Array")," with its parameter set to ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Stack(i32)")," instantiates ",(0,i.kt)("inlineCode",{parentName:"li"},"Stack")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," set to ",(0,i.kt)("inlineCode",{parentName:"li"},"i32"),".")),(0,i.kt)("p",null,"The values of type parameters are part of a type's value, and so may be deduced\nin a function call, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn PeekTopOfStack[T:! Type](s: Stack(T)*) -> T {\n  var top: T = s->Pop();\n  s->Push(top);\n  return top;\n}\n\n// `int_stack` has type `Stack(i32)`, so `T` is deduced to be `i32`.\nPeekTopOfStack(&int_stack);\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#parameterized-types"},"Generic or parameterized types")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1146"},"#1146: Generic details 12: parameterized types")))),(0,i.kt)("h4",{id:"generic-choice-types"},"Generic choice types"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#choice-types"},"Choice types")," may be parameterized similarly to classes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"choice Result(T:! Type, Error:! Type) {\n  Success(value: T),\n  Failure(error: Error)\n}\n")),(0,i.kt)("h4",{id:"generic-interfaces"},"Generic interfaces"),(0,i.kt)("p",null,"Interfaces are always parameterized by a ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type, but in some cases they\nwill have additional parameters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"interface AddWith(U:! Type);\n")),(0,i.kt)("p",null,"Interfaces without parameters may only be implemented once for a given type, but\na type can have distinct implementations of ",(0,i.kt)("inlineCode",{parentName:"p"},"AddWith(i32)")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"AddWith(BigInt)"),"."),(0,i.kt)("p",null,"Parameters to an interface ",(0,i.kt)("em",{parentName:"p"},"determine")," which implementation is selected for a\ntype, in contrast to ",(0,i.kt)("a",{parentName:"p",href:"#associated-types"},"associated types")," which are ",(0,i.kt)("em",{parentName:"p"},"determined\nby")," the implementation of an interface for a type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#parameterized-interfaces"},"Generic or parameterized interfaces")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/731"},"#731: Generics details 2: adapters, associated types, parameterized interfaces")))),(0,i.kt)("h4",{id:"generic-implementations"},"Generic implementations"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declaration may be parameterized by adding ",(0,i.kt)("inlineCode",{parentName:"p"},"forall ["),(0,i.kt)("em",{parentName:"p"},"generic\nparameter list"),(0,i.kt)("inlineCode",{parentName:"p"},"]")," after the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," keyword introducer, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"external impl forall [T:! Printable] Vector(T) as Printable;\nexternal impl forall [Key:! Hashable, Value:! Type]\n    HashMap(Key, Value) as Has(Key);\nexternal impl forall [T:! Ordered] T as PartiallyOrdered;\nexternal impl forall [T:! ImplicitAs(i32)] BigInt as AddWith(T);\nexternal impl forall [U:! Type, T:! As(U)]\n    Optional(T) as As(Optional(U));\n")),(0,i.kt)("p",null,"Generic implementations can create a situation where multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," definitions\napply to a given type and interface query. The\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#lookup-resolution-and-specialization"},"specialization")," rules\npick which definition is selected. These rules ensure:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implementations have ",(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/terminology#coherence"},"coherence"),", so the\nsame implementation is always selected for a given query."),(0,i.kt)("li",{parentName:"ul"},"Libraries will work together as long as they pass their separate checks."),(0,i.kt)("li",{parentName:"ul"},"A generic function can assume that some impl will be successfully selected\nif it can see an impl that applies, even though another more specific impl\nmay be selected.")),(0,i.kt)("p",null,"Implementations may be marked ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#final-impls"},(0,i.kt)("inlineCode",{parentName:"a"},"final"))," to\nindicate that they may not be specialized, subject to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#libraries-that-can-contain-final-impls"},"some restrictions"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#parameterized-impls"},"Generic or parameterized impls")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/624"},"#624: Coherence: terminology, rationale, alternatives considered")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/920"},"#920: Generic parameterized impls (details 5)")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/983"},"#983: Generics details 7: final impls")))),(0,i.kt)("h3",{id:"other-features"},"Other features"),(0,i.kt)("p",null,"Carbon generics have a number of other features, including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#named-constraints"},"Named constraints")," may be used to\ndisambiguate when combining two interfaces that have name conflicts. Named\nconstraints may be implemented and otherwise used in place of an interface."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#named-constraints"},"Template constraints")," are a kind of\nnamed constraint that can contain structural requirements. For example, a\ntemplate constraint could match any type that has a function with a specific\nname and signature without any explicit declaration that the type implements\nthe constraint. Template constraints may only be used as requirements for\ntemplate parameters."),(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#adapting-types"},"adapter type")," is a type with the\nsame data representation as an existing type, so you may cast between the\ntwo types, but can implement different interfaces or implement interfaces\ndifferently."),(0,i.kt)("li",{parentName:"ul"},"Additional requirements can be placed on the associated types of an\ninterface using\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#where-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"where")," constraints"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#implied-constraints"},"Implied constraints")," allows some\nconstraints to be deduced and omitted from a function signature."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#runtime-type-fields"},"Dynamic erased types")," can hold any\nvalue with a type implementing an interface, and allows the functions in\nthat interface to be called using\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Dynamic_dispatch"},"dynamic dispatch"),', for some\ninterfaces marked "',(0,i.kt)("inlineCode",{parentName:"li"},"dyn"),'-safe".'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#variadic-arguments"},"Variadics")," supports variable-length\nparameter lists.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details"},"Generics details")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"#553: Generics details part 1")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/731"},"#731: Generics details 2: adapters, associated types, parameterized interfaces")))),(0,i.kt)("blockquote",null,(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/818"},"#818: Constraints for generics (generics details 3)")))),(0,i.kt)("h3",{id:"generic-type-equality-and-observe-declarations"},"Generic type equality and ",(0,i.kt)("inlineCode",{parentName:"h3"},"observe")," declarations"),(0,i.kt)("p",null,"Determining whether two types must be equal in a generic context is in general\nundecidable, as\n",(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/swift-type-checking-is-undecidable/39024"},"has been shown in Swift"),"."),(0,i.kt)("p",null,"To make compilation fast, the Carbon compiler will limit its search to a depth\nof 1, only identifying types as equal if there is an explicit declaration that\nthey are equal in the code, such as in a\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#where-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"where")," constraint"),". There will be\nsituations where two types must be equal as the result of combining these facts,\nbut the compiler will return a type error since it did not realize they are\nequal due to the limit of the search. An\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#observe-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"observe"),"...",(0,i.kt)("inlineCode",{parentName:"a"},"==")," declaration")," may be\nadded to describe how two types are equal, allowing more code to pass type\nchecking."),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declaration showing types are equal can increase the set of\ninterfaces the compiler knows that a type implements. It is also possible that\nknowing a type implements one interface implies that it implements another, from\nan\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#interface-requiring-other-interfaces"},"interface requirement"),"\nor ",(0,i.kt)("a",{parentName:"p",href:"#generic-implementations"},"generic implementation"),". An ",(0,i.kt)("inlineCode",{parentName:"p"},"observe"),"...",(0,i.kt)("inlineCode",{parentName:"p"},"is"),"\ndeclaration may be used to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#observing-a-type-implements-an-interface"},"observe that a type implements an interface"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#observe-declarations"},"Generics: ",(0,i.kt)("inlineCode",{parentName:"a"},"observe")," declarations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#observing-a-type-implements-an-interface"},"Generics: Observing a type implements an interface")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/818"},"#818: Constraints for generics (generics details 3)")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1088"},"#1088: Generic details 10: interface-implemented requirements")))),(0,i.kt)("h3",{id:"operator-overloading"},"Operator overloading"),(0,i.kt)("p",null,"Uses of an operator in an ",(0,i.kt)("a",{parentName:"p",href:"#expressions"},"expression")," is translated into a call\nto a method of an interface. For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," has type\n",(0,i.kt)("inlineCode",{parentName:"p"},"U"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"x + y")," is translated into a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"x.(AddWith(U).Op)(y)"),". So\noverloading of the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator is accomplished by implementing interface\n",(0,i.kt)("inlineCode",{parentName:"p"},"AddWith(U)")," for type ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". In order to support\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicit conversion")," of the first operand\nto type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," and the second argument to type ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),", add the ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," keyword to both\ntypes in the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declaration, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"external impl like T as AddWith(like U) where .Result == V {\n  // `Self` is `T` here\n  fn Op[me: Self](other: U) -> V { ... }\n}\n")),(0,i.kt)("p",null,"When the operand types and result type are all the same, this is equivalent to\nimplementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"external impl T as Add {\n  fn Op[me: Self](other: Self) -> Self { ... }\n}\n")),(0,i.kt)("p",null,"The interfaces that correspond to each operator are given by:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/arithmetic#extensibility"},"Arithmetic"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-x"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Negate")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x + y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Add")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"AddWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x - y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Sub")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"SubWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x * y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Mul")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"MulWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x / y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Div")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"DivWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x % y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Mod")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"ModWith(U)")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/bitwise#extensibility"},"Bitwise and shift operators"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"^x"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"BitComplement")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x & y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"BitAnd")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"BitAndWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x | y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"BitOr")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"BitOrWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x ^ y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"BitXor")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"BitXorWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x << y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"LeftShift")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"LeftShiftWith(U)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x >> y"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"RightShift")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"RightShiftWith(U)")))),(0,i.kt)("li",{parentName:"ul"},"Comparison:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x == y"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x != y")," overloaded by implementing\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/comparison_operators#equality"},(0,i.kt)("inlineCode",{parentName:"a"},"Eq")," or ",(0,i.kt)("inlineCode",{parentName:"a"},"EqWith(U)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x < y"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x > y"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x <= y"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x >= y")," overloaded by implementing\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/comparison_operators#ordering"},(0,i.kt)("inlineCode",{parentName:"a"},"Ordered")," or ",(0,i.kt)("inlineCode",{parentName:"a"},"OrderedWith(U)"))))),(0,i.kt)("li",{parentName:"ul"},"Conversion:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x as U")," is rewritten to use the\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/as_expressions#extensibility"},(0,i.kt)("inlineCode",{parentName:"a"},"As(U)"))," interface"),(0,i.kt)("li",{parentName:"ul"},"Implicit conversions use\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/implicit_conversions#extensibility"},(0,i.kt)("inlineCode",{parentName:"a"},"ImplicitAs(U)"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"TODO:")," ",(0,i.kt)("a",{parentName:"li",href:"#assignment-statements"},"Assignment"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"x = y"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"++x"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x += y"),",\nand so on"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"TODO:")," Dereference: ",(0,i.kt)("inlineCode",{parentName:"li"},"*p")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"TODO:")," ",(0,i.kt)("a",{parentName:"li",href:"#move"},"Move"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"~x")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"TODO:")," Indexing: ",(0,i.kt)("inlineCode",{parentName:"li"},"a[3]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"TODO:")," Function call: ",(0,i.kt)("inlineCode",{parentName:"li"},"f(4)"))),(0,i.kt)("p",null,"The\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/logical_operators#overloading"},"logical operators can not be overloaded"),"."),(0,i.kt)("p",null,"Operators that result in ",(0,i.kt)("a",{parentName:"p",href:"#value-categories-and-value-phases"},"l-values"),", such as\ndereferencing ",(0,i.kt)("inlineCode",{parentName:"p"},"*p")," and indexing ",(0,i.kt)("inlineCode",{parentName:"p"},"a[3]"),", have interfaces that return the address\nof the value. Carbon automatically dereferences the pointer to get the l-value."),(0,i.kt)("p",null,"Operators that can take multiple arguments, such as function calling operator\n",(0,i.kt)("inlineCode",{parentName:"p"},"f(4)"),", have a ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#variadic-arguments"},"variadic")," parameter\nlist."),(0,i.kt)("p",null,"Whether and how a value supports other operations, such as being copied,\nswapped, or set into an ",(0,i.kt)("a",{parentName:"p",href:"#unformed-state"},"unformed state"),", is also determined by\nimplementing corresponding interfaces for the value's type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/details#operator-overloading"},"Operator overloading")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/702"},"#702: Comparison operators")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/820"},"#820: Implicit conversions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/845"},"#845: as expressions")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1058"},"#1058: How should interfaces for core functionality be named?")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1083"},"#1083: Arithmetic expressions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1191"},"#1191: Bitwise operators")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1178"},"#1178: Rework operator interfaces")))),(0,i.kt)("h4",{id:"common-type"},"Common type"),(0,i.kt)("p",null,"There are some situations where the common type for two types is needed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/if"},"conditional expression like ",(0,i.kt)("inlineCode",{parentName:"a"},"if c then t else f")),"\nreturns a value with the common type of ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If there are multiple parameters to a function with a type parameter, it\nwill be set to the common type of the corresponding arguments, as in:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn F[T:! Type](x: T, y: T);\n\n// Calls `F` with `T` set to the\n// common type of `G()` and `H()`:\nF(G(), H());\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The inferred return type of a function with\n",(0,i.kt)("a",{parentName:"p",href:"#auto-return-type"},(0,i.kt)("inlineCode",{parentName:"a"},"auto")," return type")," is the common type of its ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),"\nstatements."))),(0,i.kt)("p",null,"The common type is specified by implementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonTypeWith")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"// Common type of `A` and `B` is `C`.\nimpl A as CommonTypeWith(B) where .Result == C { }\n")),(0,i.kt)("p",null,"The common type is required to be a type that both types have an\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions"},"implicit conversion")," to."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/expressions/if#finding-a-common-type"},(0,i.kt)("inlineCode",{parentName:"a"},"if")," expressions")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/911"},"#911: Conditional expressions")),(0,i.kt)("li",{parentName:"ul"},"Question-for-leads issue\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/issues/1077"},"#1077: find a way to permit impls of CommonTypeWith where the LHS and RHS type overlap")))),(0,i.kt)("h2",{id:"bidirectional-interoperability-with-c-and-c"},"Bidirectional interoperability with C and C++"),(0,i.kt)("p",null,"Interoperability, or ",(0,i.kt)("em",{parentName:"p"},"interop"),", is the ability to call C and C++ code from\nCarbon code and the other way around. This ability achieves two goals:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Allows sharing a code and library ecosystem with C and C++."),(0,i.kt)("li",{parentName:"ul"},"Allows incremental migration to Carbon from C and C++.")),(0,i.kt)("p",null,"Carbon's approach to interop is most similar to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/interoperability/philosophy_and_goals#other-interoperability-layers"},"Java/Kotlin interop"),",\nwhere the two languages are different, but share enough of runtime model that\ndata from one side can be used from the other. For example, C++ and Carbon will\nuse the same\n",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/memory_model"},"memory model"),"."),(0,i.kt)("p",null,"The design for interoperability between Carbon and C++ hinges on:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The ability to interoperate with a wide variety of code, such as\nclasses/structs and\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Template_(C%2B%2B)"},"templates"),", not just\nfree functions."),(0,i.kt)("li",{parentName:"ol"},"A willingness to expose the idioms of C++ into Carbon code, and the other\nway around, when necessary to maximize performance of the interoperability\nlayer."),(0,i.kt)("li",{parentName:"ol"},"The use of wrappers and generic programming, including templates, to\nminimize or eliminate runtime overhead.")),(0,i.kt)("p",null,"This feature will have some restrictions; only a subset of Carbon APIs will be\navailable to C++ and a subset of C++ APIs will be available to Carbon."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"To achieve simplification in Carbon, its programming model will exclude some\nrarely used and complex features of C++. For example, there will be\nlimitations on\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Multiple_inheritance"},"multiple inheritance"),"."),(0,i.kt)("li",{parentName:"ul"},"C or C++ features that compromise the performance of code that don't use\nthat feature, like\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Run-time_type_information"},"RTTI")," and\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Exception_handling"},"exceptions"),", are in\nparticular subject to revision in Carbon.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/"},"Bidirectional interoperability with C/C++")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/175"},"#175: C++ interoperability goals")))),(0,i.kt)("h3",{id:"goals"},"Goals"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/interoperability/philosophy_and_goals#goals"},"goals for interop")," include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#support-mixing-carbon-and-c-toolchains"},"Support mixing Carbon and C++ toolchains")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#compatibility-with-the-c-memory-model"},"Compatibility with the C++ memory model")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#minimize-bridge-code"},"Minimize bridge code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#unsurprising-mappings-between-c-and-carbon-types"},"Unsurprising mappings between C++ and Carbon types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#allow-c-bridge-code-in-carbon-files"},"Allow C++ bridge code in Carbon files")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#carbon-inheritance-from-c-types"},"Carbon inheritance from C++ types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#support-use-of-advanced-c-features"},"Support use of advanced C++ features")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#support-basic-c-interoperability"},"Support basic C interoperability"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#goals"},"Interoperability: Goals")))),(0,i.kt)("h3",{id:"non-goals"},"Non-goals"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/interoperability/philosophy_and_goals#non-goals"},"non-goals for interop"),"\ninclude:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains"},"Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#never-require-bridge-code"},"Never require bridge code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#convert-all-c-types-to-carbon-types"},"Convert all C++ types to Carbon types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#support-for-c-exceptions-without-bridge-code"},"Support for C++ exceptions without bridge code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#cross-language-metaprogramming"},"Cross-language metaprogramming")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#offer-equivalent-support-for-languages-other-than-c"},"Offer equivalent support for languages other than C++"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/interoperability/philosophy_and_goals#non-goals"},"Interoperability: Non-goals")))),(0,i.kt)("h3",{id:"importing-and-include"},"Importing and ",(0,i.kt)("inlineCode",{parentName:"h3"},"#include")),(0,i.kt)("p",null,"A C++ library header file may be ",(0,i.kt)("a",{parentName:"p",href:"#imports"},"imported")," into Carbon using an\n",(0,i.kt)("inlineCode",{parentName:"p"},"import")," declaration of the special ",(0,i.kt)("inlineCode",{parentName:"p"},"Cpp")," package."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// like `#include "circle.h"` in C++\nimport Cpp library "circle.h";\n')),(0,i.kt)("p",null,"This adds the names from ",(0,i.kt)("inlineCode",{parentName:"p"},"circle.h")," into the ",(0,i.kt)("inlineCode",{parentName:"p"},"Cpp")," namespace. If ",(0,i.kt)("inlineCode",{parentName:"p"},"circle.h"),"\ndefines some names in a ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace shapes { ... }")," scope, those will be found in\nCarbon's ",(0,i.kt)("inlineCode",{parentName:"p"},"Cpp.shapes")," namespace."),(0,i.kt)("p",null,"In the other direction, Carbon packages can export a header file to be\n",(0,i.kt)("inlineCode",{parentName:"p"},"#include"),"d from C++ files."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c++"},'// like `import Geometry` in Carbon\n#include "geometry.carbon.h"\n')),(0,i.kt)("p",null,"Generally Carbon entities will be usable from C++ and C++ entities will be\nusable from Carbon. This includes types, function, and constants. Some entities,\nsuch as Carbon interfaces, won't be able to be translated directly."),(0,i.kt)("p",null,"C and C++ macros that are defining constants will be imported as constants.\nOtherwise, C and C++ macros will be unavailable in Carbon. C and C++ ",(0,i.kt)("inlineCode",{parentName:"p"},"typedef"),"s\nwould be translated into type constants, as if declared using a\n",(0,i.kt)("a",{parentName:"p",href:"#constant-let-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"let")),"."),(0,i.kt)("p",null,"Carbon functions and types that satisfy some restrictions may be annotated as\nexported to C as well, like C++'s\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B#Linking_C_and_C++_code"},(0,i.kt)("inlineCode",{parentName:"a"},'extern "C"')),"\nmarker."),(0,i.kt)("h3",{id:"abi-and-dynamic-linking"},"ABI and dynamic linking"),(0,i.kt)("p",null,"Carbon itself will not have a stable ABI for the language as a whole, and most\nlanguage features will be designed around not having any ABI stability. Instead,\nwe expect to add dedicated language features that are specifically designed to\nprovide an ABI-stable boundary between two separate parts of a Carbon program.\nThese ABI-resilient language features and API boundaries will be opt-in and\nexplicit. They may also have functionality restrictions to make them easy to\nimplement with strong ABI resilience."),(0,i.kt)("p",null,"When interoperating with already compiled C++ object code or shared libraries,\nthe C++ interop may be significantly less feature rich than otherwise. This is\nan open area for us to explore, but we expect to require re-compiling C++ code\nin order to get the full ergonomic and performance benefits when interoperating\nwith Carbon. For example, recompilation lets us ensure Carbon and C++ can use\nthe same representation for key vocabulary types."),(0,i.kt)("p",null,"However, we expect to have full support for the C ABI when interoperating with\nalready-compiled C object code or shared libraries. We expect Carbon's bridge\ncode functionality to cover similar use cases as C++'s\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B#Linking_C_and_C++_code"},(0,i.kt)("inlineCode",{parentName:"a"},'extern "C"')),"\nmarker in order to provide full bi-directional support here. The functionality\navailable across this interop boundary will of course be restricted to what is\nexpressible in the C ABI, and types may need explicit markers to have guaranteed\nABI compatibility."),(0,i.kt)("h3",{id:"operator-overloading-1"},"Operator overloading"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#operator-overloading"},"Operator overloading")," is supported in Carbon, but is\ndone by ",(0,i.kt)("a",{parentName:"p",href:"#interfaces-and-implementations"},"implementing an interface")," instead of\ndefining a method or nonmember function as in C++."),(0,i.kt)("p",null,"Carbon types implementing an operator overload using an interface should get the\ncorresponding operator overload in C++. So implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"ModWith(U)")," in Carbon\nfor a type effectively implements ",(0,i.kt)("inlineCode",{parentName:"p"},"operator%")," in C++ for that type. This also\nworks in the other direction, so C++ types implementing an operator overload are\nautomatically considered to implement the corresponding Carbon interface. So\nimplementing ",(0,i.kt)("inlineCode",{parentName:"p"},"operator%")," in C++ for a type also implements interface\n",(0,i.kt)("inlineCode",{parentName:"p"},"ModWith(U)")," in Carbon. However, there may be edge cases around implicit\nconversions or overload selection that don't map completely into Carbon."),(0,i.kt)("p",null,"In some cases, the operation might be written differently in the two languages.\nIn those cases, they are matched according to which operation has the most\nsimilar semantics rather than using the same symbols. For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"^x"),"\noperation and ",(0,i.kt)("inlineCode",{parentName:"p"},"BitComplement")," interface in Carbon corresponds to the ",(0,i.kt)("inlineCode",{parentName:"p"},"~x"),"\noperation and ",(0,i.kt)("inlineCode",{parentName:"p"},"operator~")," function in C++. Similarly, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ImplicitAs(U)")," Carbon\ninterface corresponds to implicit conversions in C++, which can be written in\nmultiple different ways. Other\n",(0,i.kt)("a",{parentName:"p",href:"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html"},"C++ customization points"),"\nlike ",(0,i.kt)("inlineCode",{parentName:"p"},"swap")," will correspond to a Carbon interface, on a case-by-case basis."),(0,i.kt)("p",null,"Some operators will only exist or be overridable in C++, such as logical\noperators or the comma operator. In the unlikely situation where those operators\nneed to be overridden for a Carbon type, that can be done with a nonmember C++\nfunction."),(0,i.kt)("p",null,"Carbon interfaces with no C++ equivalent, such as\n",(0,i.kt)("a",{parentName:"p",href:"#common-type"},(0,i.kt)("inlineCode",{parentName:"a"},"CommonTypeWith(U)")),", may be implemented for C++ types externally\nin Carbon code. To satisfy the orphan rule\n(",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#impl-lookup"},"1"),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/details#orphan-rule"},"2"),"),\neach C++ library will have a corresponding Carbon wrapper library that must be\nimported instead of the C++ library if the Carbon wrapper exists. ",(0,i.kt)("strong",{parentName:"p"},"TODO:"),"\nPerhaps it will automatically be imported, so a wrapper may be added without\nrequiring changes to importers?"),(0,i.kt)("h3",{id:"templates"},"Templates"),(0,i.kt)("p",null,"Carbon supports both\n",(0,i.kt)("a",{parentName:"p",href:"#checked-and-template-parameters"},"checked and template generics"),". This provides\na migration path for C++ template code:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C++ template -> Carbon template: This involves migrating the code from C++\nto Carbon. If that migration is faithful, the change should be transparent\nto callers."),(0,i.kt)("li",{parentName:"ul"},"-> Carbon template with constraints: Constraints may be added one at a time.\nAdding a constraint never changes the meaning of the code as long as it\ncontinues to compile. Compile errors will point to types for which an\nimplementation of missing interfaces is needed. A temporary template\nimplementation of that interface can act as a bridge during the transition."),(0,i.kt)("li",{parentName:"ul"},"-> Carbon checked generic: Once all callers work after all constraints have\nbeen added, the template parameter may be switched to a checked generic.")),(0,i.kt)("p",null,"Carbon will also provide direct interop with C++ templates in many ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Ability to call C++ templates and use C++ templated types from Carbon."),(0,i.kt)("li",{parentName:"ul"},"Ability to instantiate a C++ template with a Carbon type."),(0,i.kt)("li",{parentName:"ul"},"Ability to instantiate a Carbon generic with a C++ type.")),(0,i.kt)("p",null,"We expect the best interop in these areas to be based on a Carbon-provided C++\ntoolchain. However, even when using Carbon's generated C++ headers for interop,\nwe will include the ability where possible to use a Carbon generic from C++ as\nif it were a C++ template."),(0,i.kt)("h3",{id:"standard-types"},"Standard types"),(0,i.kt)("p",null,"The Carbon integer types, like ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"u64"),", are considered equal to the\ncorresponding fixed-width integer types in C++, like ",(0,i.kt)("inlineCode",{parentName:"p"},"int32_t")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"uint64_t"),",\nprovided by ",(0,i.kt)("inlineCode",{parentName:"p"},"<stdint.h>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"<cstdint>"),". The basic C and C++ integer types like\n",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"char"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"unsigned long")," are available in Carbon inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"Cpp"),"\nnamespace given an ",(0,i.kt)("inlineCode",{parentName:"p"},"import Cpp;")," declaration, with names like ",(0,i.kt)("inlineCode",{parentName:"p"},"Cpp.int"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"Cpp.char"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Cpp.unsigned_long"),". C++ types are considered different if C++\nconsiders them different, so C++ overloads are resolved the same way. Carbon\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions#data-types"},"conventions for implicit conversions between integer types"),"\napply here, allowing them whenever the numerical value for all inputs may be\npreserved by the conversion."),(0,i.kt)("p",null,"Other C and C++ types are equal to Carbon types as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"C or C++"),(0,i.kt)("th",{parentName:"tr",align:null},"Carbon"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bool")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bool"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"f32"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"double")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"f64"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"T*")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Optional(T*)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"T[4]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"[T; 4]"))))),(0,i.kt)("p",null,"Further, C++ reference types like ",(0,i.kt)("inlineCode",{parentName:"p"},"T&")," will be translated to ",(0,i.kt)("inlineCode",{parentName:"p"},"T*")," in Carbon,\nwhich is Carbon's non-null pointer type."),(0,i.kt)("p",null,"Carbon will work to have idiomatic vocabulary ",(0,i.kt)("em",{parentName:"p"},"view")," types for common data\nstructures, like ",(0,i.kt)("inlineCode",{parentName:"p"},"std::string_view")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"std::span"),", map transparently between\nC++ and the Carbon equivalents. This will include data layout so that even\npointers to these types translate seamlessly, contingent on a suitable C++ ABI\nfor those types, potentially by re-compiling the C++ code with a customized ABI.\nWe will also explore how to expand coverage to similar view types in other\nlibraries."),(0,i.kt)("p",null,"However, Carbon's containers will be distinct from the C++ standard library\ncontainers in order to maximize our ability to improve performance and leverage\nlanguage features like checked generics in their design and implementation."),(0,i.kt)("p",null,"Where possible, we will also try to provide implementations of Carbon's standard\nlibrary container ",(0,i.kt)("em",{parentName:"p"},"interfaces")," for the relevant C++ container types so that they\ncan be directly used with generic Carbon code. This should allow generic code in\nCarbon to work seamlessly with both Carbon and C++ containers without\nperformance loss or constraining the Carbon container implementations. In the\nother direction, Carbon containers will satisfy C++ container requirements, so\ntemplated C++ code can operate directly on Carbon containers as well."),(0,i.kt)("h3",{id:"inheritance-1"},"Inheritance"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#inheritance"},"Carbon has single inheritance")," allowing C++ classes using\ninheritance to be migrated. The data representation will be consistent so that\nCarbon classes may inherit from C++ classes, and the other way around, even with\nvirtual methods."),(0,i.kt)("p",null,"C++ ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Multiple_inheritance"},"multiple inheritance"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"},"CRTP"),"\nwill be migrated using a combination of Carbon features. Carbon mixins support\nimplementation reuse and Carbon interfaces allow a type to implement multiple\nAPIs. However, there may be limits on the degree of interop available with\nmultiple inheritance across the C++ <-> Carbon boundaries."),(0,i.kt)("p",null,"Carbon dyn-safe interfaces may be exported to C++ as an\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Class_(computer_programming)#Abstract_and_concrete"},"abstract base class"),".\nThe reverse operation is also possible using a proxy object implementing a C++\nabstract base class and holding a pointer to a type implementing the\ncorresponding interface."),(0,i.kt)("h3",{id:"enums"},"Enums"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO"))),(0,i.kt)("h2",{id:"unfinished-tales"},"Unfinished tales"),(0,i.kt)("h3",{id:"safety"},"Safety"),(0,i.kt)("p",null,"Carbon's premise is that C++ users can't give up performance to get safety. Even\nif some isolated users can make that tradeoff, they share code with\nperformance-sensitive users. Any path to safety must preserve performance of C++\ntoday. This rules out garbage collection, and many other options. The only well\nunderstood mechanism of achieving safety without giving up performance is\ncompile-time safety. The leading example of how to achieve this is Rust."),(0,i.kt)("p",null,"The difference between Rust's approach and Carbon's is that Rust starts with\nsafety and Carbons starts with migration. Rust supports interop with C, and\nthere is ongoing work to improve the C++-interop story and develop migration\ntools. However, there is a large gap in programming models between the two\nlanguages, generally requiring a revision to the architecture. So, thus far the\ncommon pattern in the Rust community is to \"rewrite it in Rust\"\n(",(0,i.kt)("a",{parentName:"p",href:"https://deprogrammaticaipsum.com/the-great-rewriting-in-rust/"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://unhandledexpression.com/rust/2017/07/10/why-you-should-actually-rewrite-it-in-rust.html"},"2"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://transitiontech.ca/random/RIIR"},"3"),"). Carbon's approach is to focus on\nmigration from C++, including seamless interop, and then incrementally improve\nsafety."),(0,i.kt)("p",null,"The first impact on Carbon's design to support its safety strategy are the\nnecessary building blocks for this level of compile-time safety. We look at\nexisting languages like Rust and Swift to understand what fundamental\ncapabilities they ended up needing. The two components that stand out are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Expanded type system that includes more semantic information."),(0,i.kt)("li",{parentName:"ul"},"More pervasive use of type system abstractions (typically generics).")),(0,i.kt)("p",null,"For migrating C++ code, we also need the ability to add features and migrate\ncode to use those new features incrementally and over time. This requires\ndesigning the language with evolution baked in on day one. This impacts a wide\nrange of features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"At the lowest level, a simple and extensible syntax and grammar."),(0,i.kt)("li",{parentName:"ul"},"Tools and support for adding and removing APIs."),(0,i.kt)("li",{parentName:"ul"},"Scalable migration strategies, including tooling support.")),(0,i.kt)("p",null,"Rust shows the value of expanded semantic information in the type system such as\nprecise lifetimes. This is hard to do in C++ since it has too many kinds of\nreferences and pointers, which increases the complexity in the type system\nmultiplicatively. Carbon is attempting to compress C++'s type variations into\njust values and ",(0,i.kt)("a",{parentName:"p",href:"#pointer-types"},"pointers"),"."),(0,i.kt)("p",null,"Rust also shows the value of functions parameterized by lifetimes. Since\nlifetimes are only used to establish safety properties of the code, there is no\nreason to pay the cost of monomorphization for those parameters. So we need a\n",(0,i.kt)("a",{parentName:"p",href:"#generics"},"generics system")," that can reason about code before it is\ninstantiated, unlike C++ templates."),(0,i.kt)("p",null,"In conclusion, there are two patterns in how Carbon diverges from C++:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Simplify and removing things to create space for new safety features. This\ntrivially requires breaking backwards compatibility."),(0,i.kt)("li",{parentName:"ul"},"Re-engineer foundations to model and enforce safety. This has complex and\ndifficulty in C++ without first simplifying the language.")),(0,i.kt)("p",null,"This leads to Carbon's incremental path to safety:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Keep your performance, your existing codebase, and your developers."),(0,i.kt)("li",{parentName:"ul"},"Adopt Carbon through a scalable, tool-assisted migration from C++."),(0,i.kt)("li",{parentName:"ul"},"Address initial, easy safety improvements starting day one."),(0,i.kt)("li",{parentName:"ul"},"Shift the Carbon code onto an incremental path towards memory safety over\nthe next decade.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/project/principles/safety_strategy"},"Safety strategy"))),(0,i.kt)("h3",{id:"lifetime-and-move-semantics"},"Lifetime and move semantics"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:"))),(0,i.kt)("h3",{id:"metaprogramming"},"Metaprogramming"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:")," References need to be evolved. Needs a detailed design and a high\nlevel summary provided inline.")),(0,i.kt)("p",null,"Carbon provides metaprogramming facilities that look similar to regular Carbon\ncode. These are structured, and do not offer arbitrary inclusion or\npreprocessing of source text such as C and C++ do."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/metaprogramming"},"Metaprogramming"))),(0,i.kt)("h3",{id:"pattern-matching-as-function-overload-resolution"},"Pattern matching as function overload resolution"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:")," References need to be evolved. Needs a detailed design and a high\nlevel summary provided inline.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References: ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/pattern_matching"},"Pattern matching"))),(0,i.kt)("h3",{id:"error-handling"},"Error handling"),(0,i.kt)("p",null,"For now, Carbon does not have language features dedicated to error handling, but\nwe would consider adding some in the future. At this point, errors are\nrepresented using ",(0,i.kt)("a",{parentName:"p",href:"#choice-types"},"choice types")," like ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional"),"."),(0,i.kt)("p",null,"This is similar to the story for Rust, which started using ",(0,i.kt)("inlineCode",{parentName:"p"},"Result"),", then added\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"},(0,i.kt)("inlineCode",{parentName:"a"},"?")," operator"),"\nfor convenience, and is now considering (",(0,i.kt)("a",{parentName:"p",href:"https://yaah.dev/try-blocks"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/beta/unstable-book/language-features/try-blocks.html"},"2"),")\nadding more."),(0,i.kt)("h3",{id:"execution-abstractions"},"Execution abstractions"),(0,i.kt)("p",null,"Carbon provides some higher-order abstractions of program execution, as well as\nthe critical underpinnings of such abstractions."),(0,i.kt)("h4",{id:"abstract-machine-and-execution-model"},"Abstract machine and execution model"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:"))),(0,i.kt)("h4",{id:"lambdas"},"Lambdas"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:"))),(0,i.kt)("h4",{id:"co-routines"},"Co-routines"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:"))),(0,i.kt)("h4",{id:"concurrency"},"Concurrency"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TODO:"))))}c.isMDXComponent=!0}}]);