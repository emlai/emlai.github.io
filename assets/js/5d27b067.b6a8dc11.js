"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8972],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>d});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(r),d=i,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||a;return r?n.createElement(h,o(o({ref:t},p),{},{components:r})):n.createElement(h,o({ref:t},p))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var c=2;c<a;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},5362:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var n=r(7462),i=(r(7294),r(3905));const a={},o="Principle: Success criteria",l={unversionedId:"principles/success_criteria",id:"principles/success_criteria",title:"Principle: Success criteria",description:"\x3c!--",source:"@site/../docs/project/principles/success_criteria.md",sourceDirName:"principles",slug:"/principles/success_criteria",permalink:"/project/principles/success_criteria",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/principles/success_criteria.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Principle: One static open extension mechanism",permalink:"/project/principles/static_open_extension"},next:{title:"Trunk-based pull-request GitHub workflow",permalink:"/project/pull_request_workflow"}},s={},c=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Principle",id:"principle",level:2},{value:"Applications of these principles",id:"applications-of-these-principles",level:2},{value:"Modern OS platforms, hardware architectures, and environments",id:"modern-os-platforms-hardware-architectures-and-environments",level:3},{value:"OS platforms",id:"os-platforms",level:4},{value:"Hardware architectures",id:"hardware-architectures",level:4},{value:"Historical platforms",id:"historical-platforms",level:4},{value:"Interoperability with and migration from existing C++ code",id:"interoperability-with-and-migration-from-existing-c-code",level:3},{value:"Migration tooling",id:"migration-tooling",level:4}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"principle-success-criteria"},"Principle: Success criteria"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#principle"},"Principle")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#applications-of-these-principles"},"Applications of these principles"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#modern-os-platforms-hardware-architectures-and-environments"},"Modern OS platforms, hardware architectures, and environments"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#os-platforms"},"OS platforms")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#hardware-architectures"},"Hardware architectures")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#historical-platforms"},"Historical platforms")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interoperability-with-and-migration-from-existing-c-code"},"Interoperability with and migration from existing C++ code"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#migration-tooling"},"Migration tooling"))))))),(0,i.kt)("h2",{id:"principle"},"Principle"),(0,i.kt)("p",null,"Carbon's goals set a high-level path for where Carbon should head. However,\ngiven priorities, it's not always clear how specific features or details may end\nup being evaluated."),(0,i.kt)("p",null,"Carbon's success criteria are specific, measurable, key results that we expect\nto use to see how Carbon is doing against its goals. Success criteria will be\nconsidered as part of Carbon's ",(0,i.kt)("a",{parentName:"p",href:"/project/roadmap_process"},"roadmap process"),", missing\nthem will be considered significant, and extra scrutiny will be applied on\nproposals that would require diminishing them. These success criteria are not\nexhaustive, but they are a bar that we aim to ",(0,i.kt)("em",{parentName:"p"},"exceed"),"."),(0,i.kt)("h2",{id:"applications-of-these-principles"},"Applications of these principles"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"TODO: Add more metrics for various goals.")),(0,i.kt)("h3",{id:"modern-os-platforms-hardware-architectures-and-environments"},"Modern OS platforms, hardware architectures, and environments"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:\n",(0,i.kt)("a",{parentName:"p",href:"/project/goals#modern-os-platforms-hardware-architectures-and-environments"},"goal"))),(0,i.kt)("p",null,"This should not be considered an exhaustive list of important platforms."),(0,i.kt)("h4",{id:"os-platforms"},"OS platforms"),(0,i.kt)("p",null,"Our priority OS platforms are modern versions of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Linux, including common distributions, Android and ChromeOS"),(0,i.kt)("li",{parentName:"ul"},"FreeBSD"),(0,i.kt)("li",{parentName:"ul"},"Windows"),(0,i.kt)("li",{parentName:"ul"},"macOS and iOS"),(0,i.kt)("li",{parentName:"ul"},"Fuchsia"),(0,i.kt)("li",{parentName:"ul"},"WebAssembly"),(0,i.kt)("li",{parentName:"ul"},"Bare metal")),(0,i.kt)("h4",{id:"hardware-architectures"},"Hardware architectures"),(0,i.kt)("p",null,"We expect to prioritize 64-bit little endian hardware, including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"x86-64"),(0,i.kt)("li",{parentName:"ul"},"AArch64, also known as ARM 64-bit"),(0,i.kt)("li",{parentName:"ul"},"PPC64LE, also known as Power ISA, 64-bit, Little Endian"),(0,i.kt)("li",{parentName:"ul"},"RV64I, also known as RISC-V 64-bit")),(0,i.kt)("p",null,"We believe Carbon should strive to support some GPUs, other restricted\ncomputational hardware and environments, and embedded environments. While this\nshould absolutely include future and emerging hardware and platforms, those\nshouldn't disproportionately shape the fundamental library and language design\nwhile they remain relatively new and rapidly evolving."),(0,i.kt)("h4",{id:"historical-platforms"},"Historical platforms"),(0,i.kt)("p",null,"Example historical platforms that we will not prioritize support for are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Byte sizes other than 8 bits, or non-power-of-two word sizes."),(0,i.kt)("li",{parentName:"ul"},"Source code encodings other than UTF-8."),(0,i.kt)("li",{parentName:"ul"},"Big- or mixed-endian, at least for computation; accessing encoded data\nremains useful."),(0,i.kt)("li",{parentName:"ul"},"Non-2's-complement integer formats."),(0,i.kt)("li",{parentName:"ul"},"Non-IEEE 754 binary floating point format and semantics for default single-\nand double-precision floating point types."),(0,i.kt)("li",{parentName:"ul"},"Source code in file systems that don\u2019t support file extensions or nested\ndirectories.")),(0,i.kt)("h3",{id:"interoperability-with-and-migration-from-existing-c-code"},"Interoperability with and migration from existing C++ code"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"References:\n",(0,i.kt)("a",{parentName:"p",href:"/project/goals#interoperability-with-and-migration-from-existing-c-code"},"goal"))),(0,i.kt)("h4",{id:"migration-tooling"},"Migration tooling"),(0,i.kt)("p",null,"Migrations must be mostly automatic. To that end, given an arbitrary large\ncodebase following best practices, we aim to have less than 2% of files require\nhuman interaction."),(0,i.kt)("p",null,"This criterion includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Addressing performance bugs unique to Carbon, introduced by migration\ntooling."),(0,i.kt)("li",{parentName:"ul"},"Converting complex code which migration tooling does not handle.")),(0,i.kt)("p",null,"This criterion does not include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Cleaning up coding style to idiomatic Carbon.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For example, heavy use of C++ preprocessor macros may result in expanded\ncode where there is no equivalent Carbon metaprogramming construct.")))))}u.isMDXComponent=!0}}]);