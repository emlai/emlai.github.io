"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7360],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||l;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},312:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const l={},r="C++ style guide",o={unversionedId:"docs/project/cpp_style_guide",id:"docs/project/cpp_style_guide",title:"C++ style guide",description:"\x3c!--",source:"@site/../docs/project/cpp_style_guide.md",sourceDirName:"docs/project",slug:"/docs/project/cpp_style_guide",permalink:"/docs/project/cpp_style_guide",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/project/cpp_style_guide.md",tags:[],version:"current",frontMatter:{},sidebar:"project",previous:{title:"Contribution tools",permalink:"/docs/project/contribution_tools"},next:{title:"Language design style guide",permalink:"/docs/project/design_style_guide"}},s={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Background",id:"background",level:2},{value:"Baseline",id:"baseline",level:2},{value:"Carbon-local guidance",id:"carbon-local-guidance",level:2},{value:"General naming rules",id:"general-naming-rules",level:3},{value:"File names",id:"file-names",level:3},{value:"Syntax and formatting",id:"syntax-and-formatting",level:3},{value:"Copyable and movable types",id:"copyable-and-movable-types",level:3},{value:"Static and global variables",id:"static-and-global-variables",level:3},{value:"Foundational libraries and data types",id:"foundational-libraries-and-data-types",level:3},{value:"Suggested <code>.clang-format</code> contents",id:"suggested-clang-format-contents",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"c-style-guide"},"C++ style guide"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#background"},"Background")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#baseline"},"Baseline")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#carbon-local-guidance"},"Carbon-local guidance"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#general-naming-rules"},"General naming rules")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#file-names"},"File names")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#syntax-and-formatting"},"Syntax and formatting")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#copyable-and-movable-types"},"Copyable and movable types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#static-and-global-variables"},"Static and global variables")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#foundational-libraries-and-data-types"},"Foundational libraries and data types")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#suggested-clang-format-contents"},"Suggested ",(0,i.kt)("inlineCode",{parentName:"a"},".clang-format")," contents"))),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"C++ code in the Carbon project should use a consistent and well documented style\nguide. Where possible, this should be enacted and enforced with tooling to avoid\ntoil both for authors of C++ code in the Carbon project and for code reviewers."),(0,i.kt)("p",null,"However, we are not in the business of innovating significantly in the space of\nwriting clean and maintainable C++ code, and so we work primarily to reuse\nexisting best practices and guidelines."),(0,i.kt)("h2",{id:"baseline"},"Baseline"),(0,i.kt)("p",null,"The baseline style guidance is the\n",(0,i.kt)("a",{parentName:"p",href:"https://google.github.io/styleguide/cppguide.html"},"Google C++ style guide"),"."),(0,i.kt)("h2",{id:"carbon-local-guidance"},"Carbon-local guidance"),(0,i.kt)("p",null,"We provide some local guidance beyond the baseline. This are typically motived\neither by specific value provided to the project, or to give simpler and more\nstrict guidance for Carbon's narrow use of C++."),(0,i.kt)("h3",{id:"general-naming-rules"},"General naming rules"),(0,i.kt)("p",null,"Carbon's C++ code tries to match the proposed Carbon naming convention as\nclosely as is reasonable in C++ in order to better understand and familiarize\nourselves with the practice of using this convention. It happens that this is\nfairly similar to the naming convention in the Google style guide and largely\nserves to simplify it."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Known, compile-time constants use ",(0,i.kt)("inlineCode",{parentName:"li"},"UpperCamelCase"),", referencing Proper\nNouns.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This includes namespaces, type names, functions, member functions\n(except as noted below), template parameters, ",(0,i.kt)("inlineCode",{parentName:"li"},"constexpr")," variables,\nenumerators, etc."),(0,i.kt)("li",{parentName:"ul"},"Note that virtual member functions should be named with\n",(0,i.kt)("inlineCode",{parentName:"li"},"UpperCamelCase"),". The distinction between a virtual function and a\nnon-virtual function should be invisible, especially at the call site,\nas that is an internal implementation detail. We want to be able to\nfreely change that without updating the name."))),(0,i.kt)("li",{parentName:"ul"},"Member functions may use ",(0,i.kt)("inlineCode",{parentName:"li"},"snake_case")," names if they do nothing besides\nreturn a reference to a data member (or assign a value to a data member, in\nthe case of ",(0,i.kt)("inlineCode",{parentName:"li"},"set_")," methods), ",(0,i.kt)("strong",{parentName:"li"},"or")," if their behavior (including\nperformance) would be unsurprising to a caller who assumes they are\nimplemented that way."),(0,i.kt)("li",{parentName:"ul"},"All other names use ",(0,i.kt)("inlineCode",{parentName:"li"},"snake_case"),", including function parameters, and\nnon-constant local and member variables.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Private member variables should have a trailing ",(0,i.kt)("inlineCode",{parentName:"li"},"_"),".")))),(0,i.kt)("h3",{id:"file-names"},"File names"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Always use ",(0,i.kt)("inlineCode",{parentName:"li"},"snake_case")," for files, directories, and build system rules.\nAvoid ",(0,i.kt)("inlineCode",{parentName:"li"},"-"),"s in these as well."),(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},".cpp"),' for source files, which is the most common open source extension\nand matches other places where "C++" is written without punctuation.')),(0,i.kt)("h3",{id:"syntax-and-formatting"},"Syntax and formatting"),(0,i.kt)("p",null,"These are minor issues where any of the options would be fine and we simply need\nto pick a consistent option. Where possible,\n",(0,i.kt)("a",{parentName:"p",href:"#suggested-clang-format-contents"},(0,i.kt)("inlineCode",{parentName:"a"},"clang-format"))," should be used to enforce\nthese."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Always use trailing return type syntax for functions and methods.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Place the pointer ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," adjacent to the type: ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeName* variable_name"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Only declare one variable at a time (declaring multiple variables requires\nconfusing repetition of part of the type).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Write ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," before the type when at the outer level: ",(0,i.kt)("inlineCode",{parentName:"p"},"const int N = 42;"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Only use line comments (with ",(0,i.kt)("inlineCode",{parentName:"p"},"//"),", not ",(0,i.kt)("inlineCode",{parentName:"p"},"/* ... */"),"), on a line by\nthemselves, except for\n",(0,i.kt)("a",{parentName:"p",href:"https://clang.llvm.org/extra/clang-tidy/checks/bugprone-argument-comment.html#bugprone-argument-comment"},"argument name comments"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://google.github.io/styleguide/cppguide.html#Namespaces"},"closing namespace comments"),",\nand similar structural comments. In particular, don't append comments about\na line of code to the end of its line:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"int bad = 42;  // Don't comment here.\n\n// Instead comment here.\nint good = 42;\n\n// Closing namespace comments are structural, and both okay and expected.\n}  // namespace MyNamespace\n")),(0,i.kt)("p",{parentName:"li"},"This dogfoods our planned commenting syntax for Carbon. It also provides a\nsingle, consistent placement rule. It also provides more resilience against\nautomated refactorings. Those changes often make code longer, which forces\never more difficult formatting decisions, and can easily spread one line\nacross multiple lines, leaving it impossible to know where to place the\ncomment. Comments on their own line preceding such code, while still\nimprecise, are at least less confusing over the course of such refactorings.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"using"),"-based type alias syntax instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"typedef"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Don't use ",(0,i.kt)("inlineCode",{parentName:"p"},"using")," to support unqualified lookup on ",(0,i.kt)("inlineCode",{parentName:"p"},"std")," types; for example,\n",(0,i.kt)("inlineCode",{parentName:"p"},"using std::vector;"),". This also applies to other short namespaces,\nparticularly ",(0,i.kt)("inlineCode",{parentName:"p"},"llvm")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"clang"),"."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Writing ",(0,i.kt)("inlineCode",{parentName:"li"},"std::")," gives clearer diagnostics and avoids any possible\nambiguity, particularly for ADL."),(0,i.kt)("li",{parentName:"ul"},"An exception is made for functions like ",(0,i.kt)("inlineCode",{parentName:"li"},"std::swap")," that are\nintentionally called using ADL. This pattern should be written as\n",(0,i.kt)("inlineCode",{parentName:"li"},"{ using std::swap; swap(thing1, thing2); }"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Follow the rules for initialization outlined in\n",(0,i.kt)("a",{parentName:"p",href:"https://abseil.io/tips/88#best-practices-for-initialization"},"Abseil's tip #88"),".\nTo summarize, omitting some details from the article:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use assignment syntax (",(0,i.kt)("inlineCode",{parentName:"li"},"="),") when initializing directly with the intended\nvalue (or with a braced initializer directly specifying that value)."),(0,i.kt)("li",{parentName:"ul"},"Use the traditional constructor syntax (with parentheses) when the\ninitialization is performing some active logic, rather than simply\ncomposing values together."),(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"{}")," initialization without the ",(0,i.kt)("inlineCode",{parentName:"li"},"=")," only if the above options don't\ncompile."),(0,i.kt)("li",{parentName:"ul"},"Never mix ",(0,i.kt)("inlineCode",{parentName:"li"},"{}")," initialization and ",(0,i.kt)("inlineCode",{parentName:"li"},"auto"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Always use braces for conditional, ",(0,i.kt)("inlineCode",{parentName:"p"},"switch"),", and loop statements, even when\nthe body is a single statement."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Within a ",(0,i.kt)("inlineCode",{parentName:"li"},"switch")," statement, use braces after a ",(0,i.kt)("inlineCode",{parentName:"li"},"case")," label when\nnecessary to create a scope for a variable."),(0,i.kt)("li",{parentName:"ul"},"Always break the line immediately after an open brace except for empty\nloop bodies."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For\n",(0,i.kt)("a",{parentName:"p",href:"https://google.github.io/styleguide/cppguide.html#Internal_Linkage"},"internal linkage"),"\nof definitions of functions and variables, prefer ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," over anonymous\nnamespaces. ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," minimizes the context necessary to notice the internal\nlinkage of a definition."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Anonymous namespaces are still necessary for classes and enums."),(0,i.kt)("li",{parentName:"ul"},"Tests are an exception and should typically be wrapped with\n",(0,i.kt)("inlineCode",{parentName:"li"},"namespace Carbon::Testing { namespace { ... } }")," to keep everything\ninternal.")))),(0,i.kt)("h3",{id:"copyable-and-movable-types"},"Copyable and movable types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Types should have value semantics and support both move and copy where\npossible."),(0,i.kt)("li",{parentName:"ul"},"Types that cannot be copied should still be movable where possible."),(0,i.kt)("li",{parentName:"ul"},"If supported, moving should be as efficient as possible.")),(0,i.kt)("h3",{id:"static-and-global-variables"},"Static and global variables"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Global and static variables, whether at file, class, or function scope,\nshould be declared ",(0,i.kt)("inlineCode",{parentName:"li"},"constexpr"),".")),(0,i.kt)("h3",{id:"foundational-libraries-and-data-types"},"Foundational libraries and data types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Generally prefer LLVM libraries and data structures to standard C++ ones.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"These are optimized significantly for performance, especially when used\nwithout exception handling or safety requirements, and when used in\npatterns that tend to occur while building compilers."),(0,i.kt)("li",{parentName:"ul"},"They also minimize the vocabulary type friction when using actual LLVM\nand Clang APIs."))),(0,i.kt)("li",{parentName:"ul"},"Do not add third-party library dependencies to any code that might\nconceivably be used as part of the compiler or runtime.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Compilers and runtime libraries have unique constraints on their\nlicensing. For simplicity, we want all transitive dependencies of these\nlayers to be under the LLVM license that the Carbon project as a whole\nuses (as well as LLVM itself).")))),(0,i.kt)("h2",{id:"suggested-clang-format-contents"},"Suggested ",(0,i.kt)("inlineCode",{parentName:"h2"},".clang-format")," contents"),(0,i.kt)("p",null,"See this repository's ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/.clang-format"},(0,i.kt)("inlineCode",{parentName:"a"},".clang-format")," file"),"."))}m.isMDXComponent=!0}}]);