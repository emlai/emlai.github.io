<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-docs/project/goals">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-rc.1">
<title data-rh="true">Goals | Carbon Language</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://carbon-language.github.io/docs/project/goals/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Goals | Carbon Language"><meta data-rh="true" name="description" content="&lt;!--"><meta data-rh="true" property="og:description" content="&lt;!--"><link data-rh="true" rel="icon" href="/img/carbon-logo.png"><link data-rh="true" rel="canonical" href="https://carbon-language.github.io/docs/project/goals/"><link data-rh="true" rel="alternate" href="https://carbon-language.github.io/docs/project/goals/" hreflang="en"><link data-rh="true" rel="alternate" href="https://carbon-language.github.io/docs/project/goals/" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.c274b177.css">
<link rel="preload" href="/assets/js/runtime~main.e89ea4d0.js" as="script">
<link rel="preload" href="/assets/js/main.6441d3bf.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,t("light"))}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><div class="announcementBar_mb4j" style="background-color:var(--ifm-navbar-background-color);color:var(--ifm-font-color-base)" role="banner"><div class="announcementBarPlaceholder_vyr4"></div><div class="announcementBarContent_xLdY">⚠️ Carbon is experimental and not production-ready, see <a href="/docs/project/faq#how-soon-can-we-use-carbon">How soon can we use Carbon?</a></div><button type="button" class="clean-btn close announcementBarClose_gvF7" aria-label="Close"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Carbon Language</b></a><a class="navbar__item navbar__link" href="/docs/design/">Design</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/project/">Project</a><a class="navbar__item navbar__link" href="/docs/guides/">Guides</a><a class="navbar__item navbar__link" href="/docs/spec/">Spec</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/">Project</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/code_review/">Code review</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/contribution_tools/">Contribution tools</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/cpp_style_guide/">C++ style guide</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/design_style_guide/">Language design style guide</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/difficulties_improving_cpp/">Difficulties improving C++</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/evolution/">Evolution and governance</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/faq/">Project FAQ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/project/goals/">Goals</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/groups/">Groups</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/project/principles/">Principles</a><button aria-label="Toggle the collapsible sidebar category &#x27;Principles&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/pull_request_workflow/">Trunk-based pull-request GitHub workflow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/roadmap/">Roadmap</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/project/roadmap_process/">Roadmap process</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Goals</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Goals</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview">Overview<a class="hash-link" href="#overview" title="Direct link to heading">​</a></h2><p>Carbon is an experiment to explore a possible, distant future for the C++
programming language designed around a specific set of goals, priorities, and
use cases.</p><p>A programming language is a tool, and different tools are good for different
purposes. We think there is great value in priorities that differentiate Carbon
from other programming languages. Stating Carbon’s priorities clearly and
explicitly shapes the design of Carbon, and helps the entire community
effectively evaluate and use the language.</p><p>Carbon&#x27;s language goals have historically been best addressed by C++, and there
are large ecosystems and codebases written using C++ to these ends. Carbon
should be attractive and easy for C++ developers to try out and incrementally
adopt, even in individual libraries both using and used from C++ code. We expect
this depends on having high-performance bidirectional interoperability with C++,
excellent migration tooling, and an easy ramp-up for experienced C++ software
developers.</p><p><a href="/docs/project/principles/">Principles</a> are provided to clarify these goals.
Principles do not supersede goals and priorities.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="project-goals">Project goals<a class="hash-link" href="#project-goals" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="community-and-culture">Community and culture<a class="hash-link" href="#community-and-culture" title="Direct link to heading">​</a></h3><p>Carbon has an overarching goal of promoting a healthy and vibrant community with
an inclusive, welcoming, and pragmatic culture. While this may not directly
affect Carbon&#x27;s design, it affects how Carbon&#x27;s design occurs. We cannot build a
good language without a good community. As the saying goes,
<a href="https://techcrunch.com/2014/04/12/culture-eats-strategy-for-breakfast/" target="_blank" rel="noopener noreferrer">&quot;culture eats strategy for breakfast&quot;</a>.
Carbon&#x27;s community, including both maintainers and users, needs to last for
years and be capable of scaling up. It needs to support people working on Carbon
across a wide range of companies as their full time job, but also people
contributing in small fractions of their time, or as students, teachers, or as a
hobby. There are several key ingredients to achieving this.</p><p><strong>The community and project needs a code of conduct.</strong> We want Carbon&#x27;s
community to be welcoming and respectful, with a deep commitment to
psychological safety. We need consistent expectations for how every community
member should behave, regardless of their position in the community. These
expectations around conduct and behavior need to be clearly articulated both to
set expectations for people joining, and to help remind and anchor us on
consistent standards. It is also important that we hold ourselves accountable to
these expectations and have real and meaningful mechanisms to moderate the
community. When behavior steps outside of our expectations, we need tools,
process, and policy for how we will recognize and correct it.</p><p><strong>An open, inclusive process for Carbon changes.</strong> The community needs to be
able to effectively engage in the direction and evolution of the project and
language, while keeping the process efficient and effective. That means we need
an open, inclusive process where everyone feels comfortable participating.
Community members should understand how and why decisions are made, and have the
ability to both influence them before they occur and give feedback afterward. We
want to use this process to also ensure we stick to our language priorities and
have clear rationales for all of our technical designs and decisions.</p><p><strong>Being inclusive is different from including everyone.</strong> We want to avoid
excluding or marginalizing members of the community. However, we expect to
inevitably make choices that benefit some Carbon community members more than
others. We will provide justification for these decisions, but achieving
Carbon&#x27;s goals -- including that of a healthy community -- will be the guiding
rule.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="language-tools-and-ecosystem">Language tools and ecosystem<a class="hash-link" href="#language-tools-and-ecosystem" title="Direct link to heading">​</a></h3><p>Programming languages do not succeed in a vacuum. The Carbon project cannot
merely <em>design</em> a language in order to succeed, it must tackle the full
ecosystem of tooling that makes developers effective using the language. This
includes not only a compiler and standard library, but also a broad range of
other tools that enable developers to be more effective, efficient, or
productive.</p><p><strong>We will provide a reference implementation.</strong> This helps the language have a
strong and consistent experience for developers and a clear onboarding process.
It also enables us to carefully consider implementation considerations
throughout the design of the language. However, we do <em>not</em> want this to be seen
as a replacement for a formal specification at any point.</p><p><strong>Carbon will have a formal specification.</strong> Fully specifying the language
enables other implementations and allows us to clearly document the expected
behavior of the reference implementation. This does not mean the specification
defines what is &quot;correct&quot;; instead, the specification and reference
implementation should complement each other. Any divergence is a bug that <em>must</em>
be resolved, and the specification and reference should always converge. Carbon
should not have designs or specifications which do not match the practical
implementation, even if that means updating designs to reflect implementation
realities. Having the specification will enable better analysis of the language
as a whole and the production of other partial or full implementations which
match the behavior of the reference implementation.</p><p><strong>Approachable, developer-facing documentation.</strong> Developers shouldn&#x27;t be
expected to read through the specification to ramp up with Carbon. User guides
and other documentation will be provided to make it easy to learn how to use
Carbon.</p><p><strong>Compelling adoption tooling.</strong> We want to provide a compelling suite of tools
out-of-the-box in order to encourage adoption of Carbon at scale where it can
augment existing C++ codebases. For example, we expect a C++ -&gt; Carbon code
translator will be important.</p><p><strong>Tooling for updating code when Carbon evolves.</strong> As Carbon evolves over time,
we expect to provide tooling to help automate and scale migrating existing
Carbon code to the new version. The goal is to enable more rapid evolution of
the language without the churn tax and version skew becoming unsustainable.</p><p><strong>Developer tooling.</strong> We need developers to be productive reading and writing
Carbon code. We expect to provide a broad suite of development oriented tools
ranging from refactoring tools to <a href="https://langserver.org/" target="_blank" rel="noopener noreferrer">LSP</a> implementations
and editor integrations. We also plan to provide machine readable forms of many
parts of the language, such as a grammar, to ensure consistency between tools
and enable the development of tools by others.</p><p><strong>Infrastructure to enable package management and other library ecosystem
support.</strong> The goal is to support what the ecosystem needs, regardless of the
exact form this ends up taking.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="language-goals-and-priorities">Language goals and priorities<a class="hash-link" href="#language-goals-and-priorities" title="Direct link to heading">​</a></h2><p>We are designing Carbon to support:</p><ul><li>Performance-critical software</li><li>Software and language evolution</li><li>Code that is easy to read, understand, and write</li><li>Practical safety and testing mechanisms</li><li>Fast and scalable development</li><li>Modern OS platforms, hardware architectures, and environments</li><li>Interoperability with and migration from existing C++ code</li></ul><p>Many languages share subsets of these goals, but what distinguishes Carbon is
their combination. Where it is necessary to make tradeoffs between these goals,
we intend to prioritize them in this order.</p><p>Each goal is broad, and has several facets to consider when making decisions.
Below, we discuss all of these goals in more detail to give a deeper
understanding of both the nature and motivation of these goals.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="performance-critical-software">Performance-critical software<a class="hash-link" href="#performance-critical-software" title="Direct link to heading">​</a></h3><p>All software consumes resources: time, memory, compute, power, binary size, and
so on. In many cases, raw resource usage is not the biggest concern. Instead,
algorithmic efficiency or business logic dominates these concerns. However,
there exists software where its rate of resource consumption -- its performance
-- is critical to its successful operation. Another way to think about when
performance is critical: would a performance regression be considered a bug?
Would it even be noticed?</p><p>Our goal is to support software where its performance with respect to some set
of resource constraints is critical to its successful operation. This
overarching goal can be decomposed into a few specific aspects.</p><p><strong>Provide the developer control over every aspect of performance.</strong> When faced
with some performance problem, the developer should always have tools within
Carbon to address it. This does not mean that the developer is necessarily
concerned with ultimate performance at every moment, but in the most constrained
scenarios they must be able to &quot;open up the hood&quot; without switching to another
language.</p><p><strong>Idiomatic code should be fast.</strong> Developers should not regularly be required
to choose between performance and readability. Although performance tuning may
in rare cases require complex or surprising code, Carbon&#x27;s design should ensure
regular, idiomatic code usually results in high performance.</p><p><strong>Code should perform predictably.</strong> The reader and writer of code should be
able to easily understand its expected performance, given sufficient background
knowledge of the environment in which it will run. This need not be precise, but
instead can use heuristics and guidelines to avoid surprise. The key priority is
that performance, whether good or bad, is unsurprising to developers. Even
pleasant surprises, when too frequent, can become a problem due to establishing
brittle baseline performance that cannot be reliably sustained.</p><p><strong>Leave no room for a lower level language.</strong> Developers should not need to
leave the rules and structure of Carbon, whether to gain control over
performance problems or to gain access to hardware facilities.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="software-and-language-evolution">Software and language evolution<a class="hash-link" href="#software-and-language-evolution" title="Direct link to heading">​</a></h3><p>Titus Winters writes in &quot;Non-Atomic Refactoring and Software Sustainability&quot;:</p><blockquote><p>What is the difference between programming and software engineering? These are
nebulous concepts and thus there are many possible answers, but my favorite
definition is this: Software engineering is programming integrated over time.
All of the hard parts of engineering come from dealing with time:
compatibility over time, dealing with changes to underlying infrastructure and
dependencies, and working with legacy code or data. Fundamentally, it is a
different task to produce a programming solution to a problem (that solves the
current <!-- -->[instance]<!-- --> of the problem) versus an engineering solution (that solves
current instances, future instances that we can predict, and - through
flexibility - allows updates to solve future instances we may not be able to
predict).</p></blockquote><p>Carbon will prioritize being a &quot;software engineering&quot; language, in the above
sense. We specifically are interested in dealing with the time-oriented aspects
of software built in this language. We need to be prepared for substantive
changes in priority over the next decade, on par with the changes experienced in
the 2010s: 10x scaling of software organizations, mobile, cloud, diversification
of platforms and architectures, and so on.</p><p><strong>Support maintaining and evolving software written in Carbon for decades.</strong> The
life expectancy of some software will be long and the software will not be
static or unchanging in that time. Mistakes will be made and need to be
corrected. New functionality will be introduced and old functionality retired
and removed. The design of Carbon must support and ease every step of this
process. This ranges from emphasizing testing and continuous integration to
tooling and the ability to make non-atomic changes. It also includes constraints
on the design of Carbon itself: we should avoid, or at least minimize, language
features that encourage unchangeable constructs. For example, any feature with a
contract that cannot be strengthened or weakened without breaking the expected
usage patterns is inherently hostile to refactoring. Analogously, features or
conventions that require simultaneously updating all users of an API when
extending it are inherently hostile towards long-term maintenance of software.</p><p><strong>Support maintaining and evolving the language itself for decades.</strong> We will
not get the design of most language features correct on our first, second, or
73rd try. As a consequence, there must be a built-in plan and ability to move
Carbon forward at a reasonable pace and with a reasonable cost. Simultaneously,
an evolving language must not leave software behind to languish, but bring
software forward. This requirement should not imply compatibility, but instead
some migratability, likely tool-assisted.</p><p><strong>Be mindful of legacy.</strong> Globally, there may be as many as 50 billion lines of
C++ code. Any evolution of Carbon that fails to account for human
investment/training and legacy code, representing significant capital, is doomed
from the start. Note that our priority is restricted to legacy source code; we
do not prioritize full support of legacy object code. While that still leaves
many options open, such as dedicated and potentially slower features, it does
limit the degree to which legacy use cases beyond source code should shape the
Carbon design.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="code-that-is-easy-to-read-understand-and-write">Code that is easy to read, understand, and write<a class="hash-link" href="#code-that-is-easy-to-read-understand-and-write" title="Direct link to heading">​</a></h3><p>While this is perhaps the least unique among programming languages of the goals
we list here, we feel it is important to state it, explain all of what we mean
by it, and fit it into our prioritization scheme.</p><p>Software has inherent complexity that burdens developers, especially at scale
and over time. Carbon will strive to minimize that burden for reading,
understanding, and writing code. The behavior of code should be easily
understood, especially by those unfamiliar with the software system. Consider
developers attempting to diagnose a serious outage under time pressure -- every
second spent trying to understand the <em>language</em> is one not spent understanding
the <em>problem</em>.</p><p>While the source code of our software may be read far more often by machines,
humans are the most expensive readers and writers of software. As a consequence,
we need to optimize for human reading, understanding, and writing of software,
in that order.</p><p><strong>Excellent ergonomics.</strong> Human capabilities and limitations in the domains of
perception, memory, reasoning, and decision-making affect interactions between
humans and systems. Ergonomic language design takes human factors into account
to increase productivity and comfort, and reduce errors and fatigue, making
Carbon more suitable for humans to use. We can also say that ergonomic designs
are accessible to humans. &quot;Readability&quot; is a related, but a more focused
concept, connected to only the process of reading code. &quot;Ergonomics&quot; covers all
activities where humans interact with Carbon: reading, writing, designing,
discussing, reviewing, and refactoring code, as well as learning and teaching
Carbon. A few examples:</p><ul><li>Carbon should not use symbols that are difficult to type, see, or
differentiate from similar symbols in commonly used contexts.</li><li>Syntax should be easily parsed and scanned by any human in any development
environment, not just a machine or a human aided by semantic hints from an
IDE.</li><li>Code with similar behavior should use similar syntax, and code with
different behavior should use different syntax. Behavior in this context
should include both the functionality and performance of the code. This is
part of conceptual integrity.</li><li>Explicitness must be balanced against conciseness, as verbosity and ceremony
add cognitive overhead for the reader, while explicitness reduces the amount
of outside context the reader must have or assume.</li><li>Common yet complex tasks, such as parallel code, should be well-supported in
ways that are easy to reason about.</li><li>Ordinary tasks should not require extraordinary care, because humans cannot
consistently avoid making mistakes for an extended amount of time.</li></ul><p><strong>Support tooling at every layer of the development experience, including
IDEs.</strong> The design and implementation of Carbon should make it easy to create
such tools and make them effective. Carbon should avoid syntax and textual
structures that are difficult to recognize and mechanically change without
losing meaning.</p><p><strong>Support software outside of the primary use cases well.</strong> There are
surprisingly high costs for developers to switch languages. Even when the
primary goal is to support performance-critical software, other kinds of
software should not be penalized unnecessarily.</p><blockquote><p>&quot;The right tool for the job is often the tool you are already using -- adding
new tools has a higher cost than many people appreciate.&quot;</p><p>-- <a href="https://twitter.com/id_aa_carmack/status/989951283900514304" target="_blank" rel="noopener noreferrer">John Carmack</a></p></blockquote><p><strong>Focus on encouraging appropriate usage of features rather than restricting
misuse.</strong> Adding arbitrary restrictions to prevent misuse of otherwise general
features of the language can create problems when they end up interfering with
unexpected or rare but still appropriate usages. Instead, Carbon should focus on
enabling appropriate and effective usage of features, and creating incentives
around those. What seems initially like a &quot;misuse&quot; of a feature may be critical
for some rare or future use case. Put differently, we will not always be able to
prevent developers from misusing features or writing unnecessarily complex code,
and that is okay. We should instead focus on helping reduce the rate that this
occurs accidentally, and enabling tooling and diagnostics that warn about
dangerous or surprising patterns.</p><p><strong>The behavior and semantics of code should be clearly and simply specified
whenever possible.</strong> Leaving behavior undefined for some cases of invalid,
buggy, or non-portable code may be necessary, but it comes at a very high cost
and should be avoided. Every case where behavior is left undefined should be
clearly spelled out with a strong rationale for this tradeoff. The code patterns
without defined behavior should be teachable and understandable by developers.
Finally, there must be mechanisms available to detect undefined behavior, at
best statically, and at worst dynamically with high probability and at minimal
cost.</p><p><strong>Adhere to the principle of least surprise.</strong> Defaults should match typical
usage patterns. Implicit features should be unsurprising and expected, while
explicit syntax should inform the reader about any behavior which might
otherwise be surprising. The core concepts of implicit versus explicit syntax
are well articulated in
<a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html#implicit-vs-explicit" target="_blank" rel="noopener noreferrer">the Rust community</a>,
although we may come to different conclusions regarding the principles.</p><p><strong>Design features to be simple to implement.</strong> Syntax, structure, and language
features should be chosen while keeping the implementation complexity
manageable. Simplicity of implementation reduces bugs, and will in most cases
make the features easier to understand. It&#x27;s also often the best way to ensure
predictable performance, although supporting peak performance may require
options for more complex implementation behavior.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practical-safety-and-testing-mechanisms">Practical safety and testing mechanisms<a class="hash-link" href="#practical-safety-and-testing-mechanisms" title="Direct link to heading">​</a></h3><p>Our goal is to add as much language-level safety and security to Carbon as
possible, using a hybrid strategy to balance other goals. We will do as many
safety checks as we can at compile time. We will also provide dynamic runtime
checking and a strong testing methodology ranging from unit tests through
integration and system tests all the way to coverage-directed fuzz testing. We
have specific criteria that are important for this strategy to be successful:</p><p><strong>Make unsafe or risky aspects of Carbon code explicit and syntactically
visible.</strong> This will allow the software to use the precise flexibility needed
and to minimize its exposure, while still aiding the reader. It can also help
the reader more by indicating the specific nature of risk faced by a given
construct. More simply, safe things shouldn&#x27;t look like unsafe things and unsafe
things should be easily recognized when reading code.</p><p><strong>Common patterns of unsafe or risky code must support static checking.</strong>
Waiting until a dynamic check is too late to prevent the most common errors. A
canonical example here are
<a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html" target="_blank" rel="noopener noreferrer">thread-safety annotations</a>
for basic mutex lock management to allow static checking. This handles the
common patterns, and we use dynamic checks, such as TSan and deadlock detection,
to handle edge cases.</p><p><strong>All unsafe or risky operations and interfaces must support some dynamic
checking.</strong> Developers need some way to test and verify that their code using
any such interface is in fact correct. Uncheckable unsafety removes any ability
for the developer to gain confidence. This means we need to design features with
unsafe or risky aspects with dynamic checking in mind. A concrete example of
this can be seen in facilities that allow indexing into an array: such
facilities should be designed to have the bounds of the array available to
implement bounds checking when desirable.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fast-and-scalable-development">Fast and scalable development<a class="hash-link" href="#fast-and-scalable-development" title="Direct link to heading">​</a></h3><p>Software development iteration has a critical &quot;edit, test, debug&quot; cycle.
Developers will use IDEs, editors, compilers, and other tools that need
different levels of parsing. For small projects, raw parsing speed is essential;
for large software systems, scalability of parsing is also necessary.</p><p><strong>Syntax should parse with bounded, small look-ahead.</strong> Syntax that requires
unbounded look-ahead or fully general backtracking adds significant complexity
to parsing and makes it harder to provide high quality error messages. The
result is both slower iteration and more iterations, a multiplicative negative
impact on productivity. Humans aren&#x27;t immune either; they can be confused by
constructs that appear to mean one thing but actually mean another. Instead, we
should design for syntax that is fast to parse, with easy and reliable error
messages.</p><p><strong>No semantic or contextual information used when parsing.</strong> The more context,
and especially the more <em>semantic</em> context, required for merely parsing code,
the fewer options available to improve the performance of tools and compilation.
Cross-file context has an especially damaging effect on the potential
distributed build graph options. Without these options, we will again be unable
to provide fast developer iteration as the codebase scales up.</p><p><strong>Support separate compilation, including parallel and distributed strategies.</strong>
Iteration requires frequent rebuilds of software as part of the edit/test/debug
cycle of development. The language design should enable low-latency build
strategies, particularly when relatively little has changed. This minimally
requires separate compilation of source files, and potentially other incremental
build strategies. Separate compilation also enables better scalability options
for build systems of large software.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="modern-os-platforms-hardware-architectures-and-environments">Modern OS platforms, hardware architectures, and environments<a class="hash-link" href="#modern-os-platforms-hardware-architectures-and-environments" title="Direct link to heading">​</a></h3><p>Carbon must have strong support for all of the major, modern OS platforms, the
hardware architectures they run on, and the environments in which their software
runs. Carbon must also continue supporting these over time, even as which ones
are major or modern evolve and change.</p><p><strong>Provide <em>native</em> support for the programming models of those platforms and
environments.</strong> This goes beyond enabling compile-time translations from one
abstraction to several implementations. While enabling high-level
synchronization primitives like mutexes and futures is good, the underlying
atomic operations provided by the hardware must also be directly available.
Similarly, lowering parallel constructs into a specific implementation, such as
SIMD or SPMD, is good but insufficient. Multiple parallel implementations must
be directly addressable in Carbon. The need for native support repeats across
the landscape of OS platform, hardware, and environment distinctions; for
example, concurrency versus parallelism, and desktop versus mobile.</p><p><strong>Conversely, Carbon cannot prioritize support for historical platforms.</strong> To
use a hockey metaphor, we should not skate to where the puck is, much less where
the puck was twenty years ago. We have existing systems to support those
platforms where necessary. Instead, Carbon should be forward-leaning in its
platform support. As these platforms evolve over time, Carbon will have to
evolve as well to continue to effectively prioritize the modern and major
platforms.</p><p>For examples, please see Carbon&#x27;s
<a href="/docs/project/principles/success_criteria/#modern-os-platforms-hardware-architectures-and-environments">success criteria</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interoperability-with-and-migration-from-existing-c-code">Interoperability with and migration from existing C++ code<a class="hash-link" href="#interoperability-with-and-migration-from-existing-c-code" title="Direct link to heading">​</a></h3><p>We want developers working within existing C++ ecosystems to easily start using
Carbon, without starting from scratch. Adopting Carbon should not require
complete rewrites, new programming models, or building an entire new
stack/ecosystem. This means integrating into the existing C++ ecosystem by
supporting incremental migration from C++ to Carbon, which in turn requires
high-quality interoperability with existing C++ code.</p><p>We must be able to move existing <em>large</em> C++ codebases -- some with hundreds of
millions of lines of code and tens of thousands of active developers -- onto
Carbon. C++ developers must also successfully switch to Carbon development. Any
migration of this scale will take years, will need to be incremental, and some
libraries -- particularly third-party -- may remain in C and C++. It must be
possible to migrate a C++ library to Carbon without simultaneously migrating all
of the libraries it depends on or all of the libraries that depend on it.</p><p>We believe incremental migrations require:</p><p><strong>Familiarity for experienced C++ developers with a gentle learning curve.</strong> We
need a feasible plan for retraining a C++ workforce to become proficient in
Carbon. If long and significant study is required to be minimally proficient,
meaning able to read, superficially understand, and do limited debugging or
modifications, then the inertia of C++ will inevitably win. Further, we need a
gentle and easily traversed learning curve to basic productivity in order for
the transition to not become a chore or otherwise unsustainable for teams and
individuals.</p><p><strong>Expressivity comparable to C++.</strong> If an algorithm or data structure or system
architecture can naturally be written in C++, it should also be possible to
write it naturally in Carbon.</p><p><strong>Automated source-to-source migration of large segments of large-scale
idiomatic C++ code bases with high fidelity.</strong> We will prioritize having very
<a href="/docs/project/principles/success_criteria/#migration-tooling">low human interaction</a> to
achieve high fidelity migration results. We do not require all C++ code to be
migratable in this fashion, and the resulting Carbon may be non-idiomatic. We
can add reasonable constraints here if those constraints are already well
established best practices for C++ development, including design patterns,
testing coverage, or usage of sanitizers. Over many years, as Carbon evolves and
codebases have had time to migrate, the results of the tooling may also drift
further from idiomatic Carbon and have less desirable results.</p><p><strong>Support for bi-directional interoperability with existing C++ code.</strong> We need
Carbon code to be able to call into C and C++ libraries with both reasonable API
clarity and high performance. We will also need some ability to implement C++
interfaces with business logic in Carbon, although this direction can tolerate
slightly more constraints both in supported features and performance overhead.
In all cases, the particular performance overhead imposed by moving between C++
and Carbon will need to be easily exposed and understood by developers. While a
given piece code only needs to be migrated once, we expect interoperability to
be invoked continuously to support migrated code and will thus remain important
for most developers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="non-goals">Non-goals<a class="hash-link" href="#non-goals" title="Direct link to heading">​</a></h2><p>There are common or expected goals of many programming languages that we
explicitly call out as non-goals for Carbon. That doesn&#x27;t make these things bad
in any way, but reflects the fact that they do not provide meaningful value to
us and come with serious costs and/or risks.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="stable-language-and-library-abi">Stable language and library ABI<a class="hash-link" href="#stable-language-and-library-abi" title="Direct link to heading">​</a></h3><p>We would prefer to provide better, dedicated mechanisms to decompose software
subsystems in ways that scale over time rather than providing a stable ABI
across the Carbon language and libraries. Our experience is that providing broad
ABI-level stability for high-level constructs is a significant and permanent
burden on their design. It becomes an impediment to evolution, which is one of
our stated goals.</p><p>This doesn&#x27;t preclude having low-level language features or tools to create
specific and curated stable ABIs, or even serializable protocols. Using any such
facilities will also cause developers to explicitly state where they are relying
on ABI and isolating it in source from code which does not need that stability.
However, these facilities would only expose a restricted set of language
features to avoid coupling the high-level language to particular stabilized
interfaces. There is a wide range of such facilities that should be explored,
from serialization-based systems like
<a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener noreferrer">protobufs</a> or
<a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="noopener noreferrer">pickling in Python</a>, to other
approaches like
<a href="https://docs.microsoft.com/en-us/windows/win32/com/com-objects-and-interfaces" target="_blank" rel="noopener noreferrer">COM</a>
or Swift&#x27;s <a href="https://swift.org/blog/library-evolution/" target="_blank" rel="noopener noreferrer">&quot;resilience&quot;</a> model. The
specific approach should be designed around the goals outlined above in order to
fit the Carbon language.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="backwards-or-forwards-compatibility">Backwards or forwards compatibility<a class="hash-link" href="#backwards-or-forwards-compatibility" title="Direct link to heading">​</a></h3><p>Our goals are focused on <em>migration</em> from one version of Carbon to the next
rather than <em>compatibility</em> between them. This is rooted in our experience with
evolving software over time more generally and a
<a href="https://abseil.io/blog/20171004-cppcon-plenary" target="_blank" rel="noopener noreferrer">live-at-head model</a>. Any
transition, whether based on backward compatibility or a migration plan, will
require some manual intervention despite our best efforts, due to
<a href="http://www.hyrumslaw.com" target="_blank" rel="noopener noreferrer">Hyrum&#x27;s Law</a>, and so we should acknowledge that
upgrades require active migrations.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="legacy-compiled-libraries-without-source-code-or-ability-to-rebuild">Legacy compiled libraries without source code or ability to rebuild<a class="hash-link" href="#legacy-compiled-libraries-without-source-code-or-ability-to-rebuild" title="Direct link to heading">​</a></h3><p>We consider it a non-goal to support legacy code for which the source code is no
longer available, though we do sympathize with such use cases and would like the
tooling mentioned above to allow easier bridging between ABIs in these cases.
Similarly, plugin ABIs aren’t our particular concern, yet we’re interested in
seeing tooling which can help bridge between programs and plugins which use
different ABIs.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="support-for-existing-compilation-and-linking-models">Support for existing compilation and linking models<a class="hash-link" href="#support-for-existing-compilation-and-linking-models" title="Direct link to heading">​</a></h3><p>While it is essential to have interoperability with C++, we are willing to
change the compilation and linking model of C++ itself to enable this if
necessary. Compilation models and linking models should be designed to suit the
needs of Carbon and its use cases, tools, and environments, not what happens to
have been implemented thus far in compilers and linkers.</p><p>As a concrete example, Carbon will not support platforms that cannot update
their compiler and linker alongside the language.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="idiomatic-migration-of-non-modern-non-idiomatic-c-code">Idiomatic migration of non-modern, non-idiomatic C++ code<a class="hash-link" href="#idiomatic-migration-of-non-modern-non-idiomatic-c-code" title="Direct link to heading">​</a></h3><p>While large-scale, tool-assisted migration of C++ code to Carbon is an explicit
goal, handling all C++ code with this is expressly not a goal. There is likely a
great deal of C++ code that works merely by chance or has serious flaws that
prevent us from understanding the developer&#x27;s intent. While we may be able to
provide a minimally &quot;correct&quot; migration to very unfriendly code, mechanically
reproducing exact C++ semantics even if bizarre, even this is not guaranteed and
improving on it is not a goal. Migration support will prioritize code that
adheres to reasonable C++ best practices, such as avoiding undefined behavior,
maintaining good test coverage, and validating tests with sanitizers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="prioritization-beyond-goals">Prioritization beyond goals<a class="hash-link" href="#prioritization-beyond-goals" title="Direct link to heading">​</a></h2><p>The features, tools, and other efforts of Carbon should be prioritized based on
a clearly articulated rationale. This may be based on this document&#x27;s
overarching goals and priorities, or if those don&#x27;t offer enough clarity, we
will fall back on rationale such as a required implementation order or a
cost-benefit analysis.</p><p><strong>Cost-benefit will drive many choices.</strong> We expect to measure both cost,
including complexity, and benefit using the impact on the project and language
as a whole. Benefit accumulates over time, which means providing incremental
solutions earlier will typically increase total benefit. It is also reasonable
for the rationale of a decision to factor in both effort already invested, and
effort ready to commit to the feature. This should not overwhelm any fundamental
cost-benefit analysis. However, given two equally impactful features, we should
focus on the solution that is moving the fastest.</p><p><strong>Domain-motivated libraries and features are an example.</strong> For these, the cost
function will typically be the effort required to specify and implement the
feature. Benefit will stem from the number of users and how much utility the
feature provides. We don&#x27;t expect to have concrete numbers for these, but we
expect prioritization decisions between features to be expressed using this
framework.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="acknowledgements">Acknowledgements<a class="hash-link" href="#acknowledgements" title="Direct link to heading">​</a></h2><p>Carbon&#x27;s goals are heavily based on
<a href="https://wg21.link/p2137" target="_blank" rel="noopener noreferrer">&quot;Goals and priorities for C++&quot;</a>. Many thanks to the
authors and contributors for helping us formulate our goals and priorities.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/project/goals.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/project/faq/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Project FAQ</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/project/groups/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Groups</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#project-goals" class="table-of-contents__link toc-highlight">Project goals</a><ul><li><a href="#community-and-culture" class="table-of-contents__link toc-highlight">Community and culture</a></li><li><a href="#language-tools-and-ecosystem" class="table-of-contents__link toc-highlight">Language tools and ecosystem</a></li></ul></li><li><a href="#language-goals-and-priorities" class="table-of-contents__link toc-highlight">Language goals and priorities</a><ul><li><a href="#performance-critical-software" class="table-of-contents__link toc-highlight">Performance-critical software</a></li><li><a href="#software-and-language-evolution" class="table-of-contents__link toc-highlight">Software and language evolution</a></li><li><a href="#code-that-is-easy-to-read-understand-and-write" class="table-of-contents__link toc-highlight">Code that is easy to read, understand, and write</a></li><li><a href="#practical-safety-and-testing-mechanisms" class="table-of-contents__link toc-highlight">Practical safety and testing mechanisms</a></li><li><a href="#fast-and-scalable-development" class="table-of-contents__link toc-highlight">Fast and scalable development</a></li><li><a href="#modern-os-platforms-hardware-architectures-and-environments" class="table-of-contents__link toc-highlight">Modern OS platforms, hardware architectures, and environments</a></li><li><a href="#interoperability-with-and-migration-from-existing-c-code" class="table-of-contents__link toc-highlight">Interoperability with and migration from existing C++ code</a></li></ul></li><li><a href="#non-goals" class="table-of-contents__link toc-highlight">Non-goals</a><ul><li><a href="#stable-language-and-library-abi" class="table-of-contents__link toc-highlight">Stable language and library ABI</a></li><li><a href="#backwards-or-forwards-compatibility" class="table-of-contents__link toc-highlight">Backwards or forwards compatibility</a></li><li><a href="#legacy-compiled-libraries-without-source-code-or-ability-to-rebuild" class="table-of-contents__link toc-highlight">Legacy compiled libraries without source code or ability to rebuild</a></li><li><a href="#support-for-existing-compilation-and-linking-models" class="table-of-contents__link toc-highlight">Support for existing compilation and linking models</a></li><li><a href="#idiomatic-migration-of-non-modern-non-idiomatic-c-code" class="table-of-contents__link toc-highlight">Idiomatic migration of non-modern, non-idiomatic C++ code</a></li></ul></li><li><a href="#prioritization-beyond-goals" class="table-of-contents__link toc-highlight">Prioritization beyond goals</a></li><li><a href="#acknowledgements" class="table-of-contents__link toc-highlight">Acknowledgements</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/ZjVdShJDAs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer" class="footer__link-item">Code of Conduct<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
<script src="/assets/js/runtime~main.e89ea4d0.js"></script>
<script src="/assets/js/main.6441d3bf.js"></script>
</body>
</html>