<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-docs/design/generics/terminology">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-rc.1">
<title data-rh="true">Generics: Terminology | Carbon Language</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://carbon-language.github.io/docs/design/generics/terminology/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Generics: Terminology | Carbon Language"><meta data-rh="true" name="description" content="&lt;!--"><meta data-rh="true" property="og:description" content="&lt;!--"><link data-rh="true" rel="icon" href="/img/carbon-logo.png"><link data-rh="true" rel="canonical" href="https://carbon-language.github.io/docs/design/generics/terminology/"><link data-rh="true" rel="alternate" href="https://carbon-language.github.io/docs/design/generics/terminology/" hreflang="en"><link data-rh="true" rel="alternate" href="https://carbon-language.github.io/docs/design/generics/terminology/" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.868a9bd8.css">
<link rel="preload" href="/assets/js/runtime~main.576a8e32.js" as="script">
<link rel="preload" href="/assets/js/main.52935302.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Carbon Language</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/design/">Design</a><a class="navbar__item navbar__link" href="/docs/project/">Project</a><a class="navbar__item navbar__link" href="/docs/guides/">Guides</a><a class="navbar__item navbar__link" href="/docs/spec/">Spec</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/">Language design</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/aliases/">Aliases</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/blocks_and_statements/">Blocks and statements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/classes/">Classes</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/design/code_and_name_organization/">Code and name organization</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code and name organization&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/design/control_flow/">Control flow</a><button aria-label="Toggle the collapsible sidebar category &#x27;Control flow&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/design/expressions/">Expressions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Expressions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/functions/">Functions</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/design/generics/">Generics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Generics&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/generics/appendix-coherence/">Carbon: alternatives to coherence</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/generics/details/">Generics: Details</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/generics/goals/">Generics: Goals</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/generics/overview/">Generics: Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/design/generics/terminology/">Generics: Terminology</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/design/interoperability/">Bidirectional interoperability with C/C++</a><button aria-label="Toggle the collapsible sidebar category &#x27;Bidirectional interoperability with C/C++&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/design/lexical_conventions/">Lexical conventions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Lexical conventions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/metaprogramming/">Metaprogramming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/name_lookup/">Name lookup</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/naming_conventions/">Naming conventions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/pattern_matching/">Pattern matching</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/primitive_types/">Primitive types</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/templates/">Templates</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/tuples/">Tuples</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/type_inference/">Type inference</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/variables/">Variables</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/design/generics/"><span itemprop="name">Generics</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Generics: Terminology</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Generics: Terminology</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="table-of-contents">Table of contents<a class="hash-link" href="#table-of-contents" title="Direct link to heading">​</a></h2><ul><li><a href="#parameterized-language-constructs">Parameterized language constructs</a></li><li><a href="#generic-versus-template-parameters">Generic versus template parameters</a><ul><li><a href="#polymorphism">Polymorphism</a><ul><li><a href="#parametric-polymorphism">Parametric polymorphism</a></li><li><a href="#compile-time-duck-typing">Compile-time duck typing</a></li><li><a href="#ad-hoc-polymorphism">Ad-hoc polymorphism</a></li></ul></li><li><a href="#constrained-genericity">Constrained genericity</a></li><li><a href="#dependent-names">Dependent names</a></li><li><a href="#definition-checking">Definition checking</a><ul><li><a href="#complete-definition-checking">Complete definition checking</a></li><li><a href="#early-versus-late-type-checking">Early versus late type checking</a></li></ul></li></ul></li><li><a href="#deduced-parameter">Deduced parameter</a></li><li><a href="#interface">Interface</a><ul><li><a href="#structural-interfaces">Structural interfaces</a></li><li><a href="#nominal-interfaces">Nominal interfaces</a></li><li><a href="#named-constraints">Named constraints</a></li></ul></li><li><a href="#associated-entity">Associated entity</a></li><li><a href="#impls-implementations-of-interfaces">Impls: Implementations of interfaces</a><ul><li><a href="#internal-impl">Internal impl</a></li><li><a href="#external-impl">External impl</a></li></ul></li><li><a href="#member-access">Member access</a><ul><li><a href="#simple-member-access">Simple member access</a></li><li><a href="#qualified-member-access-expression">Qualified member access expression</a></li></ul></li><li><a href="#compatible-types">Compatible types</a></li><li><a href="#subtyping-and-casting">Subtyping and casting</a></li><li><a href="#coherence">Coherence</a></li><li><a href="#adapting-a-type">Adapting a type</a></li><li><a href="#type-erasure">Type erasure</a></li><li><a href="#archetype">Archetype</a></li><li><a href="#extending-an-interface">Extending an interface</a></li><li><a href="#witness-tables">Witness tables</a><ul><li><a href="#dynamic-dispatch-witness-table">Dynamic-dispatch witness table</a></li><li><a href="#static-dispatch-witness-table">Static-dispatch witness table</a></li></ul></li><li><a href="#instantiation">Instantiation</a></li><li><a href="#specialization">Specialization</a><ul><li><a href="#template-specialization">Template specialization</a></li><li><a href="#generic-specialization">Generic specialization</a></li></ul></li><li><a href="#conditional-conformance">Conditional conformance</a></li><li><a href="#interface-type-parameters-and-associated-types">Interface type parameters and associated types</a></li><li><a href="#type-constraints">Type constraints</a></li><li><a href="#type-of-type">Type-of-type</a></li><li><a href="#references">References</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="parameterized-language-constructs">Parameterized language constructs<a class="hash-link" href="#parameterized-language-constructs" title="Direct link to heading">​</a></h2><p>Generally speaking, when we talk about either templates or a generics system, we
are talking about generalizing some language construct by adding a parameter to
it. Language constructs here primarily would include functions and types, but we
may want to support parameterizing other language constructs like
<a href="#interface-type-parameters-and-associated-types">interfaces</a>.</p><p>This parameter broadens the scope of the language construct on an axis defined
by that parameter, for example it could define a family of functions instead of
a single one.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="generic-versus-template-parameters">Generic versus template parameters<a class="hash-link" href="#generic-versus-template-parameters" title="Direct link to heading">​</a></h2><p>When we are distinguishing between generics and templates in Carbon, it is on an
parameter by parameter basis. A single function can take a mix of regular,
generic, and template parameters.</p><ul><li><strong>Regular parameters</strong>, or &quot;dynamic parameters&quot;, are designated using the
&quot;<!-- -->&lt;<!-- -->name&gt;<code>:</code> <!-- -->&lt;<!-- -->type&gt;&quot; syntax (or &quot;<!-- -->&lt;<!-- -->value&gt;&quot;).</li><li><strong>Generic parameters</strong> are designated using <code>:!</code> between the name and the
type (so it is &quot;<!-- -->&lt;<!-- -->name&gt;<code>:!</code> <!-- -->&lt;<!-- -->type&gt;&quot;).</li><li><strong>Template parameters</strong> are designated using &quot;<code>template</code> <!-- -->&lt;<!-- -->name&gt;<code>:!</code>&lt;<!-- -->type&gt;&quot;.</li></ul><p>The syntax for generic and template parameters was decided in
<a href="https://github.com/carbon-language/carbon-lang/issues/565" target="_blank" rel="noopener noreferrer">questions-for-leads issue #565</a>.</p><p>Expected difference between generics and templates:</p><table><tr><td><strong>Generics</strong></td><td><strong>Templates</strong></td></tr><tr><td>bounded parametric polymorphism</td><td>compile-time duck typing and ad-hoc polymorphism</td></tr><tr><td>constrained genericity</td><td>optional constraints</td></tr><tr><td>name lookup resolved for definitions in isolation (&quot;early&quot;)</td><td>some name lookup may require information from calls (name lookup may be &quot;late&quot;)</td></tr><tr><td>sound to typecheck definitions in isolation (&quot;early&quot;)</td><td>complete type checking may require information from calls (may be &quot;late&quot;)</td></tr><tr><td>supports separate type checking; may also support separate compilation, for example when implemented using dynamic witness tables</td><td>separate compilation only to the extent that C++ supports it</td></tr><tr><td>allowed but not required to be implemented using dynamic dispatch</td><td>does not support implementation by way of dynamic dispatch, just static by way of <a href="#instantiation">instantiation</a></td></tr><tr><td>monomorphization is an optional optimization that cannot render the program invalid</td><td>monomorphization is mandatory and can fail, resulting in the program being invalid</td></tr></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="polymorphism">Polymorphism<a class="hash-link" href="#polymorphism" title="Direct link to heading">​</a></h3><p>Generics and templates provide different forms of
<a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" target="_blank" rel="noopener noreferrer">polymorphism</a>
than object-oriented programming with inheritance. That uses
<a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener noreferrer">subtype polymorphism</a> where different
descendants, or &quot;subtypes&quot;, of a base class can provide different
implementations of a method, subject to some compatibility restrictions on the
signature.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="parametric-polymorphism">Parametric polymorphism<a class="hash-link" href="#parametric-polymorphism" title="Direct link to heading">​</a></h4><p>Parametric polymorphism
(<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism" target="_blank" rel="noopener noreferrer">Wikipedia</a>) is when a
function or a data type can be written generically so that it can handle values
<em>identically</em> without depending on their type.
<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism#Bounded_parametric_polymorphism" target="_blank" rel="noopener noreferrer">Bounded parametric polymorphism</a>
is where the allowed types are restricted to satisfy some constraints. Within
the set of allowed types, different types are treated uniformly.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="compile-time-duck-typing">Compile-time duck typing<a class="hash-link" href="#compile-time-duck-typing" title="Direct link to heading">​</a></h4><p>Duck typing (<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener noreferrer">Wikipedia</a>) is when the
legal types for arguments are determined implicitly by the usage of the values
of those types in the body of the function. Compile-time duck typing is when the
usages in the body of the function are checked at compile-time, along all code
paths. Contrast this with ordinary duck typing in a dynamic language such as
Python where type errors are only diagnosed at runtime when a usage is reached
dynamically.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ad-hoc-polymorphism">Ad-hoc polymorphism<a class="hash-link" href="#ad-hoc-polymorphism" title="Direct link to heading">​</a></h4><p>Ad-hoc polymorphism
(<a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism" target="_blank" rel="noopener noreferrer">Wikipedia</a>), also known as
&quot;overloading&quot;, is when a single function name has multiple implementations for
handling different argument types. There is no enforcement of any consistency
between the implementations. For example, the return type of each overload can
be arbitrary, rather than being the result of some consistent rule being applied
to the argument types.</p><p>Templates work with ad-hoc polymorphism in two ways:</p><ul><li>A function with template parameters can be
<a href="#template-specialization">specialized</a> in
<a href="https://en.cppreference.com/w/cpp/language/template_specialization" target="_blank" rel="noopener noreferrer">C++</a> as
a form of ad-hoc polymorphism.</li><li>A function with template parameters can call overloaded functions since it
will only resolve that call after the types are known.</li></ul><p>In Carbon, we expect there to be a compile error if overloading of some name
prevents a generic function from being typechecked from its definition alone.
For example, let&#x27;s say we have some overloaded function called <code>F</code> that has two
overloads:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[template T:! Type](x: T*) -&gt; T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F(x: Int) -&gt; Bool;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A generic function <code>G</code> can call <code>F</code> with a type like <code>T*</code> that can not possibly
call the <code>F(Int)</code> overload for <code>F</code>, and so it can consistently determine the
return type of <code>F</code>. But <code>G</code> can&#x27;t call <code>F</code> with an argument that could match
either overload.</p><p><strong>Note:</strong> It is undecided what to do in the situation where <code>F</code> is overloaded,
but the signatures are consistent and so callers could still typecheck calls to
<code>F</code>. This still poses problems for the dynamic strategy for compiling generics,
in a similar way to impl specialization.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="constrained-genericity">Constrained genericity<a class="hash-link" href="#constrained-genericity" title="Direct link to heading">​</a></h3><p>We will allow some way of specifying constraints as part of a function (or type
or other parameterized language construct). These constraints are a limit on
what callers are allowed to pass in. The distinction between constrained and
unconstrained genericity is whether the body of the function is limited to just
those operations that are guaranteed by the constraints.</p><p>With templates using unconstrained genericity, you may perform any operation in
the body of the function, and they will be checked against the specific types
used in calls. You can still have constraints, but they are optional in that
they could be removed and the function would still have the same capabilities.
Constraints only affect the caller, which will use them to resolve overloaded
calls to the template and provide clearer error messages.</p><p>With generics using constrained genericity, the function body can be checked
against the signature at the time of definition. Note that it is still perfectly
permissible to have no constraints on a type; that just means that you can only
perform operations that work for all types (such as manipulate pointers to
values of that type) in the body of the function.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dependent-names">Dependent names<a class="hash-link" href="#dependent-names" title="Direct link to heading">​</a></h3><p>A name is said to be <em>dependent</em> if it depends on some generic or template
parameter. Note: this matches
<a href="https://www.google.com/search?q=c%2B%2B+dependent+name" target="_blank" rel="noopener noreferrer">the use of the term &quot;dependent&quot; in C++</a>,
not as in <a href="https://en.wikipedia.org/wiki/Dependent_type" target="_blank" rel="noopener noreferrer">dependent types</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="definition-checking">Definition checking<a class="hash-link" href="#definition-checking" title="Direct link to heading">​</a></h3><p>Definition checking is the process of semantically checking the definition of
parameterized code for correctness <em>independently</em> of any particular arguments.
It includes type checking and other semantic checks. It is possible, even with
templates, to check semantics of expressions that are not
<a href="#dependent-names">dependent</a> on any template parameter in the definition.
Adding constraints to template parameters and/or switching them to be generic
allows the compiler to increase how much of the definition can be checked. Any
remaining checks are delayed until <a href="#instantiation">instantiation</a>, which can
fail.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="complete-definition-checking">Complete definition checking<a class="hash-link" href="#complete-definition-checking" title="Direct link to heading">​</a></h4><p>Complete definition checking is when the definition can be <em>fully</em> semantically
checked, including type checking. It is an especially useful property because it
enables <em>separate</em> semantic checking of the definition, a prerequisite to
separate compilation. It also enables implementation strategies that don’t
instantiate the implementation (for example, <a href="#type-erasure">type erasure</a> or
<a href="#dynamic-dispatch-witness-table">dynamic-dispatch witness tables</a>).</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="early-versus-late-type-checking">Early versus late type checking<a class="hash-link" href="#early-versus-late-type-checking" title="Direct link to heading">​</a></h4><p>Early type checking is where expressions and statements are type checked when
the definition of the function body is compiled, as part of definition checking.
This occurs for regular and generic values.</p><p>Late type checking is where expressions and statements may only be fully
typechecked once calling information is known. Late type checking delays
complete definition checking. This occurs for
<a href="#dependent-names">template-dependent</a> values.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="deduced-parameter">Deduced parameter<a class="hash-link" href="#deduced-parameter" title="Direct link to heading">​</a></h2><p>An deduced parameter is listed in the optional <code>[</code> <code>]</code> section right after the
function name in a function signature:</p><p><code>fn</code> <!-- -->&lt;<!-- -->name&gt; <code>[</code> <!-- -->&lt;<!-- -->deduced parameters&gt; <code>](</code> <!-- -->&lt;<!-- -->explicit parameters <code>) -&gt;</code>
<!-- -->&lt;<!-- -->return type&gt;</p><p>Deduced arguments are determined as a result of pattern matching the explicit
argument values (usually the types of those values) to the explicit parameters.
Note that function signatures can typically be rewritten to avoid using deduced
parameters:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[template T:! Type](value: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// is equivalent to:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F(value: (template T:! Type));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See more <a href="/docs/design/generics/overview/#deduced-parameters">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interface">Interface<a class="hash-link" href="#interface" title="Direct link to heading">​</a></h2><p>An interface is an API constraint used in a function signature to provide
encapsulation. Encapsulation here means that callers of the function only need
to know about the interface requirements to call the function, not anything
about the implementation of the function body, and the compiler can check the
function body without knowing anything more about the caller. Callers of the
function provide a value that has an implementation of the API and the body of
the function may then use that API (and nothing else).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="structural-interfaces">Structural interfaces<a class="hash-link" href="#structural-interfaces" title="Direct link to heading">​</a></h3><p>A &quot;structural&quot; interface is one where we say a type satisfies the interface as
long as it has members with a specific list of names, and for each name it must
have some type or signature. A type can satisfy a structural interface without
ever naming that interface, just by virtue of having members with the right
form.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nominal-interfaces">Nominal interfaces<a class="hash-link" href="#nominal-interfaces" title="Direct link to heading">​</a></h3><p>A &quot;nominal&quot; interface is one where we say a type can only satisfy an interface
if there is some explicit statement saying so, for example by defining an
<a href="#impls-implementations-of-interfaces">impl</a>. This allows &quot;satisfies the
interface&quot; to have additional semantic meaning beyond what is directly checkable
by the compiler. For example, knowing whether the <code>Draw</code> function means &quot;render
an image to the screen&quot; or &quot;take a card from the top of a deck of cards&quot;; or
that a <code>+</code> operator is commutative (and not, say, string concatenation).</p><p>We use the &quot;structural&quot; versus &quot;nominal&quot; terminology as a generalization of the
same terms being used in a
<a href="https://en.wikipedia.org/wiki/Subtyping#Subtyping_schemes" target="_blank" rel="noopener noreferrer">subtyping context</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="named-constraints">Named constraints<a class="hash-link" href="#named-constraints" title="Direct link to heading">​</a></h3><p>Named constraints are &quot;structural&quot; in the sense that they match a type based on
meeting some criteria rather than an explicit statement in the type&#x27;s
definition. The criteria for a named constraint, however, are less focused on
the type&#x27;s API and instead might include a set of nominal interfaces that the
type must implement and constraints on the
<a href="#associated-entity">associated entities</a> and
<a href="#interface-type-parameters-and-associated-types">interface type parameters</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="associated-entity">Associated entity<a class="hash-link" href="#associated-entity" title="Direct link to heading">​</a></h2><p>An <em>associated entity</em> is a requirement in an interface that a type&#x27;s
implementation of the interface must satisfy by having a matching member. A
requirement that the type define a value for a member constant is called an
<em>associated constant</em>, and similarly an <em>associated function</em> or <em>associated
type</em>.</p><p>Different types can satisfy an interface with different definitions for a given
member. These definitions are <em>associated</em> with what type is implementing the
interface. An <a href="#impls-implementations-of-interfaces">impl</a> defines what is
associated with the type for that interface.</p><p>Rust uses the term
<a href="https://doc.rust-lang.org/reference/items/associated-items.html" target="_blank" rel="noopener noreferrer">&quot;associated item&quot;</a>
instead of associated entity.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="impls-implementations-of-interfaces">Impls: Implementations of interfaces<a class="hash-link" href="#impls-implementations-of-interfaces" title="Direct link to heading">​</a></h2><p>An <em>impl</em> is an implementation of an interface for a specific type. It is the
place where the function bodies are defined, values for associated types, etc.
are given. Impls are needed for <a href="#nominal-interfaces">nominal interfaces</a>;
<a href="#structural-interfaces">structural interfaces</a> and
<a href="#named-constraints">named constraints</a> define conformance implicitly instead of
by requiring an impl to be defined. In can still make sense to implement a named
constraint as a way to implement all of the interfaces it requires.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="internal-impl">Internal impl<a class="hash-link" href="#internal-impl" title="Direct link to heading">​</a></h3><p>A type that implements an interface <em>internally</em> has all the named members of
the interface as named members of the type. This means that the members of the
interface are available by way of both
<a href="#member-access">simple member access and qualified member access expressions</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="external-impl">External impl<a class="hash-link" href="#external-impl" title="Direct link to heading">​</a></h3><p>In contrast, a type that implements an interface <em>externally</em> does not include
the named members of the interface in the type. The members of the interface are
still implemented by the type, though, and so may be accessed using
<a href="#qualified-member-access-expression">qualified member access expressions</a> for
those members.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="member-access">Member access<a class="hash-link" href="#member-access" title="Direct link to heading">​</a></h2><p>There are two different kinds of member access: <em>simple</em> and <em>compound</em>. See the
<a href="/docs/design/expressions/member_access/">member access design document</a> for
the details. The application to generics combines compound member access with
qualified names, which we call a <em>qualified member access expression</em>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="simple-member-access">Simple member access<a class="hash-link" href="#simple-member-access" title="Direct link to heading">​</a></h3><p>Simple member access has the from <code>object.member</code>, where <code>member</code> is a word
naming a member of <code>object</code>. This form may be used to access members of
interfaces <a href="#internal-impl">implemented internally</a> by the type of <code>object</code>.</p><p>If <code>String</code> implements <code>Printable</code> internally, then <code>s1.Print()</code> calls the
<code>Print</code> method of <code>Printable</code> using simple member access. In this case, the name
<code>Print</code> is used without qualifying it with the name of the interface it is a
member of since it is recognized as a member of the type itself as well.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="qualified-member-access-expression">Qualified member access expression<a class="hash-link" href="#qualified-member-access-expression" title="Direct link to heading">​</a></h3><p>Compound member access has the form <code>object.(expression)</code>, where <code>expression</code> is
resolved in the containing scope. A compound member access where the member
expression is a simple member access expression, as in <code>a.(context.b)</code>, is
called a <em>qualified member access expression</em>. The member expression <code>context.b</code>
may be the <em>qualified member name</em> of an interface member, that consists of the
name of the interface, possibly qualified with a package or namespace name, a
dot <code>.</code> and the name of the member.</p><p>For example, if the <code>Comparable</code> interface has a <code>Less</code> member method, then the
qualified name of that member is <code>Comparable.Less</code>. So if <code>String</code> implements
<code>Comparable</code>, and <code>s1</code> and <code>s2</code> are variables of type <code>String</code>, then the <code>Less</code>
method may be called using the qualified member name by writing the qualified
member access expression <code>s1.(Comparable.Less)(s2)</code>.</p><p>This form may be used to access any member of an interface implemented for a
type, whether it is implemented <a href="#internal-impl">internally</a> or
<a href="#external-impl">externally</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="compatible-types">Compatible types<a class="hash-link" href="#compatible-types" title="Direct link to heading">​</a></h2><p>Two types are compatible if they have the same notional set of values and
represent those values in the same way, even if they expose different APIs. The
representation of a type describes how the values of that type are represented
as a sequence of bits in memory. The set of values of a type includes properties
that the compiler can&#x27;t directly see, such as invariants that the type
maintains.</p><p>We can&#x27;t just say two types are compatible based on structural reasons. Instead,
we have specific constructs that create compatible types from existing types in
ways that encourage preserving the programmer&#x27;s intended semantics and
invariants, such as implementing the API of the new type by calling (public)
methods of the original API, instead of accessing any private implementation
details.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="subtyping-and-casting">Subtyping and casting<a class="hash-link" href="#subtyping-and-casting" title="Direct link to heading">​</a></h2><p>Both subtyping and casting are different names for changing the type of a value
to a compatible type.</p><p><a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener noreferrer">Subtyping</a> is a relationship between
two types where you can safely operate on a value of one type using a variable
of another. For example, using C++&#x27;s object-oriented features, you can operate
on a value of a derived class using a pointer to the base class. In most cases,
you can pass a more specific type to a function that can handle a more general
type. Return types work the opposite way, a function can return a more specific
type to a caller prepared to handle a more general type. This determines how
function signatures can change from base class to derived class, see
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank" rel="noopener noreferrer">covariance and contravariance in Wikipedia</a>.</p><p>In a generics context, we are specifically interested in the subtyping
relationships between <a href="#type-of-type">type-of-types</a>. In particular, a
type-of-type encompasses a set of <a href="#type-constraints">type constraints</a>, and you
can convert a type from a more-restrictive type-of-type to another type-of-type
whose constraints are implied by the first. C++ concepts terminology uses the
term
<a href="https://en.cppreference.com/w/cpp/language/constraints#Partial_ordering_of_constraints" target="_blank" rel="noopener noreferrer">&quot;subsumes&quot;</a>
to talk about this partial ordering of constraints, but we avoid that term since
it is at odds with the use of the term in
<a href="https://en.wikipedia.org/wiki/Subtyping#Subsumption" target="_blank" rel="noopener noreferrer">object-oriented subtyping terminology</a>.</p><p>Note that subtyping is a bit like
<a href="https://en.wikipedia.org/wiki/Type_conversion" target="_blank" rel="noopener noreferrer">coercion</a>, except we want to
make it clear that the data representation of the value is not changing, just
its type as reflected in the API available to manipulate the value.</p><p>Casting is indicated explicitly by way of some syntax in the source code. You
might use a cast to switch between <a href="#adapting-a-type">type adaptations</a>, or to
be explicit where an implicit conversion would otherwise occur. For now, we are
saying &quot;<code>x as y</code>&quot; is the provisional syntax in Carbon for casting the value <code>x</code>
to the type <code>y</code>. Note that outside of generics, the term &quot;casting&quot; includes any
explicit type change, including those that change the data representation.</p><p>In contexts where an expression of one type is provided and a different type is
required, an <a href="/docs/design/expressions/implicit_conversions/">implicit conversion</a> is
performed if it is considered safe to do so. Such an implicit conversion, if
permitted, always has the same meaning as an explicit cast.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="coherence">Coherence<a class="hash-link" href="#coherence" title="Direct link to heading">​</a></h2><p>A generics system has the <em>implementation coherence</em> property, or simply
<em>coherence</em>, if there is a single answer to the question &quot;what is the
implementation of this interface for this type, if any?&quot; independent of context,
such as the libraries imported into a given file.</p><p>This is typically enforced by making sure the definition of the implementation
must be imported if you import both the interface and the type. This may be done
by requiring the implementation to be in the same library as the interface or
type. This is called an <em>orphan rule</em>, meaning we don&#x27;t allow an implementation
that is not with either of its parents (parent type or parent interface).</p><p>Note that in addition to an orphan rule that implementations are visible when
queried, coherence also requires a rule for resolving what happens if there are
multiple non-orphan implementations. In Rust, this is called the
<a href="https://rust-lang.github.io/chalk/book/clauses/coherence.html#chalk-overlap-check" target="_blank" rel="noopener noreferrer">overlap rule or overlap check</a>.
This could be just producing an error in that situation, or picking one using
some specialization rule.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="adapting-a-type">Adapting a type<a class="hash-link" href="#adapting-a-type" title="Direct link to heading">​</a></h2><p>A type can be adapted by creating a new type that is
<a href="#compatible-types">compatible</a> with an existing type, but has a different API.
In particular, the new type might implement different interfaces or provide
different implementations of the same interfaces.</p><p>Unlike extending a type (as with C++ class inheritance), you are not allowed to
add new data fields onto the end of the representation -- you may only change
the API. This means that it is safe to <a href="#subtyping-and-casting">cast</a> a value
between those two types without any dynamic checks or danger of
<a href="https://en.wikipedia.org/wiki/Object_slicing" target="_blank" rel="noopener noreferrer">object slicing</a>.</p><p>This is called &quot;newtype&quot; in Rust, and is used for capturing additional
information in types to improve type safety by moving some checking to compile
time (<a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction" target="_blank" rel="noopener noreferrer">2</a>,
<a href="https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html" target="_blank" rel="noopener noreferrer">3</a>)
and as a workaround for
<a href="https://github.com/Ixrec/rust-orphan-rules#why-are-the-orphan-rules-controversial" target="_blank" rel="noopener noreferrer">Rust&#x27;s orphan rules for coherence</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="type-erasure">Type erasure<a class="hash-link" href="#type-erasure" title="Direct link to heading">​</a></h2><p>&quot;Type erasure&quot; is where a type&#x27;s API is replaced by a subset. Everything outside
of the preserved subset is said to have been &quot;erased&quot;. This can happen in a
variety of contexts including both generics and runtime polymorphism. For
generics, type erasure restricts a type to just the API required by the
constraints on a generic function.</p><p>An example of type erasure in runtime polymorphism in C++ is casting from a
pointer of a derived type to a pointer to an abstract base type. Only the API of
the base type is available on the result, even though the implementation of
those methods still come from the derived type.</p><p>The term &quot;type erasure&quot; can also refer to
<a href="https://en.wikipedia.org/wiki/Generics_in_Java" target="_blank" rel="noopener noreferrer">the specific strategy used by Java to implement generics</a>.
which includes erasing the identity of type parameters. This is not the meaning
of &quot;type erasure&quot; used in Carbon.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="archetype">Archetype<a class="hash-link" href="#archetype" title="Direct link to heading">​</a></h2><p>A placeholder type is used when type checking a function in place of a generic
type parameter. This allows type checking when the specific type to be used is
not known at type checking time. The type satisfies just its constraint and no
more, so it acts as the most general type satisfying the interface. In this way
the archetype is the supertype of all types satisfying the interface.</p><p>In addition to satisfying all the requirements of its constraint, the archetype
also has the member names of its constraint. Effectively it is considered to
<a href="#internal-impl">implement the constraint internally</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="extending-an-interface">Extending an interface<a class="hash-link" href="#extending-an-interface" title="Direct link to heading">​</a></h2><p>An interface can be extended by defining an interface that includes the full API
of another interface, plus some additional API. Types implementing the extended
interface should automatically be considered to have implemented the narrower
interface.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="witness-tables">Witness tables<a class="hash-link" href="#witness-tables" title="Direct link to heading">​</a></h2><p><a href="https://forums.swift.org/t/where-does-the-term-witness-table-come-from/54334/4" target="_blank" rel="noopener noreferrer">Witness tables</a>
are an implementation strategy where values passed to a generic parameter are
compiled into a table of required functionality. That table is then filled in
for a given passed-in type with references to the implementation on the original
type. The generic is implemented using calls into entries in the witness table,
which turn into calls to the original type. This doesn&#x27;t necessarily imply a
runtime indirection: it may be a purely compile-time separation of concerns.
However, it insists on a full abstraction boundary between the generic user of a
type and the concrete implementation.</p><p>A simple way to imagine a witness table is as a struct of function pointers, one
per method in the interface. However, in practice, it&#x27;s more complex because it
must model things like associated types and interfaces.</p><p>Witness tables are called &quot;dictionary passing&quot; in Haskell. Outside of generics,
a <a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener noreferrer">vtable</a> is a witness
table that witnesses that a class is a descendant of an abstract base class, and
is passed as part of the object instead of separately.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-dispatch-witness-table">Dynamic-dispatch witness table<a class="hash-link" href="#dynamic-dispatch-witness-table" title="Direct link to heading">​</a></h3><p>For dynamic-dispatch witness tables, actual function pointers are formed and
used as a dynamic, runtime indirection. As a result, the generic code <strong>will
not</strong> be duplicated for different witness tables.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="static-dispatch-witness-table">Static-dispatch witness table<a class="hash-link" href="#static-dispatch-witness-table" title="Direct link to heading">​</a></h3><p>For static-dispatch witness tables, the implementation is required to collapse
the table indirections at compile time. As a result, the generic code <strong>will</strong>
be duplicated for different witness tables.</p><p>Static-dispatch may be implemented as a performance optimization for
dynamic-dispatch that increases generated code size. The final compiled output
may not retain the witness table.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="instantiation">Instantiation<a class="hash-link" href="#instantiation" title="Direct link to heading">​</a></h2><p>Instantiation is the implementation strategy for templates in both C++ and
Carbon. Instantiation explicitly creates a copy of the template code and
replaces the template components with the concrete type and its implementation
operations. It allows duck typing and lazy binding. Instantiation implies
template code <strong>will</strong> be duplicated.</p><p>Unlike <a href="#static-dispatch-witness-table">static-dispatch witness tables</a> and
<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics" target="_blank" rel="noopener noreferrer">monomorphization (as in Rust)</a>,
this is done <strong>before</strong> type checking completes. Only when the template is used
with a concrete type is the template fully type checked, and it type checks
against the actual concrete type after substituting it into the template. This
means that different instantiations may interpret the same construct in
different ways, and that templates can include constructs that are not valid for
some possible instantiations. However, it also means that some errors in the
template implementation may not produce errors until the instantiation occurs,
and other errors may only happen for <strong>some</strong> instantiations.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="specialization">Specialization<a class="hash-link" href="#specialization" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="template-specialization">Template specialization<a class="hash-link" href="#template-specialization" title="Direct link to heading">​</a></h3><p>Specialization in C++ is essentially overloading in the context of a template.
The template is overloaded to have a different definition for some subset of the
possible template argument values. For example, the C++ type <code>std::vector&lt;T&gt;</code>
might have a specialization <code>std::vector&lt;T*&gt;</code> that is implemented in terms of
<code>std::vector&lt;void*&gt;</code> to reduce code size. In C++, even the interface of a
templated type can be changed in a specialization, as happens for
<code>std::vector&lt;bool&gt;</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="generic-specialization">Generic specialization<a class="hash-link" href="#generic-specialization" title="Direct link to heading">​</a></h3><p>Specialization of generics, or types used by generics, is restricted to changing
the implementation <em>without</em> affecting the interface. This restriction is needed
to preserve the ability to perform type checking of generic definitions that
reference a type that can be specialized, without statically knowing which
specialization will be used.</p><p>While there is nothing fundamentally incompatible about specialization with
generics, even when implemented using witness tables, the result may be
surprising because the selection of the specialized generic happens outside of
the witness-table-based indirection between the generic code and the concrete
implementation. Provided all selection relies exclusively on interfaces, this
still satisfies the fundamental constraints of generics.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conditional-conformance">Conditional conformance<a class="hash-link" href="#conditional-conformance" title="Direct link to heading">​</a></h2><p>Conditional conformance is when you have a parameterized type that has one API
that it always supports, but satisfies additional interfaces under some
conditions on the type argument. For example: <code>Array(T)</code> might implement
<code>Comparable</code> if <code>T</code> itself implements <code>Comparable</code>, using lexicographical order.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interface-type-parameters-and-associated-types">Interface type parameters and associated types<a class="hash-link" href="#interface-type-parameters-and-associated-types" title="Direct link to heading">​</a></h2><p>Imagine an interface defining a container. Different containers will contain
different types of values, and the container API will have to refer to that
&quot;element type&quot; when defining the signature of methods like &quot;insert&quot; or &quot;find&quot;.
If that element type is a parameter (input) to the interface type, we say it is
an <em>interface type parameter</em>; if it is an output, we say it is an <em>associated
type</em>. An associated type is a kind of <a href="#associated-entity">associated entity</a>.</p><p>Interface type parameter example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface StackTP(ElementType:! Type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Push[addr me: Self*](value: ElementType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Pop[addr me: Self*]() -&gt; ElementType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Associated type example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface StackAT {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ElementType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Push[addr me: Self*](value: ElementType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Pop[addr me: Self*]() -&gt; ElementType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Associated types are particularly called for when the implementation controls
the type, not the caller. For example, the iterator type for a container is
specific to the container and not something you would expect a user of the
interface to specify.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Iterator { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Container {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // This does not make sense as an parameter to the container interface,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // since this type is determined from the container type.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let IteratorType:! Iterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Insert[addr me: Self*](position: IteratorType, value: ElementType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ListIterator(ElementType:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Iterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class List(ElementType:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Iterator type is determined by the container type.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Container where .IteratorType = ListIterator(ElementType) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Insert[addr me: Self*](position: IteratorType, value: ElementType) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If you have an interface with type parameters, a type can have multiple impls
for different combinations of type parameters. As a result, type parameters may
not be deduced in a function call. However, if the interface parameters are
specified, a type can only have a single implementation of the given interface.
This unique implementation choice determines the values of associated types.</p><p>For example, we might have an interface that says how to perform addition with
another type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Addable(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ResultType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Add[me: Self](rhs: T) -&gt; ResultType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An <code>i32</code> value might support addition with <code>i32</code>, <code>u16</code>, and <code>f64</code> values.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl i32 as Addable(i32) where .ResultType = i32 { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl i32 as Addable(u16) where .ResultType = i32 { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl i32 as Addable(f64) where .ResultType = f64 { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To write a generic function requiring a parameter to be <code>Addable</code>, there needs
to be some way to determine the type to add to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ This is allowed, since the value of `T` is determined by the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `y` parameter.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn DoAdd[T:! Type, U:! Addable(T)](x: U, y: T) -&gt; U.ResultType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return x.Add(y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ This is forbidden, can&#x27;t uniquely determine `T`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn CompileError[T:! Type, U:! Addable(T)](x: U) -&gt; T;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Once the interface parameter can be determined, that determines the values for
associated types, such as <code>ResultType</code> in the example. As always, calls with
types for which no implementation exists will be rejected at the call site:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ This is forbidden, no implementation of `Addable(Orange)`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// for `Apple`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DoAdd(apple, orange);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="type-constraints">Type constraints<a class="hash-link" href="#type-constraints" title="Direct link to heading">​</a></h2><p>Type constraints restrict which types are legal for template or generic
parameters or associated types. They help define semantics under which they
should be called, and prevent incorrect calls.</p><p>In general there are a number of different type relationships we would like to
express, for example:</p><ul><li>This function accepts two containers. The container types may be different,
but the element types need to match.</li><li>For this container interface we have associated types for iterators and
elements. The iterator type&#x27;s element type needs to match the container&#x27;s
element type.</li><li>An interface may define an associated type that needs to be constrained to
implement some interfaces.</li><li>This type must be <a href="#compatible-types">compatible</a> with another type. You
might use this to define alternate implementations of a single interfaces,
such as sorting order, for a single type.</li></ul><p>Note that type constraints can be a restriction on one type parameter or
associated type, or can define a relationship between multiple types.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="type-of-type">Type-of-type<a class="hash-link" href="#type-of-type" title="Direct link to heading">​</a></h2><p>A type-of-type is the type used when declaring some type parameter. It foremost
determines which types are legal arguments for that type parameter, also known
as <a href="#type-constraints">type constraints</a>. For template parameters, that is all a
type-of-type does. For generic parameters, it also determines the API that is
available in the body of the function.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><ul><li><a href="https://github.com/carbon-language/carbon-lang/pull/447" target="_blank" rel="noopener noreferrer">#447: Generics terminology</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/731" target="_blank" rel="noopener noreferrer">#731: Generics details 2: adapters, associated types, parameterized interfaces</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/950" target="_blank" rel="noopener noreferrer">#950: Generic details 6: remove facets</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1013" target="_blank" rel="noopener noreferrer">#1013: Generics: Set associated constants using where constraints</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/design/generics/terminology.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/design/generics/overview/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Generics: Overview</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/design/interoperability/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Bidirectional interoperability with C/C++</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#table-of-contents" class="table-of-contents__link toc-highlight">Table of contents</a></li><li><a href="#parameterized-language-constructs" class="table-of-contents__link toc-highlight">Parameterized language constructs</a></li><li><a href="#generic-versus-template-parameters" class="table-of-contents__link toc-highlight">Generic versus template parameters</a><ul><li><a href="#polymorphism" class="table-of-contents__link toc-highlight">Polymorphism</a></li><li><a href="#constrained-genericity" class="table-of-contents__link toc-highlight">Constrained genericity</a></li><li><a href="#dependent-names" class="table-of-contents__link toc-highlight">Dependent names</a></li><li><a href="#definition-checking" class="table-of-contents__link toc-highlight">Definition checking</a></li></ul></li><li><a href="#deduced-parameter" class="table-of-contents__link toc-highlight">Deduced parameter</a></li><li><a href="#interface" class="table-of-contents__link toc-highlight">Interface</a><ul><li><a href="#structural-interfaces" class="table-of-contents__link toc-highlight">Structural interfaces</a></li><li><a href="#nominal-interfaces" class="table-of-contents__link toc-highlight">Nominal interfaces</a></li><li><a href="#named-constraints" class="table-of-contents__link toc-highlight">Named constraints</a></li></ul></li><li><a href="#associated-entity" class="table-of-contents__link toc-highlight">Associated entity</a></li><li><a href="#impls-implementations-of-interfaces" class="table-of-contents__link toc-highlight">Impls: Implementations of interfaces</a><ul><li><a href="#internal-impl" class="table-of-contents__link toc-highlight">Internal impl</a></li><li><a href="#external-impl" class="table-of-contents__link toc-highlight">External impl</a></li></ul></li><li><a href="#member-access" class="table-of-contents__link toc-highlight">Member access</a><ul><li><a href="#simple-member-access" class="table-of-contents__link toc-highlight">Simple member access</a></li><li><a href="#qualified-member-access-expression" class="table-of-contents__link toc-highlight">Qualified member access expression</a></li></ul></li><li><a href="#compatible-types" class="table-of-contents__link toc-highlight">Compatible types</a></li><li><a href="#subtyping-and-casting" class="table-of-contents__link toc-highlight">Subtyping and casting</a></li><li><a href="#coherence" class="table-of-contents__link toc-highlight">Coherence</a></li><li><a href="#adapting-a-type" class="table-of-contents__link toc-highlight">Adapting a type</a></li><li><a href="#type-erasure" class="table-of-contents__link toc-highlight">Type erasure</a></li><li><a href="#archetype" class="table-of-contents__link toc-highlight">Archetype</a></li><li><a href="#extending-an-interface" class="table-of-contents__link toc-highlight">Extending an interface</a></li><li><a href="#witness-tables" class="table-of-contents__link toc-highlight">Witness tables</a><ul><li><a href="#dynamic-dispatch-witness-table" class="table-of-contents__link toc-highlight">Dynamic-dispatch witness table</a></li><li><a href="#static-dispatch-witness-table" class="table-of-contents__link toc-highlight">Static-dispatch witness table</a></li></ul></li><li><a href="#instantiation" class="table-of-contents__link toc-highlight">Instantiation</a></li><li><a href="#specialization" class="table-of-contents__link toc-highlight">Specialization</a><ul><li><a href="#template-specialization" class="table-of-contents__link toc-highlight">Template specialization</a></li><li><a href="#generic-specialization" class="table-of-contents__link toc-highlight">Generic specialization</a></li></ul></li><li><a href="#conditional-conformance" class="table-of-contents__link toc-highlight">Conditional conformance</a></li><li><a href="#interface-type-parameters-and-associated-types" class="table-of-contents__link toc-highlight">Interface type parameters and associated types</a></li><li><a href="#type-constraints" class="table-of-contents__link toc-highlight">Type constraints</a></li><li><a href="#type-of-type" class="table-of-contents__link toc-highlight">Type-of-type</a></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/ZjVdShJDAs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer" class="footer__link-item">Code of Conduct<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
<script src="/assets/js/runtime~main.576a8e32.js"></script>
<script src="/assets/js/main.52935302.js"></script>
</body>
</html>