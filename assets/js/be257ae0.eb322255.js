"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3119],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(t),m=i,f=d["".concat(s,".").concat(m)]||d[m]||c[m]||r;return t?a.createElement(f,l(l({ref:n},u),{},{components:t})):a.createElement(f,l({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3043:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const r={},l="Functions",o={unversionedId:"docs/design/functions",id:"docs/design/functions",title:"Functions",description:"\x3c!--",source:"@site/../docs/design/functions.md",sourceDirName:"docs/design",slug:"/docs/design/functions",permalink:"/docs/design/functions",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/../docs/design/functions.md",tags:[],version:"current",frontMatter:{},sidebar:"design",previous:{title:"Qualified names and member access",permalink:"/docs/design/expressions/member_access"},next:{title:"Generics",permalink:"/docs/design/generics/"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Function definitions",id:"function-definitions",level:2},{value:"Return clause",id:"return-clause",level:3},{value:"<code>return</code> statements",id:"return-statements",level:3},{value:"Function declarations",id:"function-declarations",level:2},{value:"Function calls",id:"function-calls",level:2},{value:"Functions in other features",id:"functions-in-other-features",level:2},{value:"Alternatives considered",id:"alternatives-considered",level:2},{value:"References",id:"references",level:2}],u={toc:p};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"functions"},"Functions"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Functions are the core building block for applications. Carbon's basic function\nsyntax is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"parameter"),": ",(0,i.kt)("em",{parentName:"li"},"identifier")," ",(0,i.kt)("inlineCode",{parentName:"li"},":")," ",(0,i.kt)("em",{parentName:"li"},"expression")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"parameter-list"),": ",(0,i.kt)("em",{parentName:"li"},"[ parameter")," ",(0,i.kt)("inlineCode",{parentName:"li"},",")," ",(0,i.kt)("em",{parentName:"li"},"parameter")," ",(0,i.kt)("inlineCode",{parentName:"li"},",")," ",(0,i.kt)("em",{parentName:"li"},"... ]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"return-clause"),": ",(0,i.kt)("em",{parentName:"li"},"[")," ",(0,i.kt)("inlineCode",{parentName:"li"},"->")," ",(0,i.kt)("em",{parentName:"li"},"< expression |")," ",(0,i.kt)("inlineCode",{parentName:"li"},"auto")," ",(0,i.kt)("em",{parentName:"li"},"> ]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"signature"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"fn")," ",(0,i.kt)("em",{parentName:"li"},"identifier")," ",(0,i.kt)("inlineCode",{parentName:"li"},"(")," ",(0,i.kt)("em",{parentName:"li"},"parameter-list")," ",(0,i.kt)("inlineCode",{parentName:"li"},")")," ",(0,i.kt)("em",{parentName:"li"},"return-clause")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"function-definition"),": ",(0,i.kt)("em",{parentName:"li"},"signature")," ",(0,i.kt)("inlineCode",{parentName:"li"},"{")," ",(0,i.kt)("em",{parentName:"li"},"statements")," ",(0,i.kt)("inlineCode",{parentName:"li"},"}")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"function-declaration"),": ",(0,i.kt)("em",{parentName:"li"},"signature")," ",(0,i.kt)("inlineCode",{parentName:"li"},";")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"function-call"),": ",(0,i.kt)("em",{parentName:"li"},"identifier")," ",(0,i.kt)("inlineCode",{parentName:"li"},"(")," ",(0,i.kt)("em",{parentName:"li"},"[ expression")," ",(0,i.kt)("inlineCode",{parentName:"li"},",")," ",(0,i.kt)("em",{parentName:"li"},"expression")," ",(0,i.kt)("inlineCode",{parentName:"li"},",")," ",(0,i.kt)("em",{parentName:"li"},"...\n]")," ",(0,i.kt)("inlineCode",{parentName:"li"},")"))),(0,i.kt)("p",null,"A function with only a signature and no body is a function declaration, or\nforward declaration. When the body is a present, it's a function definition. The\nbody introduces nested scopes which may contain local variable declarations."),(0,i.kt)("h2",{id:"function-definitions"},"Function definitions"),(0,i.kt)("p",null,"A basic function definition may look like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Add(a: i64, b: i64) -> i64 {\n  return a + b;\n}\n")),(0,i.kt)("p",null,"This declares a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," which accepts two ",(0,i.kt)("inlineCode",{parentName:"p"},"i64")," parameters, the\nfirst called ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and the second called ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),", and returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"i64")," result. It\nreturns the result of adding the two arguments."),(0,i.kt)("p",null,"C++ might declare the same thing:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"std::int64_t Add(std::int64_t a, std::int64_t b) {\n  return a + b;\n}\n\n// Or with trailing return type syntax:\nauto Add(std::int64_t a, std::int64_t b) -> std::int64_t {\n  return a + b;\n}\n")),(0,i.kt)("h3",{id:"return-clause"},"Return clause"),(0,i.kt)("p",null,"The return clause of a function specifies the return type using one of three\npossible syntaxes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"->")," followed by an ",(0,i.kt)("em",{parentName:"li"},"expression"),", such as ",(0,i.kt)("inlineCode",{parentName:"li"},"i64"),", directly states the return\ntype. This expression will be evaluated at compile-time, so must be valid in\nthat context.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For example, ",(0,i.kt)("inlineCode",{parentName:"li"},"fn ToString(val: i64) -> String;")," has a return type of\n",(0,i.kt)("inlineCode",{parentName:"li"},"String"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"->")," followed by the ",(0,i.kt)("inlineCode",{parentName:"li"},"auto")," keyword indicates that\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/type_inference"},"type inference")," should be used to determine the return\ntype.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For example, ",(0,i.kt)("inlineCode",{parentName:"li"},"fn Echo(val: i64) -> auto { return val; }")," will have a\nreturn type of ",(0,i.kt)("inlineCode",{parentName:"li"},"i64")," through type inference."),(0,i.kt)("li",{parentName:"ul"},"Declarations must have a known return type, so ",(0,i.kt)("inlineCode",{parentName:"li"},"auto")," is not valid."),(0,i.kt)("li",{parentName:"ul"},"The function must have precisely one ",(0,i.kt)("inlineCode",{parentName:"li"},"return")," statement. That ",(0,i.kt)("inlineCode",{parentName:"li"},"return"),"\nstatement's expression will then be used for type inference."))),(0,i.kt)("li",{parentName:"ul"},"Omission indicates that the return type is the empty tuple, ",(0,i.kt)("inlineCode",{parentName:"li"},"()"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For example, ",(0,i.kt)("inlineCode",{parentName:"li"},"fn Sleep(seconds: i64);")," is similar to\n",(0,i.kt)("inlineCode",{parentName:"li"},"fn Sleep(seconds: i64) -> ();"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"()")," is similar to a ",(0,i.kt)("inlineCode",{parentName:"li"},"void")," return type in C++.")))),(0,i.kt)("h3",{id:"return-statements"},(0,i.kt)("inlineCode",{parentName:"h3"},"return")," statements"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/control_flow/return"},(0,i.kt)("inlineCode",{parentName:"a"},"return")," statement")," is essential to function\ncontrol flow. It ends the flow of the function and returns execution to the\ncaller."),(0,i.kt)("p",null,"When the ",(0,i.kt)("a",{parentName:"p",href:"#return-clause"},"return clause")," is omitted, the ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement has\nno expression argument, and function control flow implicitly ends after the last\nstatement in the function's body as if ",(0,i.kt)("inlineCode",{parentName:"p"},"return;")," were present."),(0,i.kt)("p",null,"When the return clause is provided, including when it is ",(0,i.kt)("inlineCode",{parentName:"p"},"-> ()"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),"\nstatement must have an expression that is convertible to the return type, and a\n",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement must be used to end control flow of the function."),(0,i.kt)("h2",{id:"function-declarations"},"Function declarations"),(0,i.kt)("p",null,"Functions may be declared separate from the definition by providing only a\nsignature, with no body. This provides an API which may be called. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"// Declaration:\nfn Add(a: i64, b: i64) -> i64;\n\n// Definition:\nfn Add(a: i64, b: i64) -> i64 {\n  return a + b;\n}\n")),(0,i.kt)("p",null,"The corresponding definition may be provided later in the same file or, when the\ndeclaration is in an\n",(0,i.kt)("a",{parentName:"p",href:"code_and_name_organization/#libraries"},(0,i.kt)("inlineCode",{parentName:"a"},"api")," file of a library"),", in the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"\nfile of the same library. The signature of a function declaration must match the\ncorresponding definition. This includes the ",(0,i.kt)("a",{parentName:"p",href:"#return-clause"},"return clause"),";\neven though an omitted return type has equivalent behavior to ",(0,i.kt)("inlineCode",{parentName:"p"},"-> ()"),", the\npresence or omission must match."),(0,i.kt)("h2",{id:"function-calls"},"Function calls"),(0,i.kt)("p",null,"Function calls use a function's identifier to pass multiple expression arguments\ncorresponding to the function signature's parameters. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Add(a: i64, b: i64) -> i64 {\n  return a + b;\n}\n\nfn Run() {\n  Add(1, 2);\n}\n")),(0,i.kt)("p",null,"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"Add(1, 2)")," is a function call expression. ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," refers to the function\ndefinition's identifier. The parenthesized arguments ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," are passed to\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," parameters of ",(0,i.kt)("inlineCode",{parentName:"p"},"Add"),"."),(0,i.kt)("h2",{id:"functions-in-other-features"},"Functions in other features"),(0,i.kt)("p",null,"Other designs build upon basic function syntax to add advanced features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/generics/overview#generic-functions"},"Generic functions")," adds support for\ndeduced parameters and generic type parameters."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes#member-functions"},"Class member functions")," adds support for\nmethods and class functions.")),(0,i.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0438.md#function-keyword"},"Function keyword")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0826.md#only-allow-auto-return-types-if-parameters-are-generic"},"Only allow ",(0,i.kt)("inlineCode",{parentName:"a"},"auto")," return types if parameters are generic")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0826.md#provide-alternate-function-syntax-for-concise-return-type-inference"},"Provide alternate function syntax for concise return type inference")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0826.md#allow-separate-declaration-and-definition"},"Allow separate declaration and definition"))),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/438"},"#438: Add statement syntax for function declarations")),(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/826"},"#826: Function return type inference"))))}c.isMDXComponent=!0}}]);